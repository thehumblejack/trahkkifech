import { b as _u, c as navigator, d as window, f as Jt } from "./chunk-ENK4YSX5.mjs"; var _t = {}; _u(_t, { Children: () => Rn, Component: () => ve, Fragment: () => Uo, Profiler: () => iC, PureComponent: () => oC, StrictMode: () => sC, Suspense: () => Xo, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => aC, cloneElement: () => mn, createContext: () => ge, createElement: () => Du, createFactory: () => lC, createRef: () => $m, default: () => b, forwardRef: () => Ne, isValidElement: () => en, lazy: () => cC, memo: () => uC, startTransition: () => Ai, unstable_act: () => fC, useCallback: () => pe, useContext: () => O, useDebugValue: () => dC, useDeferredValue: () => hC, useEffect: () => H, useId: () => ei, useImperativeHandle: () => pC, useInsertionEffect: () => ct, useLayoutEffect: () => Pn, useMemo: () => he, useReducer: () => mC, useRef: () => D, useState: () => ut, useSyncExternalStore: () => vC, useTransition: () => gC, version: () => yC }); Jt(); var b = {}, Wo = Symbol.for("react.element"), jk = Symbol.for("react.portal"), Wk = Symbol.for("react.fragment"), Uk = Symbol.for("react.strict_mode"), Xk = Symbol.for("react.profiler"), Yk = Symbol.for("react.provider"), Gk = Symbol.for("react.context"), Kk = Symbol.for("react.forward_ref"), qk = Symbol.for("react.suspense"), Qk = Symbol.for("react.memo"), Zk = Symbol.for("react.lazy"), _m = Symbol.iterator; function Jk(e) { return e === null || typeof e != "object" ? null : (e = _m && e[_m] || e["@@iterator"], typeof e == "function" ? e : null) } var Lm = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Mm = Object.assign, Om = {}; function Di(e, t, n) { this.props = e, this.context = t, this.refs = Om, this.updater = n || Lm } Di.prototype.isReactComponent = {}; Di.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; Di.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function Dm() { } Dm.prototype = Di.prototype; function Iu(e, t, n) { this.props = e, this.context = t, this.refs = Om, this.updater = n || Lm } var Lu = Iu.prototype = new Dm; Lu.constructor = Iu; Mm(Lu, Di.prototype); Lu.isPureReactComponent = !0; var Fm = Array.isArray, Am = Object.prototype.hasOwnProperty, Mu = { current: null }, Vm = { key: !0, ref: !0, __self: !0, __source: !0 }; function Bm(e, t, n) { var r, i = {}, o = null, s = null; if (t != null) for (r in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (o = "" + t.key), t) Am.call(t, r) && !Vm.hasOwnProperty(r) && (i[r] = t[r]); var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { for (var l = Array(a), c = 0; c < a; c++)l[c] = arguments[c + 2]; i.children = l } if (e && e.defaultProps) for (r in a = e.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: Wo, type: e, key: o, ref: s, props: i, _owner: Mu.current } } function eC(e, t) { return { $$typeof: Wo, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function Ou(e) { return typeof e == "object" && e !== null && e.$$typeof === Wo } function tC(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var Im = /\/+/g; function Fu(e, t) { return typeof e == "object" && e !== null && e.key != null ? tC("" + e.key) : t.toString(36) } function Aa(e, t, n, r, i) { var o = typeof e; o !== "undefined" && o !== "boolean" || (e = null); var s = !1; if (e === null) s = !0; else switch (o) { case "string": case "number": s = !0; break; case "object": switch (e.$$typeof) { case Wo: case jk: s = !0 } }if (s) return s = e, i = i(s), e = r === "" ? "." + Fu(s, 0) : r, Fm(i) ? (n = "", e != null && (n = e.replace(Im, "$&/") + "/"), Aa(i, t, n, "", function (c) { return c })) : i != null && (Ou(i) && (i = eC(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(Im, "$&/") + "/") + e)), t.push(i)), 1; if (s = 0, r = r === "" ? "." : r + ":", Fm(e)) for (var a = 0; a < e.length; a++) { o = e[a]; var l = r + Fu(o, a); s += Aa(o, t, n, l, i) } else if (l = Jk(e), typeof l == "function") for (e = l.call(e), a = 0; !(o = e.next()).done;)o = o.value, l = r + Fu(o, a++), s += Aa(o, t, n, l, i); else if (o === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return s } function Da(e, t, n) { if (e == null) return e; var r = [], i = 0; return Aa(e, r, "", "", function (o) { return t.call(n, o, i++) }), r } function nC(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { e._status !== 0 && e._status !== -1 || (e._status = 1, e._result = n) }, function (n) { e._status !== 0 && e._status !== -1 || (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var xt = { current: null }, Va = { transition: null }, rC = { ReactCurrentDispatcher: xt, ReactCurrentBatchConfig: Va, ReactCurrentOwner: Mu }; b.Children = { map: Da, forEach: function (e, t, n) { Da(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return Da(e, function () { t++ }), t }, toArray: function (e) { return Da(e, function (t) { return t }) || [] }, only: function (e) { if (!Ou(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; b.Component = Di; b.Fragment = Wk; b.Profiler = Xk; b.PureComponent = Iu; b.StrictMode = Uk; b.Suspense = qk; b.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = rC; b.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = Mm({}, e.props), i = e.key, o = e.ref, s = e._owner; if (t != null) { if (t.ref !== void 0 && (o = t.ref, s = Mu.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) Am.call(t, l) && !Vm.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var c = 0; c < l; c++)a[c] = arguments[c + 2]; r.children = a } return { $$typeof: Wo, type: e.type, key: i, ref: o, props: r, _owner: s } }; b.createContext = function (e) { return e = { $$typeof: Gk, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: Yk, _context: e }, e.Consumer = e }; b.createElement = Bm; b.createFactory = function (e) { var t = Bm.bind(null, e); return t.type = e, t }; b.createRef = function () { return { current: null } }; b.forwardRef = function (e) { return { $$typeof: Kk, render: e } }; b.isValidElement = Ou; b.lazy = function (e) { return { $$typeof: Zk, _payload: { _status: -1, _result: e }, _init: nC } }; b.memo = function (e, t) { return { $$typeof: Qk, type: e, compare: t === void 0 ? null : t } }; b.startTransition = function (e) { var t = Va.transition; Va.transition = {}; try { e() } finally { Va.transition = t } }; b.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; b.useCallback = function (e, t) { return xt.current.useCallback(e, t) }; b.useContext = function (e) { return xt.current.useContext(e) }; b.useDebugValue = function () { }; b.useDeferredValue = function (e) { return xt.current.useDeferredValue(e) }; b.useEffect = function (e, t) { return xt.current.useEffect(e, t) }; b.useId = function () { return xt.current.useId() }; b.useImperativeHandle = function (e, t, n) { return xt.current.useImperativeHandle(e, t, n) }; b.useInsertionEffect = function (e, t) { return xt.current.useInsertionEffect(e, t) }; b.useLayoutEffect = function (e, t) { return xt.current.useLayoutEffect(e, t) }; b.useMemo = function (e, t) { return xt.current.useMemo(e, t) }; b.useReducer = function (e, t, n) { return xt.current.useReducer(e, t, n) }; b.useRef = function (e) { return xt.current.useRef(e) }; b.useState = function (e) { return xt.current.useState(e) }; b.useSyncExternalStore = function (e, t, n) { return xt.current.useSyncExternalStore(e, t, n) }; b.useTransition = function () { return xt.current.useTransition() }; b.version = "18.2.0"; var Rn = b.Children, ve = b.Component, Uo = b.Fragment, iC = b.Profiler, oC = b.PureComponent, sC = b.StrictMode, Xo = b.Suspense, aC = b.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, mn = b.cloneElement, ge = b.createContext, Du = b.createElement, lC = b.createFactory, $m = b.createRef, Ne = b.forwardRef, en = b.isValidElement, cC = b.lazy, uC = b.memo, Ai = b.startTransition, fC = b.unstable_act, pe = b.useCallback, O = b.useContext, dC = b.useDebugValue, hC = b.useDeferredValue, H = b.useEffect, ei = b.useId, pC = b.useImperativeHandle, ct = b.useInsertionEffect, Pn = b.useLayoutEffect, he = b.useMemo, mC = b.useReducer, D = b.useRef, ut = b.useState, vC = b.useSyncExternalStore, gC = b.useTransition, yC = b.version; Jt(); var bC = "default" in _t ? b : _t, Vi = {}, xC = bC, SC = Symbol.for("react.element"), wC = Symbol.for("react.fragment"), kC = Object.prototype.hasOwnProperty, CC = xC.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, TC = { key: !0, ref: !0, __self: !0, __source: !0 }; function zm(e, t, n) { var r, i = {}, o = null, s = null; n !== void 0 && (o = "" + n), t.key !== void 0 && (o = "" + t.key), t.ref !== void 0 && (s = t.ref); for (r in t) kC.call(t, r) && !TC.hasOwnProperty(r) && (i[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]); return { $$typeof: SC, type: e, key: o, ref: s, props: i, _owner: CC.current } } Vi.Fragment = wC; Vi.jsx = zm; Vi.jsxs = zm; var Le = Vi.Fragment, C = Vi.jsx, ae = Vi.jsxs; Jt(); var EC = Object.create, pf = Object.defineProperty, RC = Object.getOwnPropertyDescriptor, og = Object.getOwnPropertyNames, PC = Object.getPrototypeOf, _C = Object.prototype.hasOwnProperty, FC = (e, t, n) => t in e ? pf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, rn = (e, t) => function () { return t || (0, e[og(e)[0]])((t = { exports: {} }).exports, t), t.exports }, IC = (e, t, n, r) => { if (t && typeof t == "object" || typeof t == "function") for (let i of og(t)) !_C.call(e, i) && i !== n && pf(e, i, { get: () => t[i], enumerable: !(r = RC(t, i)) || r.enumerable }); return e }, Dn = (e, t, n) => (n = e != null ? EC(PC(e)) : {}, IC(t || !e || !e.__esModule ? pf(n, "default", { value: e, enumerable: !0 }) : n, e)), R = (e, t, n) => (FC(e, typeof t != "symbol" ? t + "" : t, n), n), mf = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, li = (e, t, n) => (mf(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Wi = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, vf = (e, t, n, r) => (mf(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), It = (e, t, n) => (mf(e, t, "access private method"), n), LC = rn({ "../../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); function t(n) { var r = {}; return function (i) { return r[i] === void 0 && (r[i] = n(i)), r[i] } } e.default = t } }), MC = rn({ "../../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); function t(o) { return o && typeof o == "object" && "default" in o ? o.default : o } var n = t(LC()), r = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, i = n(function (o) { return r.test(o) || o.charCodeAt(0) === 111 && o.charCodeAt(1) === 110 && o.charCodeAt(2) < 91 }); e.default = i } }), On = ge({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }), as = ge({}), Ui = ge(null), Ja = typeof document < "u", Sr = Ja ? Pn : H, gf = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), OC = "framerAppearId", el = "data-" + gf(OC), tl = { skipAnimations: !1, useManualTiming: !1 }, rs = ge({}), nl = ge({}), sg = ge({ strict: !1 }), Nm = class { constructor() { this.order = [], this.scheduled = new Set } add(e) { if (!this.scheduled.has(e)) return this.scheduled.add(e), this.order.push(e), !0 } remove(e) { let t = this.order.indexOf(e); t !== -1 && (this.order.splice(t, 1), this.scheduled.delete(e)) } clear() { this.order.length = 0, this.scheduled.clear() } }; function DC(e) { let t = new Nm, n = new Nm, r = 0, i = !1, o = !1, s = new WeakSet, a = { schedule: (l, c = !1, u = !1) => { let f = u && i, d = f ? t : n; return c && s.add(l), d.add(l) && f && i && (r = t.order.length), l }, cancel: l => { n.remove(l), s.delete(l) }, process: l => { if (i) { o = !0; return } if (i = !0, [t, n] = [n, t], n.clear(), r = t.order.length, r) for (let c = 0; c < r; c++) { let u = t.order[c]; s.has(u) && (a.schedule(u), e()), u(l) } i = !1, o && (o = !1, a.process(l)) } }; return a } var Ko = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], AC = 40; function ag(e, t) { let n = !1, r = !0, i = { delta: 0, timestamp: 0, isProcessing: !1 }, o = Ko.reduce((f, d) => (f[d] = DC(() => n = !0), f), {}), s = f => { o[f].process(i) }, a = () => { let f = tl.useManualTiming ? i.timestamp : performance.now(); n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(f - i.timestamp, AC), 1), i.timestamp = f, i.isProcessing = !0, Ko.forEach(s), i.isProcessing = !1, n && t && (r = !1, e(a)) }, l = () => { n = !0, r = !0, i.isProcessing || e(a) }; return { schedule: Ko.reduce((f, d) => { let p = o[d]; return f[d] = (g, v = !1, S = !1) => (n || l(), p.schedule(g, v, S)), f }, {}), cancel: f => Ko.forEach(d => o[d].cancel(f)), state: i, steps: o } } var { schedule: yf, cancel: X4 } = ag(queueMicrotask, !1); function VC(e, t, n, r) { let { visualElement: i } = O(as), o = O(sg), s = O(Ui), a = O(On).reducedMotion, l = D(); r = r || o.renderer, !l.current && r && (l.current = r(e, { visualState: t, parent: i, props: n, presenceContext: s, blockInitialAnimation: s ? s.initial === !1 : !1, reducedMotionConfig: a })); let c = l.current; ct(() => { c && c.update(n, s) }); let u = D(!!(n[el] && !window.HandoffComplete)); return Sr(() => { c && (yf.render(c.render), u.current && c.animationState && c.animationState.animateChanges()) }), H(() => { c && (c.updateFeatures(), !u.current && c.animationState && c.animationState.animateChanges(), u.current && (u.current = !1, window.HandoffComplete = !0)) }), c } function Bi(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function BC(e, t, n) { return pe(r => { r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : Bi(n) && (n.current = r)) }, [t]) } function is(e) { return typeof e == "string" || Array.isArray(e) } function rl(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } var bf = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], xf = ["initial", ...bf]; function il(e) { return rl(e.animate) || xf.some(t => is(e[t])) } function lg(e) { return !!(il(e) || e.variants) } function $C(e, t) { if (il(e)) { let { initial: n, animate: r } = e; return { initial: n === !1 || is(n) ? n : void 0, animate: is(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function zC(e) { let { initial: t, animate: n } = $C(e, O(as)); return he(() => ({ initial: t, animate: n }), [Hm(t), Hm(n)]) } function Hm(e) { return Array.isArray(e) ? e.join(" ") : e } var jm = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, os = {}; for (let e in jm) os[e] = { isEnabled: t => jm[e].some(n => !!t[n]) }; function NC(e) { for (let t in e) os[t] = { ...os[t], ...e[t] } } var Sf = Symbol.for("motionComponentSymbol"); function cg({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: i }) { e && NC(e); function o(a, l) { let c, u = { ...O(On), ...a, layoutId: HC(a) }, { isStatic: f } = u, d = zC(a), p = r(a, f); if (!f && Ja) { d.visualElement = VC(i, p, u, t); let g = O(nl), v = O(sg).strict; d.visualElement && (c = d.visualElement.loadFeatures(u, v, e, g)) } return ae(as.Provider, { value: d, children: [c && d.visualElement ? C(c, { visualElement: d.visualElement, ...u }) : null, n(i, a, BC(p, d.visualElement, l), p, f, d.visualElement)] }) } let s = Ne(o); return s[Sf] = i, s } function HC({ layoutId: e }) { let t = O(rs).id; return t && e !== void 0 ? t + "-" + e : e } var Ua = {}; function wf(e) { Object.assign(Ua, e) } var Te = e => !!(e && e.getVelocity), ls = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], ci = new Set(ls), jC = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, WC = ls.length; function ug(e, { enableHardwareAcceleration: t = !0, allowTransformNone: n = !0 }, r, i) { let o = ""; for (let s = 0; s < WC; s++) { let a = ls[s]; if (e[a] !== void 0) { let l = jC[a] || a; o += `${l}(${e[a]}) ` } } return t && !e.z && (o += "translateZ(0)"), o = o.trim(), i ? o = i(e, r ? "" : o) : n && r && (o = "none"), o } var Jn = (e, t, n) => n > t ? t : n < e ? e : n, Qo = e => Math.round(e * 1e5) / 1e5, kf = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, UC = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, XC = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function cs(e) { return typeof e == "string" } var us = e => ({ test: t => cs(t) && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), vr = us("deg"), _n = us("%"), G = us("px"), YC = us("vh"), GC = us("vw"), Wm = { ..._n, parse: e => _n.parse(e) / 100, transform: e => _n.transform(e * 100) }, KC = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function Hi(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || KC.has(e) } var fg = e => !Hi(e); function dg(e) { e && (fg = t => t.startsWith("on") ? !Hi(t) : e(t)) } try { dg(MC().default) } catch { } function hg(e, t, n) { let r = {}; for (let i in e) i === "values" && typeof e.values == "object" || (fg(i) || n === !0 && Hi(i) || !t && !Hi(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]); return r } var Ku = e => Array.isArray(e), qC = e => !!(e && typeof e == "object" && e.mix && e.toValue), QC = e => Ku(e) ? e[e.length - 1] || 0 : e; function ft(e) { let t = Te(e) ? e.get() : e; return qC(t) ? t.toValue() : t } function Um(e) { let t = [{}, {}]; return e?.values.forEach((n, r) => { t[0][r] = n.get(), t[1][r] = n.getVelocity() }), t } function Cf(e, t, n, r) { if (typeof t == "function") { let [i, o] = Um(r); t = t(n !== void 0 ? n : e.custom, i, o) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { let [i, o] = Um(r); t = t(n !== void 0 ? n : e.custom, i, o) } return t } function vn(e) { let t = D(null); return t.current === null && (t.current = e()), t.current } function ZC({ scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n }, r, i, o) { let s = { latestValues: JC(r, i, o, e), renderState: t() }; return n && (s.mount = a => n(r, a, s)), s } var ol = e => (t, n) => { let r = O(as), i = O(Ui), o = () => ZC(e, t, r, i); return n ? o() : vn(o) }; function JC(e, t, n, r) { let i = {}, o = r(e, {}); for (let d in o) i[d] = ft(o[d]); let { initial: s, animate: a } = e, l = il(e), c = lg(e); t && c && !l && e.inherit !== !1 && (s === void 0 && (s = t.initial), a === void 0 && (a = t.animate)); let u = n ? n.initial === !1 : !1; u = u || s === !1; let f = u ? a : s; return f && typeof f != "boolean" && !rl(f) && (Array.isArray(f) ? f : [f]).forEach(p => { let g = Cf(e, p); if (!g) return; let { transitionEnd: v, transition: S, ...m } = g; for (let h in m) { let y = m[h]; if (Array.isArray(y)) { let x = u ? y.length - 1 : 0; y = y[x] } y !== null && (i[h] = y) } for (let h in v) i[h] = v[h] }), i } var nt = e => e, { schedule: Y, cancel: dt, state: Oe, steps: za } = ag(typeof requestAnimationFrame < "u" ? requestAnimationFrame : nt, !0), pg = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1; function sl(e, t = "page") { return { point: { x: e[`${t}X`], y: e[`${t}Y`] } } } var mg = e => t => pg(t) && e(t, sl(t)); function Zn(e, t, n, r = { passive: !0 }) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } function Fn(e, t, n, r) { return Zn(e, t, mg(n), r) } var eT = (e, t) => n => t(e(n)), In = (...e) => e.reduce(eT); function vg(e) { let t = null; return () => { let n = () => { t = null }; return t === null ? (t = e, n) : !1 } } var Xm = vg("dragHorizontal"), Ym = vg("dragVertical"); function gg(e) { let t = !1; if (e === "y") t = Ym(); else if (e === "x") t = Xm(); else { let n = Xm(), r = Ym(); n && r ? t = () => { n(), r() } : (n && n(), r && r()) } return t } function Tf() { let e = gg(!0); return e ? (e(), !1) : !0 } var Xi = nt, zt = nt, Yi = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, Zo = { ...Yi, transform: e => Jn(0, 1, e) }, Ba = { ...Yi, default: 1 }, Ef = (e, t) => n => !!(cs(n) && XC.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t)), yg = (e, t, n) => r => { if (!cs(r)) return r; let [i, o, s, a] = r.match(kf); return { [e]: parseFloat(i), [t]: parseFloat(o), [n]: parseFloat(s), alpha: a !== void 0 ? parseFloat(a) : 1 } }, tT = e => Jn(0, 255, e), Au = { ...Yi, transform: e => Math.round(tT(e)) }, oi = { test: Ef("rgb", "red"), parse: yg("red", "green", "blue"), transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + Au.transform(e) + ", " + Au.transform(t) + ", " + Au.transform(n) + ", " + Qo(Zo.transform(r)) + ")" }; function nT(e) { let t = "", n = "", r = "", i = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } var qu = { test: Ef("#"), parse: nT, transform: oi.transform }, $i = { test: Ef("hsl", "hue"), parse: yg("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + _n.transform(Qo(t)) + ", " + _n.transform(Qo(n)) + ", " + Qo(Zo.transform(r)) + ")" }, tt = { test: e => oi.test(e) || qu.test(e) || $i.test(e), parse: e => oi.test(e) ? oi.parse(e) : $i.test(e) ? $i.parse(e) : qu.parse(e), transform: e => cs(e) ? e : e.hasOwnProperty("red") ? oi.transform(e) : $i.transform(e) }; function rT(e) { var t, n; return isNaN(e) && cs(e) && (((t = e.match(kf)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(UC)) === null || n === void 0 ? void 0 : n.length) || 0) > 0 } var bg = "number", xg = "color", iT = "var", oT = "var(", Gm = "${}", sT = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function ss(e) { let t = e.toString(), n = [], r = { color: [], number: [], var: [] }, i = [], o = 0, a = t.replace(sT, l => (tt.test(l) ? (r.color.push(o), i.push(xg), n.push(tt.parse(l))) : l.startsWith(oT) ? (r.var.push(o), i.push(iT), n.push(l)) : (r.number.push(o), i.push(bg), n.push(parseFloat(l))), ++o, Gm)).split(Gm); return { values: n, split: a, indexes: r, types: i } } function Sg(e) { return ss(e).values } function wg(e) { let { split: t, types: n } = ss(e), r = t.length; return i => { let o = ""; for (let s = 0; s < r; s++)if (o += t[s], i[s] !== void 0) { let a = n[s]; a === bg ? o += Qo(i[s]) : a === xg ? o += tt.transform(i[s]) : o += i[s] } return o } } var aT = e => typeof e == "number" ? 0 : e; function lT(e) { let t = Sg(e); return wg(e)(t.map(aT)) } var er = { test: rT, parse: Sg, createTransformer: wg, getAnimatableNone: lT }, Ln = e => e * 1e3, Mn = e => e / 1e3; function Rf(e, t) { return t ? e * (1e3 / t) : 0 } var cT = 5; function kg(e, t, n) { let r = Math.max(t - cT, 0); return Rf(n - e(r), t - r) } var Vu = .001, uT = .01, Km = 10, fT = .05, dT = 1; function hT({ duration: e = 800, bounce: t = .25, velocity: n = 0, mass: r = 1 }) { let i, o; Xi(e <= Ln(Km), "Spring duration must be 10 seconds or less"); let s = 1 - t; s = Jn(fT, dT, s), e = Jn(uT, Km, Mn(e)), s < 1 ? (i = c => { let u = c * s, f = u * e, d = u - n, p = Qu(c, s), g = Math.exp(-f); return Vu - d / p * g }, o = c => { let f = c * s * e, d = f * n + n, p = Math.pow(s, 2) * Math.pow(c, 2) * e, g = Math.exp(-f), v = Qu(Math.pow(c, 2), s); return (-i(c) + Vu > 0 ? -1 : 1) * ((d - p) * g) / v }) : (i = c => { let u = Math.exp(-c * e), f = (c - n) * e + 1; return -Vu + u * f }, o = c => { let u = Math.exp(-c * e), f = (n - c) * (e * e); return u * f }); let a = 5 / e, l = mT(i, o, a); if (e = Ln(e), isNaN(l)) return { stiffness: 100, damping: 10, duration: e }; { let c = Math.pow(l, 2) * r; return { stiffness: c, damping: s * 2 * Math.sqrt(r * c), duration: e } } } var pT = 12; function mT(e, t, n) { let r = n; for (let i = 1; i < pT; i++)r = r - e(r) / t(r); return r } function Qu(e, t) { return e * Math.sqrt(1 - t * t) } var vT = ["duration", "bounce"], gT = ["stiffness", "damping", "mass"]; function qm(e, t) { return t.some(n => e[n] !== void 0) } function yT(e) { let t = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...e }; if (!qm(e, gT) && qm(e, vT)) { let n = hT(e); t = { ...t, ...n, mass: 1 }, t.isResolvedFromDuration = !0 } return t } function fs({ keyframes: e, restDelta: t, restSpeed: n, ...r }) { let i = e[0], o = e[e.length - 1], s = { done: !1, value: i }, { stiffness: a, damping: l, mass: c, duration: u, velocity: f, isResolvedFromDuration: d } = yT({ ...r, velocity: -Mn(r.velocity || 0) }), p = f || 0, g = l / (2 * Math.sqrt(a * c)), v = o - i, S = Mn(Math.sqrt(a / c)), m = Math.abs(v) < 5; n || (n = m ? .01 : 2), t || (t = m ? .005 : .5); let h; if (g < 1) { let y = Qu(S, g); h = x => { let k = Math.exp(-g * S * x); return o - k * ((p + g * S * v) / y * Math.sin(y * x) + v * Math.cos(y * x)) } } else if (g === 1) h = y => o - Math.exp(-S * y) * (v + (p + S * v) * y); else { let y = S * Math.sqrt(g * g - 1); h = x => { let k = Math.exp(-g * S * x), w = Math.min(y * x, 300); return o - k * ((p + g * S * v) * Math.sinh(w) + y * v * Math.cosh(w)) / y } } return { calculatedDuration: d && u || null, next: y => { let x = h(y); if (d) s.done = y >= u; else { let k = p; y !== 0 && (g < 1 ? k = kg(h, y, x) : k = 0); let w = Math.abs(k) <= n, T = Math.abs(o - x) <= t; s.done = w && T } return s.value = s.done ? o : x, s } } } var Cg = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, bT = 1e-7, xT = 12; function ST(e, t, n, r, i) { let o, s, a = 0; do s = t + (n - t) / 2, o = Cg(s, r, i) - e, o > 0 ? n = s : t = s; while (Math.abs(o) > bT && ++a < xT); return s } function Gi(e, t, n, r) { if (e === t && n === r) return nt; let i = o => ST(o, 0, 1, e, n); return o => o === 0 || o === 1 ? o : Cg(i(o), t, r) } var Tg = Gi(.42, 0, 1, 1), Eg = Gi(0, 0, .58, 1), Pf = Gi(.42, 0, .58, 1), _f = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, Ff = e => t => 1 - e(1 - t), al = e => 1 - Math.sin(Math.acos(e)), If = Ff(al), Rg = _f(al), Lf = Gi(.33, 1.53, .69, .99), ll = Ff(Lf), Pg = _f(ll), _g = e => (e *= 2) < 1 ? .5 * ll(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), xr = (e, t, n) => { let r = t - e; return r === 0 ? 1 : (n - e) / r }, xe = (e, t, n) => e + (t - e) * n; function Bu(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function wT({ hue: e, saturation: t, lightness: n, alpha: r }) { e /= 360, t /= 100, n /= 100; let i = 0, o = 0, s = 0; if (!t) i = o = s = n; else { let a = n < .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a; i = Bu(l, a, e + 1 / 3), o = Bu(l, a, e), s = Bu(l, a, e - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(o * 255), blue: Math.round(s * 255), alpha: r } } function Xa(e, t) { return n => n > 0 ? t : e } var $u = (e, t, n) => { let r = e * e, i = n * (t * t - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, kT = [qu, oi, $i], CT = e => kT.find(t => t.test(e)); function Qm(e) { let t = CT(e); if (Xi(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`), !t) return !1; let n = t.parse(e); return t === $i && (n = wT(n)), n } var Zm = (e, t) => { let n = Qm(e), r = Qm(t); if (!n || !r) return Xa(e, t); let i = { ...n }; return o => (i.red = $u(n.red, r.red, o), i.green = $u(n.green, r.green, o), i.blue = $u(n.blue, r.blue, o), i.alpha = xe(n.alpha, r.alpha, o), oi.transform(i)) }, Fg = e => t => typeof t == "string" && t.startsWith(e), Ig = Fg("--"), TT = Fg("var(--"), Mf = e => TT(e) ? ET.test(e.split("/*")[0].trim()) : !1, ET = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Zu = new Set(["none", "hidden"]); function RT(e, t) { return Zu.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e } function PT(e, t) { return n => xe(e, t, n) } function Of(e) { return typeof e == "number" ? PT : typeof e == "string" ? Mf(e) ? Xa : tt.test(e) ? Zm : IT : Array.isArray(e) ? Lg : typeof e == "object" ? tt.test(e) ? Zm : _T : Xa } function Lg(e, t) { let n = [...e], r = n.length, i = e.map((o, s) => Of(o)(o, t[s])); return o => { for (let s = 0; s < r; s++)n[s] = i[s](o); return n } } function _T(e, t) { let n = { ...e, ...t }, r = {}; for (let i in n) e[i] !== void 0 && t[i] !== void 0 && (r[i] = Of(e[i])(e[i], t[i])); return i => { for (let o in r) n[o] = r[o](i); return n } } function FT(e, t) { var n; let r = [], i = { color: 0, var: 0, number: 0 }; for (let o = 0; o < t.values.length; o++) { let s = t.types[o], a = e.indexes[s][i[s]], l = (n = e.values[a]) !== null && n !== void 0 ? n : 0; r[o] = l, i[s]++ } return r } var IT = (e, t) => { let n = er.createTransformer(t), r = ss(e), i = ss(t); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? Zu.has(e) && !i.values.length || Zu.has(t) && !r.values.length ? RT(e, t) : In(Lg(FT(r, i), i.values), n) : (Xi(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Xa(e, t)) }; function Df(e, t, n) { return typeof e == "number" && typeof t == "number" && typeof n == "number" ? xe(e, t, n) : Of(e)(e, t) } function LT(e, t, n) { let r = [], i = n || Df, o = e.length - 1; for (let s = 0; s < o; s++) { let a = i(e[s], e[s + 1]); if (t) { let l = Array.isArray(t) ? t[s] || nt : t; a = In(l, a) } r.push(a) } return r } function Ki(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) { let o = e.length; if (zt(o === t.length, "Both input and output ranges must be the same length"), o === 1) return () => t[0]; if (o === 2 && e[0] === e[1]) return () => t[1]; e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse()); let s = LT(t, r, i), a = s.length, l = c => { let u = 0; if (a > 1) for (; u < e.length - 2 && !(c < e[u + 1]); u++); let f = xr(e[u], e[u + 1], c); return s[u](f) }; return n ? c => l(Jn(e[0], e[o - 1], c)) : l } var MT = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), Jm = e => e === Yi || e === G, ev = (e, t) => parseFloat(e.split(", ")[t]), tv = (e, t) => (n, { transform: r }) => { if (r === "none" || !r) return 0; let i = r.match(/^matrix3d\((.+)\)$/u); if (i) return ev(i[1], t); { let o = r.match(/^matrix\((.+)\)$/u); return o ? ev(o[1], e) : 0 } }, OT = new Set(["x", "y", "z"]), DT = ls.filter(e => !OT.has(e)); function AT(e) { let t = []; return DT.forEach(n => { let r = e.getValue(n); r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), t } var ji = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: tv(4, 13), y: tv(5, 14) }; ji.translateX = ji.x; ji.translateY = ji.y; var si = new Set, Ju = !1, ef = !1; function Mg() { if (ef) { let e = Array.from(si).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), n = new Map; t.forEach(r => { let i = AT(r); i.length && (n.set(r, i), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render(); let i = n.get(r); i && i.forEach(([o, s]) => { var a; (a = r.getValue(o)) === null || a === void 0 || a.set(s) }) }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } ef = !1, Ju = !1, si.forEach(e => e.complete()), si.clear() } function Og() { si.forEach(e => { e.readKeyframes(), e.needsMeasurement && (ef = !0) }) } function VT() { Og(), Mg() } var Af = class { constructor(e, t, n, r, i, o = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = t, this.name = n, this.motionValue = r, this.element = i, this.isAsync = o } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (si.add(this), Ju || (Ju = !0, Y.read(Og), Y.resolveKeyframes(Mg))) : (this.readKeyframes(), this.complete()) } readKeyframes() { let { unresolvedKeyframes: e, name: t, element: n, motionValue: r } = this; for (let i = 0; i < e.length; i++)if (e[i] === null) if (i === 0) { let o = r?.get(), s = e[e.length - 1]; if (o !== void 0) e[0] = o; else if (n && t) { let a = n.readValue(t, s); a != null && (e[0] = a) } e[0] === void 0 && (e[0] = s), r && o === void 0 && r.set(e[0]) } else e[i] = e[i - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), si.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, si.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } }; function nv({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: l, restDelta: c = .5, restSpeed: u }) { let f = e[0], d = { done: !1, value: f }, p = E => a !== void 0 && E < a || l !== void 0 && E > l, g = E => a === void 0 ? l : l === void 0 || Math.abs(a - E) < Math.abs(l - E) ? a : l, v = n * t, S = f + v, m = s === void 0 ? S : s(S); m !== S && (v = m - f); let h = E => -v * Math.exp(-E / r), y = E => m + h(E), x = E => { let I = h(E), F = y(E); d.done = Math.abs(I) <= c, d.value = d.done ? m : F }, k, w, T = E => { p(d.value) && (k = E, w = fs({ keyframes: [d.value, g(d.value)], velocity: kg(y, E, d.value), damping: i, stiffness: o, restDelta: c, restSpeed: u })) }; return T(0), { calculatedDuration: null, next: E => { let I = !1; return !w && k === void 0 && (I = !0, x(E), T(E)), k !== void 0 && E >= k ? w.next(E - k) : (!I && x(E), d) } } } var Dg = e => Array.isArray(e) && typeof e[0] != "number", rv = { linear: nt, easeIn: Tg, easeInOut: Pf, easeOut: Eg, circIn: al, circInOut: Rg, circOut: If, backIn: ll, backInOut: Pg, backOut: Lf, anticipate: _g }, iv = e => { if (Array.isArray(e)) { zt(e.length === 4, "Cubic bezier arrays must contain four numerical values."); let [t, n, r, i] = e; return Gi(t, n, r, i) } else if (typeof e == "string") return zt(rv[e] !== void 0, `Invalid easing type '${e}'`), rv[e]; return e }; function Ag(e, t) { let n = e[e.length - 1]; for (let r = 1; r <= t; r++) { let i = xr(0, t, r); e.push(xe(n, 1, i)) } } function Vf(e) { let t = [0]; return Ag(t, e.length - 1), t } function BT(e, t) { return e.map(n => n * t) } function $T(e, t) { return e.map(() => t || Pf).splice(0, e.length - 1) } function Ya({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) { let i = Dg(r) ? r.map(iv) : iv(r), o = { done: !1, value: t[0] }, s = BT(n && n.length === t.length ? n : Vf(t), e), a = Ki(s, t, { ease: Array.isArray(i) ? i : $T(t, i) }); return { calculatedDuration: e, next: l => (o.value = a(l), o.done = l >= e, o) } } var Ga = { current: !1 }, ov = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (er.test(e) || e === "0") && !e.startsWith("url(")); function zT(e) { let t = e[0]; if (e.length === 1) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 } function NT(e, t, n, r) { let i = e[0]; if (i === null) return !1; if (t === "display" || t === "visibility") return !0; let o = e[e.length - 1], s = ov(i, t), a = ov(o, t); return Xi(s === a, `You are trying to animate ${t} from "${i}" to "${o}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${o} via the \`style\` property.`), !s || !a ? !1 : zT(e) || n === "spring" && r } var HT = e => e !== null; function cl(e, { repeat: t, repeatType: n = "loop" }, r) { let i = e.filter(HT), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1; return !o || r === void 0 ? i[o] : r } var Vg = class { constructor({ autoplay: e = !0, delay: t = 0, type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: o = "loop", ...s }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.options = { autoplay: e, delay: t, type: n, repeat: r, repeatDelay: i, repeatType: o, ...s }, this.updateFinishedPromise() } get resolved() { return !this._resolved && !this.hasAttemptedResolve && VT(), this._resolved } onKeyframesResolved(e, t) { this.hasAttemptedResolve = !0; let { name: n, type: r, velocity: i, delay: o, onComplete: s, onUpdate: a, isGenerator: l } = this.options; if (!l && !NT(e, n, r, i)) if (Ga.current || !o) { a?.(cl(e, this.options, t)), s?.(), this.resolveFinishedPromise(); return } else this.options.duration = 0; let c = this.initPlayback(e, t); c !== !1 && (this._resolved = { keyframes: e, finalKeyframe: t, ...c }, this.onPostResolved()) } onPostResolved() { } then(e, t) { return this.currentFinishedPromise.then(e, t) } updateFinishedPromise() { this.currentFinishedPromise = new Promise(e => { this.resolveFinishedPromise = e }) } }, tf = 2e4; function Bg(e) { let t = 0, n = 50, r = e.next(t); for (; !r.done && t < tf;)t += n, r = e.next(t); return t >= tf ? 1 / 0 : t } var Na; function jT() { Na = void 0 } var br = { now: () => (Na === void 0 && br.set(Oe.isProcessing || tl.useManualTiming ? Oe.timestamp : performance.now()), Na), set: e => { Na = e, queueMicrotask(jT) } }, WT = e => { let t = ({ timestamp: n }) => e(n); return { start: () => Y.update(t, !0), stop: () => dt(t), now: () => Oe.isProcessing ? Oe.timestamp : br.now() } }, UT = { decay: nv, inertia: nv, tween: Ya, keyframes: Ya, spring: fs }, XT = e => e / 100, ul = class extends Vg { constructor({ KeyframeResolver: e = Af, ...t }) { super(t), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); let { onStop: s } = this.options; s && s() }; let { name: n, motionValue: r, keyframes: i } = this.options, o = (s, a) => this.onKeyframesResolved(s, a); n && r && r.owner ? this.resolver = r.owner.resolveKeyframes(i, o, n, r) : this.resolver = new e(i, o, n, r), this.resolver.scheduleResolve() } initPlayback(e) { let { type: t = "keyframes", repeat: n = 0, repeatDelay: r = 0, repeatType: i, velocity: o = 0 } = this.options, s = UT[t] || Ya, a, l; s !== Ya && typeof e[0] != "number" && (a = In(XT, Df(e[0], e[1])), e = [0, 100]); let c = s({ ...this.options, keyframes: e }); i === "mirror" && (l = s({ ...this.options, keyframes: [...e].reverse(), velocity: -o })), c.calculatedDuration === null && (c.calculatedDuration = Bg(c)); let { calculatedDuration: u } = c, f = u + r, d = f * (n + 1) - r; return { generator: c, mirroredGenerator: l, mapPercentToKeyframes: a, calculatedDuration: u, resolvedDuration: f, totalDuration: d } } onPostResolved() { let { autoplay: e = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState } tick(e, t = !1) { let { resolved: n } = this; if (!n) { let { keyframes: T } = this.options; return { done: !0, value: T[T.length - 1] } } let { finalKeyframe: r, generator: i, mirroredGenerator: o, mapPercentToKeyframes: s, keyframes: a, calculatedDuration: l, totalDuration: c, resolvedDuration: u } = n; if (this.startTime === null) return i.next(0); let { delay: f, repeat: d, repeatType: p, repeatDelay: g, onUpdate: v } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - c / this.speed, this.startTime)), t ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed; let S = this.currentTime - f * (this.speed >= 0 ? 1 : -1), m = this.speed >= 0 ? S < 0 : S > c; this.currentTime = Math.max(S, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = c); let h = this.currentTime, y = i; if (d) { let T = Math.min(this.currentTime, c) / u, E = Math.floor(T), I = T % 1; !I && T >= 1 && (I = 1), I === 1 && E--, E = Math.min(E, d + 1), !!(E % 2) && (p === "reverse" ? (I = 1 - I, g && (I -= g / u)) : p === "mirror" && (y = o)), h = Jn(0, 1, I) * u } let x = m ? { done: !1, value: a[0] } : y.next(h); s && (x.value = s(x.value)); let { done: k } = x; !m && l !== null && (k = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0); let w = this.holdTime === null && (this.state === "finished" || this.state === "running" && k); return w && r !== void 0 && (x.value = cl(a, this.options, r)), v && v(x.value), w && this.finish(), x } get duration() { let { resolved: e } = this; return e ? Mn(e.calculatedDuration) : 0 } get time() { return Mn(this.currentTime) } set time(e) { e = Ln(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed) } get speed() { return this.playbackSpeed } set speed(e) { let t = this.playbackSpeed !== e; this.playbackSpeed = e, t && (this.time = Mn(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; let { driver: e = WT, onPlay: t } = this.options; this.driver || (this.driver = e(r => this.tick(r))), t && t(); let n = this.driver.now(); this.holdTime !== null ? this.startTime = n - this.holdTime : (!this.startTime || this.state === "finished") && (this.startTime = n), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var e; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; let { onComplete: e } = this.options; e && e() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } }; function Bf(e) { return new ul(e) } var $g = e => /^0[^.\s]+$/u.test(e); function YT(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || $g(e) : !0 } var zg = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), GT = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function KT(e) { let t = GT.exec(e); if (!t) return [,]; let [, n, r, i] = t; return [`--${n ?? r}`, i] } var qT = 4; function Ng(e, t, n = 1) { zt(n <= qT, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`); let [r, i] = KT(e); if (!r) return; let o = window.getComputedStyle(t).getPropertyValue(r); if (o) { let s = o.trim(); return zg(s) ? parseFloat(s) : s } return Mf(i) ? Ng(i, t, n + 1) : i } var Hg = e => t => t.test(e), QT = { test: e => e === "auto", parse: e => e }, jg = [Yi, G, _n, vr, GC, YC, QT], sv = e => jg.find(Hg(e)), ZT = new Set(["brightness", "contrast", "saturate", "opacity"]); function JT(e) { let [t, n] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; let [r] = n.match(kf) || []; if (!r) return e; let i = n.replace(r, ""), o = ZT.has(t) ? 1 : 0; return r !== n && (o *= 100), t + "(" + o + i + ")" } var eE = /\b([a-z-]*)\(.*?\)/gu, nf = { ...er, getAnimatableNone: e => { let t = e.match(eE); return t ? t.map(JT).join(" ") : e } }, av = { ...Yi, transform: Math.round }, Wg = { borderWidth: G, borderTopWidth: G, borderRightWidth: G, borderBottomWidth: G, borderLeftWidth: G, borderRadius: G, radius: G, borderTopLeftRadius: G, borderTopRightRadius: G, borderBottomRightRadius: G, borderBottomLeftRadius: G, width: G, maxWidth: G, height: G, maxHeight: G, size: G, top: G, right: G, bottom: G, left: G, padding: G, paddingTop: G, paddingRight: G, paddingBottom: G, paddingLeft: G, margin: G, marginTop: G, marginRight: G, marginBottom: G, marginLeft: G, rotate: vr, rotateX: vr, rotateY: vr, rotateZ: vr, scale: Ba, scaleX: Ba, scaleY: Ba, scaleZ: Ba, skew: vr, skewX: vr, skewY: vr, distance: G, translateX: G, translateY: G, translateZ: G, x: G, y: G, z: G, perspective: G, transformPerspective: G, opacity: Zo, originX: Wm, originY: Wm, originZ: G, zIndex: av, backgroundPositionX: G, backgroundPositionY: G, fillOpacity: Zo, strokeOpacity: Zo, numOctaves: av }, tE = { ...Wg, color: tt, backgroundColor: tt, outlineColor: tt, fill: tt, stroke: tt, borderColor: tt, borderTopColor: tt, borderRightColor: tt, borderBottomColor: tt, borderLeftColor: tt, filter: nf, WebkitFilter: nf }, $f = e => tE[e]; function Ug(e, t) { let n = $f(e); return n !== nf && (n = er), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } var nE = new Set(["auto", "none", "0"]); function rE(e, t, n) { let r = 0, i; for (; r < e.length && !i;) { let o = e[r]; typeof o == "string" && !nE.has(o) && ss(o).values.length && (i = e[r]), r++ } if (i && n) for (let o of t) e[o] = Ug(n, i) } var Xg = class extends Af { constructor(e, t, n, r) { super(e, t, n, r, r?.owner, !0) } readKeyframes() { let { unresolvedKeyframes: e, element: t, name: n } = this; if (!t.current) return; super.readKeyframes(); for (let a = 0; a < e.length; a++) { let l = e[a]; if (typeof l == "string" && (l = l.trim(), Mf(l))) { let c = Ng(l, t.current); c !== void 0 && (e[a] = c), a === e.length - 1 && (this.finalKeyframe = l) } } if (this.resolveNoneKeyframes(), !MT.has(n) || e.length !== 2) return; let [r, i] = e, o = sv(r), s = sv(i); if (o !== s) if (Jm(o) && Jm(s)) for (let a = 0; a < e.length; a++) { let l = e[a]; typeof l == "string" && (e[a] = parseFloat(l)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { let { unresolvedKeyframes: e, name: t } = this, n = []; for (let r = 0; r < e.length; r++)YT(e[r]) && n.push(r); n.length && rE(e, n, t) } measureInitialState() { let { element: e, unresolvedKeyframes: t, name: n } = this; if (!e.current) return; n === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ji[n](e.measureViewportBox(), window.getComputedStyle(e.current)), t[0] = this.measuredOrigin; let r = t[t.length - 1]; r !== void 0 && e.getValue(n, r).jump(r, !1) } measureEndState() { var e; let { element: t, name: n, unresolvedKeyframes: r } = this; if (!t.current) return; let i = t.getValue(n); i && i.jump(this.measuredOrigin, !1); let o = r.length - 1, s = r[o]; r[o] = ji[n](t.measureViewportBox(), window.getComputedStyle(t.current)), s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([a, l]) => { t.getValue(a).set(l) }), this.resolveNoneKeyframes() } }; function Yg(e) { let t; return () => (t === void 0 && (t = e()), t) } var Gg = e => Array.isArray(e) && typeof e[0] == "number"; function Kg(e) { return !!(!e || typeof e == "string" && e in zf || Gg(e) || Array.isArray(e) && e.every(Kg)) } var qo = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, zf = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: qo([0, .65, .55, 1]), circOut: qo([.55, 0, 1, .45]), backIn: qo([.31, .01, .66, -.59]), backOut: qo([.33, 1.53, .69, .99]) }; function iE(e) { return qg(e) || zf.easeOut } function qg(e) { if (e) return Gg(e) ? qo(e) : Array.isArray(e) ? e.map(iE) : zf[e] } function oE(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a, times: l } = {}) { let c = { [t]: n }; l && (c.offset = l); let u = qg(a); return Array.isArray(u) && (c.easing = u), e.animate(c, { delay: r, duration: i, easing: Array.isArray(u) ? "linear" : u, fill: "both", iterations: o + 1, direction: s === "reverse" ? "alternate" : "normal" }) } var sE = Yg(() => Object.hasOwnProperty.call(Element.prototype, "animate")), aE = new Set(["opacity", "clipPath", "filter", "transform"]), Ka = 10, lE = 2e4; function cE(e) { return e.type === "spring" || e.name === "backgroundColor" || !Kg(e.ease) } function uE(e, t) { let n = new ul({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }), r = { done: !1, value: e[0] }, i = [], o = 0; for (; !r.done && o < lE;)r = n.sample(o), i.push(r.value), o += Ka; return { times: void 0, keyframes: i, duration: o - Ka, ease: "linear" } } var rf = class extends Vg { constructor(e) { super(e); let { name: t, motionValue: n, keyframes: r } = this.options; this.resolver = new Xg(r, (i, o) => this.onKeyframesResolved(i, o), t, n), this.resolver.scheduleResolve() } initPlayback(e, t) { var n; let { duration: r = 300, times: i, ease: o, type: s, motionValue: a, name: l } = this.options; if (!(!((n = a.owner) === null || n === void 0) && n.current)) return !1; if (cE(this.options)) { let { onComplete: u, onUpdate: f, motionValue: d, ...p } = this.options, g = uE(e, p); e = g.keyframes, e.length === 1 && (e[1] = e[0]), r = g.duration, i = g.times, o = g.ease, s = "keyframes" } let c = oE(a.owner.current, l, e, { ...this.options, duration: r, times: i, ease: o }); return c.startTime = br.now(), this.pendingTimeline ? (c.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : c.onfinish = () => { let { onComplete: u } = this.options; a.set(cl(e, this.options, t)), u && u(), this.cancel(), this.resolveFinishedPromise() }, { animation: c, duration: r, times: i, type: s, ease: o, keyframes: e } } get duration() { let { resolved: e } = this; if (!e) return 0; let { duration: t } = e; return Mn(t) } get time() { let { resolved: e } = this; if (!e) return 0; let { animation: t } = e; return Mn(t.currentTime || 0) } set time(e) { let { resolved: t } = this; if (!t) return; let { animation: n } = t; n.currentTime = Ln(e) } get speed() { let { resolved: e } = this; if (!e) return 1; let { animation: t } = e; return t.playbackRate } set speed(e) { let { resolved: t } = this; if (!t) return; let { animation: n } = t; n.playbackRate = e } get state() { let { resolved: e } = this; if (!e) return "idle"; let { animation: t } = e; return t.playState } attachTimeline(e) { if (!this._resolved) this.pendingTimeline = e; else { let { resolved: t } = this; if (!t) return nt; let { animation: n } = t; n.timeline = e, n.onfinish = null } return nt } play() { if (this.isStopped) return; let { resolved: e } = this; if (!e) return; let { animation: t } = e; t.playState === "finished" && this.updateFinishedPromise(), t.play() } pause() { let { resolved: e } = this; if (!e) return; let { animation: t } = e; t.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; let { resolved: e } = this; if (!e) return; let { animation: t, keyframes: n, duration: r, type: i, ease: o, times: s } = e; if (!(t.playState === "idle" || t.playState === "finished")) { if (this.time) { let { motionValue: a, onUpdate: l, onComplete: c, ...u } = this.options, f = new ul({ ...u, keyframes: n, duration: r, type: i, ease: o, times: s, isGenerator: !0 }), d = Ln(this.time); a.setWithVelocity(f.sample(d - Ka).value, f.sample(d).value, Ka) } this.cancel() } } complete() { let { resolved: e } = this; e && e.animation.finish() } cancel() { let { resolved: e } = this; e && e.animation.cancel() } static supports(e) { let { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: s } = e; return sE() && n && aE.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !r && i !== "mirror" && o !== 0 && s !== "inertia" } }; function Nf(e, t) { e.indexOf(t) === -1 && e.push(t) } function fl(e, t) { let n = e.indexOf(t); n > -1 && e.splice(n, 1) } function fE([...e], t, n) { let r = t < 0 ? e.length + t : t; if (r >= 0 && r < e.length) { let i = n < 0 ? e.length + n : n, [o] = e.splice(t, 1); e.splice(i, 0, o) } return e } var Hf = class { constructor() { this.subscriptions = [] } add(e) { return Nf(this.subscriptions, e), () => fl(this.subscriptions, e) } notify(e, t, n) { let r = this.subscriptions.length; if (r) if (r === 1) this.subscriptions[0](e, t, n); else for (let i = 0; i < r; i++) { let o = this.subscriptions[i]; o && o(e, t, n) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } }, lv = 30, dE = e => !isNaN(parseFloat(e)), Jo = { current: void 0 }, dl = class { constructor(e, t = {}) { this.version = "11.2.10", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (n, r = !0) => { let i = br.now(); this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(n), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), r && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(e), this.owner = t.owner } setCurrent(e) { this.current = e, this.updatedAt = br.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = dE(this.current)) } setPrevFrameValue(e = this.current) { this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, t) { this.events[e] || (this.events[e] = new Hf); let n = this.events[e].add(t); return e === "change" ? () => { n(), Y.read(() => { this.events.change.getSize() || this.stop() }) } : n } clearListeners() { for (let e in this.events) this.events[e].clear() } attach(e, t) { this.passiveEffect = e, this.stopPassiveEffect = t } set(e, t = !0) { !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify) } setWithVelocity(e, t, n) { this.set(t), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n } jump(e, t = !0) { this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, t && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return Jo.current && Jo.current.push(this), this.current } getPrevious() { return this.prev } getVelocity() { let e = br.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > lv) return 0; let t = Math.min(this.updatedAt - this.prevUpdatedAt, lv); return Rf(parseFloat(this.current) - parseFloat(this.prevFrameValue), t) } start(e) { return this.stop(), new Promise(t => { this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } }; function Ee(e, t) { return new dl(e, t) } function hl(e, t, n) { let r = e.getProps(); return Cf(r, t, n !== void 0 ? n : r.custom, e) } var hE = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, pE = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), mE = { type: "keyframes", duration: .8 }, vE = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, gE = (e, { keyframes: t }) => t.length > 2 ? mE : ci.has(e) ? e.startsWith("scale") ? pE(t[1]) : hE : vE; function yE({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: l, elapsed: c, ...u }) { return !!Object.keys(u).length } function jf(e, t) { return e[t] || e.default || e } function bE(e, t) { let n, r = () => { let { currentTime: i } = t, s = (i === null ? 0 : i.value) / 100; n !== s && e(s), n = s }; return Y.update(r, !0), () => dt(r) } var xE = Yg(() => window.ScrollTimeline !== void 0), Wf = class { constructor(e) { this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean) } then(e, t) { return Promise.all(this.animations).then(e).catch(t) } getAll(e) { return this.animations[0][e] } setAll(e, t) { for (let n = 0; n < this.animations.length; n++)this.animations[n][e] = t } attachTimeline(e) { let t = this.animations.map(n => { if (xE() && n.attachTimeline) n.attachTimeline(e); else return n.pause(), bE(r => { n.time = n.duration * r }, e) }); return () => { t.forEach((n, r) => { n && n(), this.animations[r].stop() }) } } get time() { return this.getAll("time") } set time(e) { this.setAll("time", e) } get speed() { return this.getAll("speed") } set speed(e) { this.setAll("speed", e) } get duration() { let e = 0; for (let t = 0; t < this.animations.length; t++)e = Math.max(e, this.animations[t].duration); return e } runAll(e) { this.animations.forEach(t => t[e]()) } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } }, Uf = (e, t, n, r = {}, i, o) => s => { let a = jf(r, e) || {}, l = a.delay || r.delay || 0, { elapsed: c = 0 } = r; c = c - Ln(l); let u = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...a, delay: -c, onUpdate: d => { t.set(d), a.onUpdate && a.onUpdate(d) }, onComplete: () => { s(), a.onComplete && a.onComplete() }, name: e, motionValue: t, element: o ? void 0 : i }; yE(a) || (u = { ...u, ...gE(e, u) }), u.duration && (u.duration = Ln(u.duration)), u.repeatDelay && (u.repeatDelay = Ln(u.repeatDelay)), u.from !== void 0 && (u.keyframes[0] = u.from); let f = !1; if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0, u.delay === 0 && (f = !0)), (Ga.current || tl.skipAnimations) && (f = !0, u.duration = 0, u.delay = 0), f && !o && t.get() !== void 0) { let d = cl(u.keyframes, a); if (d !== void 0) return Y.update(() => { u.onUpdate(d), u.onComplete() }), new Wf([]) } return !o && rf.supports(u) ? new rf(u) : new ul(u) }; function qa(e) { return !!(Te(e) && e.add) } function SE(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Ee(n)) } function Xf(e, t) { let n = hl(e, t), { transitionEnd: r = {}, transition: i = {}, ...o } = n || {}; o = { ...o, ...r }; for (let s in o) { let a = QC(o[s]); SE(e, s, a) } } function Qg(e) { return e.getProps()[el] } function wE({ protectedKeys: e, needsAnimating: t }, n) { let r = e.hasOwnProperty(n) && t[n] !== !0; return t[n] = !1, r } function Yf(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) { var o; let { transition: s = e.getDefaultTransition(), transitionEnd: a, ...l } = t, c = e.getValue("willChange"); r && (s = r); let u = [], f = i && e.animationState && e.animationState.getState()[i]; for (let d in l) { let p = e.getValue(d, (o = e.latestValues[d]) !== null && o !== void 0 ? o : null), g = l[d]; if (g === void 0 || f && wE(f, d)) continue; let v = { delay: n, elapsed: 0, ...jf(s || {}, d) }, S = !1; if (window.HandoffAppearAnimations) { let h = Qg(e); if (h) { let y = window.HandoffAppearAnimations(h, d, p, Y); y !== null && (v.elapsed = y, S = !0) } } p.start(Uf(d, p, g, e.shouldReduceMotion && ci.has(d) ? { type: !1 } : v, e, S)); let m = p.animation; m && (qa(c) && (c.add(d), m.then(() => c.remove(d))), u.push(m)) } return a && Promise.all(u).then(() => { Y.update(() => { a && Xf(e, a) }) }), u } function of(e, t, n = {}) { var r; let i = hl(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0), { transition: o = e.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (o = n.transitionOverride); let s = i ? () => Promise.all(Yf(e, i, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (c = 0) => { let { delayChildren: u = 0, staggerChildren: f, staggerDirection: d } = o; return kE(e, t, u + c, f, d, n) } : () => Promise.resolve(), { when: l } = o; if (l) { let [c, u] = l === "beforeChildren" ? [s, a] : [a, s]; return c().then(() => u()) } else return Promise.all([s(), a(n.delay)]) } function kE(e, t, n = 0, r = 0, i = 1, o) { let s = [], a = (e.variantChildren.size - 1) * r, l = i === 1 ? (c = 0) => c * r : (c = 0) => a - c * r; return Array.from(e.variantChildren).sort(CE).forEach((c, u) => { c.notify("AnimationStart", t), s.push(of(c, t, { ...o, delay: n + l(u) }).then(() => c.notify("AnimationComplete", t))) }), Promise.all(s) } function CE(e, t) { return e.sortNodePosition(t) } function Gf(e, t, n = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { let i = t.map(o => of(e, o, n)); r = Promise.all(i) } else if (typeof t == "string") r = of(e, t, n); else { let i = typeof t == "function" ? hl(e, t, n.custom) : t; r = Promise.all(Yf(e, i, n)) } return r.then(() => { Y.postRender(() => { e.notify("AnimationComplete", t) }) }) } function Zg(e, t) { if (!Array.isArray(t)) return !1; let n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } var TE = [...bf].reverse(), EE = bf.length; function RE(e) { return t => Promise.all(t.map(({ animation: n, options: r }) => Gf(e, n, r))) } function PE(e) { let t = RE(e), n = FE(), r = !0, i = l => (c, u) => { var f; let d = hl(e, u, l === "exit" ? (f = e.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0); if (d) { let { transition: p, transitionEnd: g, ...v } = d; c = { ...c, ...v, ...g } } return c }; function o(l) { t = l(e) } function s(l) { let c = e.getProps(), u = e.getVariantContext(!0) || {}, f = [], d = new Set, p = {}, g = 1 / 0; for (let S = 0; S < EE; S++) { let m = TE[S], h = n[m], y = c[m] !== void 0 ? c[m] : u[m], x = is(y), k = m === l ? h.isActive : null; k === !1 && (g = S); let w = y === u[m] && y !== c[m] && x; if (w && r && e.manuallyAnimateOnMount && (w = !1), h.protectedKeys = { ...p }, !h.isActive && k === null || !y && !h.prevProp || rl(y) || typeof y == "boolean") continue; let E = _E(h.prevProp, y) || m === l && h.isActive && !w && x || S > g && x, I = !1, F = Array.isArray(y) ? y : [y], B = F.reduce(i(m), {}); k === !1 && (B = {}); let { prevResolvedValues: V = {} } = h, K = { ...V, ...B }, Z = j => { E = !0, d.has(j) && (I = !0, d.delete(j)), h.needsAnimating[j] = !0; let ne = e.getValue(j); ne && (ne.liveStyle = !1) }; for (let j in K) { let ne = B[j], U = V[j]; if (p.hasOwnProperty(j)) continue; let X = !1; Ku(ne) && Ku(U) ? X = !Zg(ne, U) : X = ne !== U, X ? ne != null ? Z(j) : d.add(j) : ne !== void 0 && d.has(j) ? Z(j) : h.protectedKeys[j] = !0 } h.prevProp = y, h.prevResolvedValues = B, h.isActive && (p = { ...p, ...B }), r && e.blockInitialAnimation && (E = !1), E && (!w || I) && f.push(...F.map(j => ({ animation: j, options: { type: m } }))) } if (d.size) { let S = {}; d.forEach(m => { let h = e.getBaseTarget(m), y = e.getValue(m); y && (y.liveStyle = !0), S[m] = h ?? null }), f.push({ animation: S }) } let v = !!f.length; return r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (v = !1), r = !1, v ? t(f) : Promise.resolve() } function a(l, c) { var u; if (n[l].isActive === c) return Promise.resolve(); (u = e.variantChildren) === null || u === void 0 || u.forEach(d => { var p; return (p = d.animationState) === null || p === void 0 ? void 0 : p.setActive(l, c) }), n[l].isActive = c; let f = s(l); for (let d in n) n[d].protectedKeys = {}; return f } return { animateChanges: s, setActive: a, setAnimateFunction: o, getState: () => n } } function _E(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !Zg(t, e) : !1 } function ti(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function FE() { return { animate: ti(!0), whileInView: ti(), whileHover: ti(), whileTap: ti(), whileDrag: ti(), whileFocus: ti(), exit: ti() } } var wr = class { constructor(e) { this.isMounted = !1, this.node = e } update() { } }, IE = class extends wr { constructor(e) { super(e), e.animationState || (e.animationState = PE(e)) } updateAnimationControlsSubscription() { let { animate: e } = this.node.getProps(); this.unmount(), rl(e) && (this.unmount = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { let { animate: e } = this.node.getProps(), { animate: t } = this.node.prevProps || {}; e !== t && this.updateAnimationControlsSubscription() } unmount() { } }, LE = 0, ME = class extends wr { constructor() { super(...arguments), this.id = LE++ } update() { if (!this.node.presenceContext) return; let { isPresent: e, onExitComplete: t } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === n) return; let r = this.node.animationState.setActive("exit", !e); t && !e && r.then(() => t(this.id)) } mount() { let { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } }, Kf = { animation: { Feature: IE }, exit: { Feature: ME } }, sf = (e, t) => Math.abs(e - t); function Jg(e, t) { let n = sf(e.x, t.x), r = sf(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) } function Ft(e) { return e.max - e.min } function af(e, t = 0, n = .01) { return Math.abs(e - t) <= n } function cv(e, t, n, r = .5) { e.origin = r, e.originPoint = xe(t.min, t.max, e.origin), e.scale = Ft(n) / Ft(t), (af(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1), e.translate = xe(n.min, n.max, e.origin) - e.originPoint, (af(e.translate) || isNaN(e.translate)) && (e.translate = 0) } function es(e, t, n, r) { cv(e.x, t.x, n.x, r ? r.originX : void 0), cv(e.y, t.y, n.y, r ? r.originY : void 0) } function uv(e, t, n) { e.min = n.min + t.min, e.max = e.min + Ft(t) } function OE(e, t, n) { uv(e.x, t.x, n.x), uv(e.y, t.y, n.y) } function fv(e, t, n) { e.min = t.min - n.min, e.max = e.min + Ft(t) } function ts(e, t, n) { fv(e.x, t.x, n.x), fv(e.y, t.y, n.y) } var dv = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), zi = () => ({ x: dv(), y: dv() }), hv = () => ({ min: 0, max: 0 }), Me = () => ({ x: hv(), y: hv() }); function pl() { let e = O(Ui); if (e === null) return [!0, null]; let { isPresent: t, onExitComplete: n, register: r } = e, i = ei(); return H(() => r(i), []), !t && n ? [!1, () => n && n(i)] : [!0] } var DE = (e, t) => e.depth - t.depth, ey = class { constructor() { this.children = [], this.isDirty = !1 } add(e) { Nf(this.children, e), this.isDirty = !0 } remove(e) { fl(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(DE), this.isDirty = !1, this.children.forEach(e) } }; function ty(e, t) { let n = br.now(), r = ({ timestamp: i }) => { let o = i - n; o >= t && (dt(r), e(o - t)) }; return Y.read(r, !0), () => dt(r) } var tr = new WeakMap, Qa = { current: null }, qf = { current: !1 }; function ny() { if (qf.current = !0, !!Ja) if (window.matchMedia) { let e = window.matchMedia("(prefers-reduced-motion)"), t = () => Qa.current = e.matches; e.addListener(t), t() } else Qa.current = !1 } function AE(e, t, n) { let { willChange: r } = t; for (let i in t) { let o = t[i], s = n[i]; if (Te(o)) e.addValue(i, o), qa(r) && r.add(i); else if (Te(s)) e.addValue(i, Ee(o, { owner: e })), qa(r) && r.remove(i); else if (s !== o) if (e.hasValue(i)) { let a = e.getValue(i); a.liveStyle === !0 ? a.jump(o) : a.hasAnimated || a.set(o) } else { let a = e.getStaticValue(i); e.addValue(i, Ee(a !== void 0 ? a : o, { owner: e })) } } for (let i in n) t[i] === void 0 && e.removeValue(i); return t } var VE = [...jg, tt, er], BE = e => VE.find(Hg(e)), ry = Object.keys(os), $E = ry.length, pv = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], zE = xf.length; function iy(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : iy(e.parent) } var oy = class { scrapeMotionValuesFromProps(e, t, n) { return {} } constructor({ parent: e, props: t, presenceContext: n, reducedMotionConfig: r, blockInitialAnimation: i, visualState: o }, s = {}) { this.resolveKeyframes = (f, d, p, g) => new this.KeyframeResolver(f, d, p, g, this), this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Af, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.scheduleRender = () => Y.render(this.render, !1, !0); let { latestValues: a, renderState: l } = o; this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = t.initial ? { ...a } : {}, this.renderState = l, this.parent = e, this.props = t, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = r, this.options = s, this.blockInitialAnimation = !!i, this.isControllingVariants = il(t), this.isVariantNode = lg(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current); let { willChange: c, ...u } = this.scrapeMotionValuesFromProps(t, {}, this); for (let f in u) { let d = u[f]; a[f] !== void 0 && Te(d) && (d.set(a[f], !1), qa(c) && c.add(f)) } } mount(e) { this.current = e, tr.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, n) => this.bindToMotionValue(n, t)), qf.current || ny(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Qa.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { var e; tr.delete(this.current), this.projection && this.projection.unmount(), dt(this.notifyUpdate), dt(this.render), this.valueSubscriptions.forEach(t => t()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (let t in this.events) this.events[t].clear(); for (let t in this.features) (e = this.features[t]) === null || e === void 0 || e.unmount(); this.current = null } bindToMotionValue(e, t) { let n = ci.has(e), r = t.on("change", o => { this.latestValues[e] = o, this.props.onUpdate && Y.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0) }), i = t.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(e, () => { r(), i(), t.owner && t.stop() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } loadFeatures({ children: e, ...t }, n, r, i) { let o, s; for (let a = 0; a < $E; a++) { let l = ry[a], { isEnabled: c, Feature: u, ProjectionNode: f, MeasureLayout: d } = os[l]; f && (o = f), c(t) && (!this.features[l] && u && (this.features[l] = new u(this)), d && (s = d)) } if ((this.type === "html" || this.type === "svg") && !this.projection && o) { let { layoutId: a, layout: l, drag: c, dragConstraints: u, layoutScroll: f, layoutRoot: d } = t; this.projection = new o(this.latestValues, t["data-framer-portal-id"] ? void 0 : iy(this.parent)), this.projection.setOptions({ layoutId: a, layout: l, alwaysMeasureLayout: !!c || u && Bi(u), visualElement: this, scheduleRender: () => this.scheduleRender(), animationType: typeof l == "string" ? l : "both", initialPromotionConfig: i, layoutScroll: f, layoutRoot: d }) } return s } updateFeatures() { for (let e in this.features) { let t = this.features[e]; t.isMounted ? t.update() : (t.mount(), t.isMounted = !0) } } triggerBuild() { this.build(this.renderState, this.latestValues, this.options, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Me() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, t) { this.latestValues[e] = t } update(e, t) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t; for (let n = 0; n < pv.length; n++) { let r = pv[n]; this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]); let i = "on" + r, o = e[i]; o && (this.propEventSubscriptions[r] = this.on(r, o)) } this.prevMotionValues = AE(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(e = !1) { if (e) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { let n = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (n.initial = this.props.initial), n } let t = {}; for (let n = 0; n < zE; n++) { let r = xf[n], i = this.props[r]; (is(i) || i === !1) && (t[r] = i) } return t } addVariantChild(e) { let t = this.getClosestVariantNode(); if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e) } addValue(e, t) { let n = this.values.get(e); t !== n && (n && this.removeValue(e), this.bindToMotionValue(e, t), this.values.set(e, t), this.latestValues[e] = t.get()) } removeValue(e) { this.values.delete(e); let t = this.valueSubscriptions.get(e); t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, t) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let n = this.values.get(e); return n === void 0 && t !== void 0 && (n = Ee(t === null ? void 0 : t, { owner: this }), this.addValue(e, n)), n } readValue(e, t) { var n; let r = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options); return r != null && (typeof r == "string" && (zg(r) || $g(r)) ? r = parseFloat(r) : !BE(r) && er.test(t) && (r = Ug(e, t)), this.setBaseTarget(e, Te(r) ? r.get() : r)), Te(r) ? r.get() : r } setBaseTarget(e, t) { this.baseTarget[e] = t } getBaseTarget(e) { var t; let { initial: n } = this.props, r; if (typeof n == "string" || typeof n == "object") { let o = Cf(this.props, n, (t = this.presenceContext) === null || t === void 0 ? void 0 : t.custom); o && (r = o[e]) } if (n && r !== void 0) return r; let i = this.getBaseTargetFromProps(this.props, e); return i !== void 0 && !Te(i) ? i : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e] } on(e, t) { return this.events[e] || (this.events[e] = new Hf), this.events[e].add(t) } notify(e, ...t) { this.events[e] && this.events[e].notify(...t) } }; function sy(e) { function t(r, i = {}) { return cg(e(r, i)) } if (typeof Proxy > "u") return t; let n = new Map; return new Proxy(t, { get: (r, i) => (n.has(i) || n.set(i, t(i)), n.get(i)) }) } var NE = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Qf(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(NE.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function ay(e, { layout: t, layoutId: n }) { return ci.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Ua[e] || e === "opacity") } var HE = (e, t) => t && typeof e == "number" ? t.transform(e) : e; function Zf(e, t, n, r) { let { style: i, vars: o, transform: s, transformOrigin: a } = e, l = !1, c = !1, u = !0; for (let f in t) { let d = t[f]; if (Ig(f)) { o[f] = d; continue } let p = Wg[f], g = HE(d, p); if (ci.has(f)) { if (l = !0, s[f] = g, !u) continue; d !== (p.default || 0) && (u = !1) } else f.startsWith("origin") ? (c = !0, a[f] = g) : i[f] = g } if (t.transform || (l || r ? i.transform = ug(e.transform, n, u, r) : i.transform && (i.transform = "none")), c) { let { originX: f = "50%", originY: d = "50%", originZ: p = 0 } = a; i.transformOrigin = `${f} ${d} ${p}` } } var Jf = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function ly(e, t, n) { for (let r in t) !Te(t[r]) && !ay(r, n) && (e[r] = t[r]) } function jE({ transformTemplate: e }, t, n) { return he(() => { let r = Jf(); return Zf(r, t, { enableHardwareAcceleration: !n }, e), Object.assign({}, r.vars, r.style) }, [t]) } function WE(e, t, n) { let r = e.style || {}, i = {}; return ly(i, r, e), Object.assign(i, jE(e, t, n)), i } function UE(e, t, n) { let r = {}, i = WE(e, t, n); return e.drag && e.dragListener !== !1 && (r.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (r.tabIndex = 0), r.style = i, r } function mv(e, t, n) { return typeof e == "string" ? e : G.transform(t + n * e) } function XE(e, t, n) { let r = mv(t, e.x, e.width), i = mv(n, e.y, e.height); return `${r} ${i}` } var YE = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, GE = { offset: "strokeDashoffset", array: "strokeDasharray" }; function KE(e, t, n = 1, r = 0, i = !0) { e.pathLength = 1; let o = i ? YE : GE; e[o.offset] = G.transform(-r); let s = G.transform(t), a = G.transform(n); e[o.array] = `${s} ${a}` } function ed(e, { attrX: t, attrY: n, attrScale: r, originX: i, originY: o, pathLength: s, pathSpacing: a = 1, pathOffset: l = 0, ...c }, u, f, d) { if (Zf(e, c, u, d), f) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; let { attrs: p, style: g, dimensions: v } = e; p.transform && (v && (g.transform = p.transform), delete p.transform), v && (i !== void 0 || o !== void 0 || g.transform) && (g.transformOrigin = XE(v, i !== void 0 ? i : .5, o !== void 0 ? o : .5)), t !== void 0 && (p.x = t), n !== void 0 && (p.y = n), r !== void 0 && (p.scale = r), s !== void 0 && KE(p, s, a, l, !1) } var cy = () => ({ ...Jf(), attrs: {} }), td = e => typeof e == "string" && e.toLowerCase() === "svg"; function qE(e, t, n, r) { let i = he(() => { let o = cy(); return ed(o, t, { enableHardwareAcceleration: !1 }, td(r), e.transformTemplate), { ...o.attrs, style: { ...o.style } } }, [t]); if (e.style) { let o = {}; ly(o, e.style, e), i.style = { ...o, ...i.style } } return i } function QE(e = !1) { return (n, r, i, { latestValues: o }, s) => { let l = (Qf(n) ? qE : UE)(r, o, s, n), c = hg(r, typeof n == "string", e), u = n !== Uo ? { ...c, ...l, ref: i } : {}, { children: f } = r, d = he(() => Te(f) ? f.get() : f, [f]); return Du(n, { ...u, children: d }) } } function uy(e, { style: t, vars: n }, r, i) { Object.assign(e.style, t, i && i.getProjectionStyles(r)); for (let o in n) e.style.setProperty(o, n[o]) } var fy = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function dy(e, t, n, r) { uy(e, t, void 0, r); for (let i in t.attrs) e.setAttribute(fy.has(i) ? i : gf(i), t.attrs[i]) } function nd(e, t, n) { var r; let { style: i } = e, o = {}; for (let s in i) (Te(i[s]) || t.style && Te(t.style[s]) || ay(s, e) || ((r = n?.getValue(s)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[s] = i[s]); return o } function hy(e, t, n) { let r = nd(e, t, n); for (let i in e) if (Te(e[i]) || Te(t[i])) { let o = ls.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[o] = e[i] } return r } var ZE = { useVisualState: ol({ scrapeMotionValuesFromProps: hy, createRenderState: cy, onMount: (e, t, { renderState: n, latestValues: r }) => { Y.read(() => { try { n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect() } catch { n.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), Y.render(() => { ed(n, r, { enableHardwareAcceleration: !1 }, td(t.tagName), e.transformTemplate), dy(t, n) }) } }) }, JE = { useVisualState: ol({ scrapeMotionValuesFromProps: nd, createRenderState: Jf }) }; function py(e, { forwardMotionProps: t = !1 }, n, r) { return { ...Qf(e) ? ZE : JE, preloadedFeatures: n, useRender: QE(t), createVisualElement: r, Component: e } } function vv(e, t) { let n = t ? "pointerenter" : "pointerleave", r = t ? "onHoverStart" : "onHoverEnd", i = (o, s) => { if (o.pointerType === "touch" || Tf()) return; let a = e.getProps(); e.animationState && a.whileHover && e.animationState.setActive("whileHover", t); let l = a[r]; l && Y.postRender(() => l(o, s)) }; return Fn(e.current, n, i, { passive: !e.getProps()[r] }) } var eR = class extends wr { mount() { this.unmount = In(vv(this.node, !0), vv(this.node, !1)) } unmount() { } }, tR = class extends wr { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = In(Zn(this.node.current, "focus", () => this.onFocus()), Zn(this.node.current, "blur", () => this.onBlur())) } unmount() { } }, my = (e, t) => t ? e === t ? !0 : my(e, t.parentElement) : !1; function zu(e, t) { if (!t) return; let n = new PointerEvent("pointer" + e); t(n, sl(n)) } var nR = class extends wr { constructor() { super(...arguments), this.removeStartListeners = nt, this.removeEndListeners = nt, this.removeAccessibleListeners = nt, this.startPointerPress = (e, t) => { if (this.isPressing) return; this.removeEndListeners(); let n = this.node.getProps(), i = Fn(window, "pointerup", (s, a) => { if (!this.checkPressEnd()) return; let { onTap: l, onTapCancel: c, globalTapTarget: u } = this.node.getProps(), f = !u && !my(this.node.current, s.target) ? c : l; f && Y.update(() => f(s, a)) }, { passive: !(n.onTap || n.onPointerUp) }), o = Fn(window, "pointercancel", (s, a) => this.cancelPress(s, a), { passive: !(n.onTapCancel || n.onPointerCancel) }); this.removeEndListeners = In(i, o), this.startPress(e, t) }, this.startAccessiblePress = () => { let e = i => { if (i.key !== "Enter" || this.isPressing) return; let o = s => { s.key !== "Enter" || !this.checkPressEnd() || zu("up", (a, l) => { let { onTap: c } = this.node.getProps(); c && Y.postRender(() => c(a, l)) }) }; this.removeEndListeners(), this.removeEndListeners = Zn(this.node.current, "keyup", o), zu("down", (s, a) => { this.startPress(s, a) }) }, t = Zn(this.node.current, "keydown", e), n = () => { this.isPressing && zu("cancel", (i, o) => this.cancelPress(i, o)) }, r = Zn(this.node.current, "blur", n); this.removeAccessibleListeners = In(t, r) } } startPress(e, t) { this.isPressing = !0; let { onTapStart: n, whileTap: r } = this.node.getProps(); r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Y.postRender(() => n(e, t)) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !Tf() } cancelPress(e, t) { if (!this.checkPressEnd()) return; let { onTapCancel: n } = this.node.getProps(); n && Y.postRender(() => n(e, t)) } mount() { let e = this.node.getProps(), t = Fn(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), n = Zn(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = In(t, n) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } }, lf = new WeakMap, Nu = new WeakMap, rR = e => { let t = lf.get(e.target); t && t(e) }, iR = e => { e.forEach(rR) }; function oR({ root: e, ...t }) { let n = e || document; Nu.has(n) || Nu.set(n, {}); let r = Nu.get(n), i = JSON.stringify(t); return r[i] || (r[i] = new IntersectionObserver(iR, { root: e, ...t })), r[i] } function sR(e, t, n) { let r = oR(t); return lf.set(e, n), r.observe(e), () => { lf.delete(e), r.unobserve(e) } } var aR = { some: 0, all: 1 }, lR = class extends wr { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); let { viewport: e = {} } = this.node.getProps(), { root: t, margin: n, amount: r = "some", once: i } = e, o = { root: t ? t.current : void 0, rootMargin: n, threshold: typeof r == "number" ? r : aR[r] }, s = a => { let { isIntersecting: l } = a; if (this.isInView === l || (this.isInView = l, i && !l && this.hasEnteredView)) return; l && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", l); let { onViewportEnter: c, onViewportLeave: u } = this.node.getProps(), f = l ? c : u; f && f(a) }; return sR(this.node.current, o, s) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; let { props: e, prevProps: t } = this.node;["amount", "margin", "root"].some(cR(e, t)) && this.startObserver() } unmount() { } }; function cR({ viewport: e = {} }, { viewport: t = {} } = {}) { return n => e[n] !== t[n] } var vy = { inView: { Feature: lR }, tap: { Feature: nR }, focus: { Feature: tR }, hover: { Feature: eR } }, gy = class { constructor(e, t, { transformPagePoint: n, contextWindow: r, dragSnapToOrigin: i = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; let u = ju(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, d = Jg(u.offset, { x: 0, y: 0 }) >= 3; if (!f && !d) return; let { point: p } = u, { timestamp: g } = Oe; this.history.push({ ...p, timestamp: g }); let { onStart: v, onMove: S } = this.handlers; f || (v && v(this.lastMoveEvent, u), this.startEvent = this.lastMoveEvent), S && S(this.lastMoveEvent, u) }, this.handlePointerMove = (u, f) => { this.lastMoveEvent = u, this.lastMoveEventInfo = Hu(f, this.transformPagePoint), Y.update(this.updatePoint, !0) }, this.handlePointerUp = (u, f) => { this.end(); let { onEnd: d, onSessionEnd: p, resumeAnimation: g } = this.handlers; if (this.dragSnapToOrigin && g && g(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; let v = ju(u.type === "pointercancel" ? this.lastMoveEventInfo : Hu(f, this.transformPagePoint), this.history); this.startEvent && d && d(u, v), p && p(u, v) }, !pg(e)) return; this.dragSnapToOrigin = i, this.handlers = t, this.transformPagePoint = n, this.contextWindow = r || window; let o = sl(e), s = Hu(o, this.transformPagePoint), { point: a } = s, { timestamp: l } = Oe; this.history = [{ ...a, timestamp: l }]; let { onSessionStart: c } = t; c && c(e, ju(s, this.history)), this.removeListeners = In(Fn(this.contextWindow, "pointermove", this.handlePointerMove), Fn(this.contextWindow, "pointerup", this.handlePointerUp), Fn(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), dt(this.updatePoint) } }; function Hu(e, t) { return t ? { point: t(e.point) } : e } function gv(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function ju({ point: e }, t) { return { point: e, delta: gv(e, yy(t)), offset: gv(e, uR(t)), velocity: fR(t, .1) } } function uR(e) { return e[0] } function yy(e) { return e[e.length - 1] } function fR(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null, i = yy(e); for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Ln(t)));)n--; if (!r) return { x: 0, y: 0 }; let o = Mn(i.timestamp - r.timestamp); if (o === 0) return { x: 0, y: 0 }; let s = { x: (i.x - r.x) / o, y: (i.y - r.y) / o }; return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s } function dR(e, { min: t, max: n }, r) { return t !== void 0 && e < t ? e = r ? xe(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? xe(n, e, r.max) : Math.min(e, n)), e } function yv(e, t, n) { return { min: t !== void 0 ? e.min + t : void 0, max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0 } } function hR(e, { top: t, left: n, bottom: r, right: i }) { return { x: yv(e.x, n, i), y: yv(e.y, t, r) } } function bv(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } function pR(e, t) { return { x: bv(e.x, t.x), y: bv(e.y, t.y) } } function mR(e, t) { let n = .5, r = Ft(e), i = Ft(t); return i > r ? n = xr(t.min, t.max - r, e.min) : r > i && (n = xr(e.min, e.max - i, t.min)), Jn(0, 1, n) } function vR(e, t) { let n = {}; return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n } var cf = .35; function gR(e = cf) { return e === !1 ? e = 0 : e === !0 && (e = cf), { x: xv(e, "left", "right"), y: xv(e, "top", "bottom") } } function xv(e, t, n) { return { min: Sv(e, t), max: Sv(e, n) } } function Sv(e, t) { return typeof e == "number" ? e : e[t] || 0 } function nn(e) { return [e("x"), e("y")] } function by({ top: e, left: t, right: n, bottom: r }) { return { x: { min: t, max: n }, y: { min: e, max: r } } } function yR({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function bR(e, t) { if (!t) return e; let n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function Wu(e) { return e === void 0 || e === 1 } function uf({ scale: e, scaleX: t, scaleY: n }) { return !Wu(e) || !Wu(t) || !Wu(n) } function ni(e) { return uf(e) || xy(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function xy(e) { return wv(e.x) || wv(e.y) } function wv(e) { return e && e !== "0%" } function Za(e, t, n) { let r = e - n, i = t * r; return n + i } function kv(e, t, n, r, i) { return i !== void 0 && (e = Za(e, i, r)), Za(e, n, r) + t } function ff(e, t = 0, n = 1, r, i) { e.min = kv(e.min, t, n, r, i), e.max = kv(e.max, t, n, r, i) } function Sy(e, { x: t, y: n }) { ff(e.x, t.translate, t.scale, t.originPoint), ff(e.y, n.translate, n.scale, n.originPoint) } function xR(e, t, n, r = !1) { let i = n.length; if (!i) return; t.x = t.y = 1; let o, s; for (let a = 0; a < i; a++) { o = n[a], s = o.projectionDelta; let l = o.instance; l && l.style && l.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && Ni(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }), s && (t.x *= s.x.scale, t.y *= s.y.scale, Sy(e, s)), r && ni(o.latestValues) && Ni(e, o.latestValues)) } t.x = Cv(t.x), t.y = Cv(t.y) } function Cv(e) { return Number.isInteger(e) || e > 1.0000000000001 || e < .999999999999 ? e : 1 } function yr(e, t) { e.min = e.min + t, e.max = e.max + t } function Tv(e, t, [n, r, i]) { let o = t[i] !== void 0 ? t[i] : .5, s = xe(e.min, e.max, o); ff(e, t[n], t[r], s, t.scale) } var SR = ["x", "scaleX", "originX"], wR = ["y", "scaleY", "originY"]; function Ni(e, t) { Tv(e.x, t, SR), Tv(e.y, t, wR) } function wy(e, t) { return by(bR(e.getBoundingClientRect(), t)) } function kR(e, t, n) { let r = wy(e, n), { scroll: i } = t; return i && (yr(r.x, i.offset.x), yr(r.y, i.offset.y)), r } var ky = ({ current: e }) => e ? e.ownerDocument.defaultView : null, CR = new WeakMap, TR = class { constructor(e) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Me(), this.visualElement = e } start(e, { snapToCursor: t = !1 } = {}) { let { presenceContext: n } = this.visualElement; if (n && n.isPresent === !1) return; let r = c => { let { dragSnapToOrigin: u } = this.getProps(); u ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(sl(c, "page").point) }, i = (c, u) => { let { drag: f, dragPropagation: d, onDragStart: p } = this.getProps(); if (f && !d && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = gg(f), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), nn(v => { let S = this.getAxisMotionValue(v).get() || 0; if (_n.test(S)) { let { projection: m } = this.visualElement; if (m && m.layout) { let h = m.layout.layoutBox[v]; h && (S = Ft(h) * (parseFloat(S) / 100)) } } this.originPoint[v] = S }), p && Y.postRender(() => p(c, u)); let { animationState: g } = this.visualElement; g && g.setActive("whileDrag", !0) }, o = (c, u) => { let { dragPropagation: f, dragDirectionLock: d, onDirectionLock: p, onDrag: g } = this.getProps(); if (!f && !this.openGlobalLock) return; let { offset: v } = u; if (d && this.currentDirection === null) { this.currentDirection = ER(v), this.currentDirection !== null && p && p(this.currentDirection); return } this.updateAxis("x", u.point, v), this.updateAxis("y", u.point, v), this.visualElement.render(), g && g(c, u) }, s = (c, u) => this.stop(c, u), a = () => nn(c => { var u; return this.getAnimationState(c) === "paused" && ((u = this.getAxisMotionValue(c).animation) === null || u === void 0 ? void 0 : u.play()) }), { dragSnapToOrigin: l } = this.getProps(); this.panSession = new gy(e, { onSessionStart: r, onStart: i, onMove: o, onSessionEnd: s, resumeAnimation: a }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: l, contextWindow: ky(this.visualElement) }) } stop(e, t) { let n = this.isDragging; if (this.cancel(), !n) return; let { velocity: r } = t; this.startAnimation(r); let { onDragEnd: i } = this.getProps(); i && Y.postRender(() => i(e, t)) } cancel() { this.isDragging = !1; let { projection: e, animationState: t } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; let { dragPropagation: n } = this.getProps(); !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1) } updateAxis(e, t, n) { let { drag: r } = this.getProps(); if (!n || !$a(e, r, this.currentDirection)) return; let i = this.getAxisMotionValue(e), o = this.originPoint[e] + n[e]; this.constraints && this.constraints[e] && (o = dR(o, this.constraints[e], this.elastic[e])), i.set(o) } resolveConstraints() { var e; let { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, i = this.constraints; t && Bi(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = hR(r.layoutBox, t) : this.constraints = !1, this.elastic = gR(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && nn(o => { this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = vR(r.layoutBox[o], this.constraints[o])) }) } resolveRefConstraints() { let { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps(); if (!e || !Bi(e)) return !1; let n = e.current; zt(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."); let { projection: r } = this.visualElement; if (!r || !r.layout) return !1; let i = kR(n, r.root, this.visualElement.getTransformPagePoint()), o = pR(r.layout.layoutBox, i); if (t) { let s = t(yR(o)); this.hasMutatedConstraints = !!s, s && (o = by(s)) } return o } startAnimation(e) { let { drag: t, dragMomentum: n, dragElastic: r, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: s } = this.getProps(), a = this.constraints || {}, l = nn(c => { if (!$a(c, t, this.currentDirection)) return; let u = a && a[c] || {}; o && (u = { min: 0, max: 0 }); let f = r ? 200 : 1e6, d = r ? 40 : 1e7, p = { type: "inertia", velocity: n ? e[c] : 0, bounceStiffness: f, bounceDamping: d, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i, ...u }; return this.startAxisValueAnimation(c, p) }); return Promise.all(l).then(s) } startAxisValueAnimation(e, t) { let n = this.getAxisMotionValue(e); return n.start(Uf(e, n, 0, t, this.visualElement)) } stopAnimation() { nn(e => this.getAxisMotionValue(e).stop()) } pauseAnimation() { nn(e => { var t; return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.pause() }) } getAnimationState(e) { var t; return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.state } getAxisMotionValue(e) { let t = `_drag${e.toUpperCase()}`, n = this.visualElement.getProps(), r = n[t]; return r || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0) } snapToCursor(e) { nn(t => { let { drag: n } = this.getProps(); if (!$a(t, n, this.currentDirection)) return; let { projection: r } = this.visualElement, i = this.getAxisMotionValue(t); if (r && r.layout) { let { min: o, max: s } = r.layout.layoutBox[t]; i.set(e[t] - xe(o, s, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; let { drag: e, dragConstraints: t } = this.getProps(), { projection: n } = this.visualElement; if (!Bi(t) || !n || !this.constraints) return; this.stopAnimation(); let r = { x: 0, y: 0 }; nn(o => { let s = this.getAxisMotionValue(o); if (s && this.constraints !== !1) { let a = s.get(); r[o] = mR({ min: a, max: a }, this.constraints[o]) } }); let { transformTemplate: i } = this.visualElement.getProps(); this.visualElement.current.style.transform = i ? i({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), nn(o => { if (!$a(o, e, null)) return; let s = this.getAxisMotionValue(o), { min: a, max: l } = this.constraints[o]; s.set(xe(a, l, r[o])) }) } addListeners() { if (!this.visualElement.current) return; CR.set(this.visualElement, this); let e = this.visualElement.current, t = Fn(e, "pointerdown", a => { let { drag: l, dragListener: c = !0 } = this.getProps(); l && c && this.start(a) }), n = () => { let { dragConstraints: a } = this.getProps(); Bi(a) && (this.constraints = this.resolveRefConstraints()) }, { projection: r } = this.visualElement, i = r.addEventListener("measure", n); r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), n(); let o = Zn(window, "resize", () => this.scalePositionWithinConstraints()), s = r.addEventListener("didUpdate", ({ delta: a, hasLayoutChanged: l }) => { this.isDragging && l && (nn(c => { let u = this.getAxisMotionValue(c); u && (this.originPoint[c] += a[c].translate, u.set(u.get() + a[c].translate)) }), this.visualElement.render()) }); return () => { o(), t(), i(), s && s() } } getProps() { let e = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: n = !1, dragPropagation: r = !1, dragConstraints: i = !1, dragElastic: o = cf, dragMomentum: s = !0 } = e; return { ...e, drag: t, dragDirectionLock: n, dragPropagation: r, dragConstraints: i, dragElastic: o, dragMomentum: s } } }; function $a(e, t, n) { return (t === !0 || t === e) && (n === null || n === e) } function ER(e, t = 10) { let n = null; return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n } var RR = class extends wr { constructor(e) { super(e), this.removeGroupControls = nt, this.removeListeners = nt, this.controls = new TR(e) } mount() { let { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || nt } unmount() { this.removeGroupControls(), this.removeListeners() } }, Ev = e => (t, n) => { e && Y.postRender(() => e(t, n)) }, PR = class extends wr { constructor() { super(...arguments), this.removePointerDownListener = nt } onPointerDown(e) { this.session = new gy(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: ky(this.node) }) } createPanHandlers() { let { onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: r } = this.node.getProps(); return { onSessionStart: Ev(e), onStart: Ev(t), onMove: n, onEnd: (i, o) => { delete this.session, r && Y.postRender(() => r(i, o)) } } } mount() { this.removePointerDownListener = Fn(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } }, Ha = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Rv(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } var Yo = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (G.test(e)) e = parseFloat(e); else return e; let n = Rv(e, t.target.x), r = Rv(e, t.target.y); return `${n}% ${r}%` } }, _R = { correct: (e, { treeScale: t, projectionDelta: n }) => { let r = e, i = er.parse(e); if (i.length > 5) return r; let o = er.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y; i[0 + s] /= a, i[1 + s] /= l; let c = xe(a, l, .5); return typeof i[2 + s] == "number" && (i[2 + s] /= c), typeof i[3 + s] == "number" && (i[3 + s] /= c), o(i) } }, FR = class extends ve { componentDidMount() { let { visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: r } = this.props, { projection: i } = e; wf(IR), i && (t.group && t.group.add(i), n && n.register && r && n.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => { this.safeToRemove() }), i.setOptions({ ...i.options, onExitComplete: () => this.safeToRemove() })), Ha.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { let { layoutDependency: t, visualElement: n, drag: r, isPresent: i } = this.props, o = n.projection; return o && (o.isPresent = i, r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== i && (i ? o.promote() : o.relegate() || Y.postRender(() => { let s = o.getStack(); (!s || !s.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { let { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), yf.postRender(() => { !e.currentAnimation && e.isLead() && this.safeToRemove() })) } componentWillUnmount() { let { visualElement: e, layoutGroup: t, switchLayoutGroup: n } = this.props, { projection: r } = e; r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), n && n.deregister && n.deregister(r)) } safeToRemove() { let { safeToRemove: e } = this.props; e && e() } render() { return null } }; function Cy(e) { let [t, n] = pl(), r = O(rs); return C(FR, { ...e, layoutGroup: r, switchLayoutGroup: O(nl), isPresent: t, safeToRemove: n }) } var IR = { borderRadius: { ...Yo, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Yo, borderTopRightRadius: Yo, borderBottomLeftRadius: Yo, borderBottomRightRadius: Yo, boxShadow: _R }, Ty = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], LR = Ty.length, Pv = e => typeof e == "string" ? parseFloat(e) : e, _v = e => typeof e == "number" || G.test(e); function MR(e, t, n, r, i, o) { i ? (e.opacity = xe(0, n.opacity !== void 0 ? n.opacity : 1, OR(r)), e.opacityExit = xe(t.opacity !== void 0 ? t.opacity : 1, 0, DR(r))) : o && (e.opacity = xe(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r)); for (let s = 0; s < LR; s++) { let a = `border${Ty[s]}Radius`, l = Fv(t, a), c = Fv(n, a); if (l === void 0 && c === void 0) continue; l || (l = 0), c || (c = 0), l === 0 || c === 0 || _v(l) === _v(c) ? (e[a] = Math.max(xe(Pv(l), Pv(c), r), 0), (_n.test(c) || _n.test(l)) && (e[a] += "%")) : e[a] = c } (t.rotate || n.rotate) && (e.rotate = xe(t.rotate || 0, n.rotate || 0, r)) } function Fv(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } var OR = Ey(0, .5, If), DR = Ey(.5, .95, nt); function Ey(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(xr(e, t, r)) } function Iv(e, t) { e.min = t.min, e.max = t.max } function tn(e, t) { Iv(e.x, t.x), Iv(e.y, t.y) } function Lv(e, t, n, r, i) { return e -= t, e = Za(e, 1 / n, r), i !== void 0 && (e = Za(e, 1 / i, r)), e } function AR(e, t = 0, n = 1, r = .5, i, o = e, s = e) { if (_n.test(t) && (t = parseFloat(t), t = xe(s.min, s.max, t / 100) - s.min), typeof t != "number") return; let a = xe(o.min, o.max, r); e === o && (a -= t), e.min = Lv(e.min, t, n, a, i), e.max = Lv(e.max, t, n, a, i) } function Mv(e, t, [n, r, i], o, s) { AR(e, t[n], t[r], t[i], t.scale, o, s) } var VR = ["x", "scaleX", "originX"], BR = ["y", "scaleY", "originY"]; function Ov(e, t, n, r) { Mv(e.x, t, VR, n ? n.x : void 0, r ? r.x : void 0), Mv(e.y, t, BR, n ? n.y : void 0, r ? r.y : void 0) } function Dv(e) { return e.translate === 0 && e.scale === 1 } function Ry(e) { return Dv(e.x) && Dv(e.y) } function $R(e, t) { return e.x.min === t.x.min && e.x.max === t.x.max && e.y.min === t.y.min && e.y.max === t.y.max } function Py(e, t) { return Math.round(e.x.min) === Math.round(t.x.min) && Math.round(e.x.max) === Math.round(t.x.max) && Math.round(e.y.min) === Math.round(t.y.min) && Math.round(e.y.max) === Math.round(t.y.max) } function Av(e) { return Ft(e.x) / Ft(e.y) } var zR = class { constructor() { this.members = [] } add(e) { Nf(this.members, e), e.scheduleRender() } remove(e) { if (fl(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { let t = this.members[this.members.length - 1]; t && this.promote(t) } } relegate(e) { let t = this.members.findIndex(r => e === r); if (t === 0) return !1; let n; for (let r = t; r >= 0; r--) { let i = this.members[r]; if (i.isPresent !== !1) { n = i; break } } return n ? (this.promote(n), !0) : !1 } promote(e, t) { let n = this.lead; if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) { n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, t && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); let { crossfade: r } = e.options; r === !1 && n.hide() } } exitAnimationComplete() { this.members.forEach(e => { let { options: t, resumingFrom: n } = e; t.onExitComplete && t.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } }; function Vv(e, t, n) { let r = "", i = e.x.translate / t.x, o = e.y.translate / t.y, s = n?.z || 0; if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) { let { transformPerspective: c, rotate: u, rotateX: f, rotateY: d, skewX: p, skewY: g } = n; c && (r = `perspective(${c}px) ${r}`), u && (r += `rotate(${u}deg) `), f && (r += `rotateX(${f}deg) `), d && (r += `rotateY(${d}deg) `), p && (r += `skewX(${p}deg) `), g && (r += `skewY(${g}deg) `) } let a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none" } function NR(e) { window.MotionDebug && window.MotionDebug.record(e) } function _y(e) { return e instanceof SVGElement && e.tagName !== "svg" } function rd(e, t, n) { let r = Te(e) ? e : Ee(e); return r.start(Uf("", r, t, n)), r.animation } var Uu = ["", "X", "Y", "Z"], HR = { visibility: "hidden" }, Bv = 1e3, jR = 0, ri = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }; function Xu(e, t, n, r) { let { latestValues: i } = t; i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function Fy(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return !1; let { visualElement: t } = e.options; return t ? Qg(t) ? !0 : e.parent && !e.parent.hasCheckedOptimisedAppear ? Fy(e.parent) : !1 : !1 } function Iy({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(s = {}, a = t?.()) { this.id = jR++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, ri.totalNodes = ri.resolvedTargetDeltas = ri.recalculatedProjection = 0, this.nodes.forEach(XR), this.nodes.forEach(QR), this.nodes.forEach(ZR), this.nodes.forEach(YR), NR(ri) }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new ey) } addEventListener(s, a) { return this.eventHandlers.has(s) || this.eventHandlers.set(s, new Hf), this.eventHandlers.get(s).add(a) } notifyListeners(s, ...a) { let l = this.eventHandlers.get(s); l && l.notify(...a) } hasListeners(s) { return this.eventHandlers.has(s) } mount(s, a = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = _y(s), this.instance = s; let { layoutId: l, layout: c, visualElement: u } = this.options; if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), e) { let f, d = () => this.root.updateBlockedByResize = !1; e(s, () => { this.root.updateBlockedByResize = !0, f && f(), f = ty(d, 250), Ha.hasAnimatedSinceResize && (Ha.hasAnimatedSinceResize = !1, this.nodes.forEach(zv)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: f, hasLayoutChanged: d, hasRelativeTargetChanged: p, layout: g }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } let v = this.options.transition || u.getDefaultTransition() || rP, { onLayoutAnimationStart: S, onLayoutAnimationComplete: m } = u.getProps(), h = !this.targetLayout || !Py(this.targetLayout, g) || p, y = !d && p; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || y || d && (h || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(f, y); let x = { ...jf(v, "layout"), onPlay: S, onComplete: m }; (u.shouldReduceMotion || this.options.layoutRoot) && (x.delay = 0, x.type = !1), this.startAnimation(x) } else d || zv(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = g }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); let s = this.getStack(); s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, dt(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(JR), this.animationId++) } getTransformTemplate() { let { visualElement: s } = this.options; return s && s.getProps().transformTemplate } willUpdate(s = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.HandoffCancelAllAnimations && Fy(this) && window.HandoffCancelAllAnimations(), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let u = 0; u < this.path.length; u++) { let f = this.path[u]; f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1) } let { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; let c = this.getTransformTemplate(); this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach($v); return } this.isUpdating || this.nodes.forEach(KR), this.isUpdating = !1, this.nodes.forEach(qR), this.nodes.forEach(WR), this.nodes.forEach(UR), this.clearAllSnapshots(); let a = br.now(); Oe.delta = Jn(0, 1e3 / 60, a - Oe.timestamp), Oe.timestamp = a, Oe.isProcessing = !0, za.update.process(Oe), za.preRender.process(Oe), za.render.process(Oe), Oe.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, yf.read(() => this.update())) } clearAllSnapshots() { this.nodes.forEach(GR), this.sharedNodes.forEach(eP) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Y.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Y.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); let s = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Me(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); let { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0) } updateScroll(s = "measure") { let a = !!(this.options.layoutScroll && this.instance); this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a && (this.scroll = { animationId: this.root.animationId, phase: s, isRoot: r(this.instance), offset: n(this.instance) }) } resetTransform() { if (!i) return; let s = this.isLayoutDirty || this.shouldResetTransform, a = this.projectionDelta && !Ry(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue; s && (a || ni(this.latestValues) || u) && (i(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender()) } measure(s = !0) { let a = this.measurePageBox(), l = this.removeElementScroll(a); return s && (l = this.removeTransform(l)), iP(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { let { visualElement: s } = this.options; if (!s) return Me(); let a = s.measureViewportBox(), { scroll: l } = this.root; return l && (yr(a.x, l.offset.x), yr(a.y, l.offset.y)), a } removeElementScroll(s) { let a = Me(); tn(a, s); for (let l = 0; l < this.path.length; l++) { let c = this.path[l], { scroll: u, options: f } = c; if (c !== this.root && u && f.layoutScroll) { if (u.isRoot) { tn(a, s); let { scroll: d } = this.root; d && (yr(a.x, -d.offset.x), yr(a.y, -d.offset.y)) } yr(a.x, u.offset.x), yr(a.y, u.offset.y) } } return a } applyTransform(s, a = !1) { let l = Me(); tn(l, s); for (let c = 0; c < this.path.length; c++) { let u = this.path[c]; !a && u.options.layoutScroll && u.scroll && u !== u.root && Ni(l, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }), ni(u.latestValues) && Ni(l, u.latestValues) } return ni(this.latestValues) && Ni(l, this.latestValues), l } removeTransform(s) { let a = Me(); tn(a, s); for (let l = 0; l < this.path.length; l++) { let c = this.path[l]; if (!c.instance || !ni(c.latestValues)) continue; uf(c.latestValues) && c.updateSnapshot(); let u = Me(), f = c.measurePageBox(); tn(u, f), Ov(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u) } return ni(this.latestValues) && Ov(a, this.latestValues), a } setTargetDelta(s) { this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(s) { this.options = { ...this.options, ...s, crossfade: s.crossfade !== void 0 ? s.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Oe.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(s = !1) { var a; let l = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty); let c = !!this.resumingFrom || this !== l; if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget)) return; let { layout: f, layoutId: d } = this.options; if (!(!this.layout || !(f || d))) { if (this.resolvedRelativeTargetAt = Oe.timestamp, !this.targetDelta && !this.relativeTarget) { let p = this.getClosestProjectingParent(); p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Me(), this.relativeTargetOrigin = Me(), ts(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), tn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = Me(), this.targetWithTransforms = Me()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), OE(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : tn(this.target, this.layout.layoutBox), Sy(this.target, this.targetDelta)) : tn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; let p = this.getClosestProjectingParent(); p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Me(), this.relativeTargetOrigin = Me(), ts(this.relativeTargetOrigin, this.target, p.target), tn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } ri.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || uf(this.parent.latestValues) || xy(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var s; let a = this.getLead(), l = !!this.resumingFrom || this !== a, c = !0; if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === Oe.timestamp && (c = !1), c) return; let { layout: u, layoutId: f } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || f)) return; tn(this.layoutCorrected, this.layout.layoutBox); let d = this.treeScale.x, p = this.treeScale.y; xR(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = Me()); let { target: g } = a; if (!g) { this.projectionTransform && (this.projectionDelta = zi(), this.projectionTransform = "none", this.scheduleRender()); return } this.projectionDelta || (this.projectionDelta = zi(), this.projectionDeltaWithTransform = zi()); let v = this.projectionTransform; es(this.projectionDelta, this.layoutCorrected, g, this.latestValues), this.projectionTransform = Vv(this.projectionDelta, this.treeScale), (this.projectionTransform !== v || this.treeScale.x !== d || this.treeScale.y !== p) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", g)), ri.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(s = !0) { if (this.options.scheduleRender && this.options.scheduleRender(), s) { let a = this.getStack(); a && a.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } setAnimationOrigin(s, a = !1) { let l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, f = zi(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; let d = Me(), p = l ? l.source : void 0, g = this.layout ? this.layout.source : void 0, v = p !== g, S = this.getStack(), m = !S || S.members.length <= 1, h = !!(v && !m && this.options.crossfade === !0 && !this.path.some(nP)); this.animationProgress = 0; let y; this.mixTargetDelta = x => { let k = x / 1e3; Nv(f.x, s.x, k), Nv(f.y, s.y, k), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (ts(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox), tP(this.relativeTarget, this.relativeTargetOrigin, d, k), y && $R(this.relativeTarget, y) && (this.isProjectionDirty = !1), y || (y = Me()), tn(y, this.relativeTarget)), v && (this.animationValues = u, MR(u, c, this.latestValues, k, h, m)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = k }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(s) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (dt(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Y.update(() => { Ha.hasAnimatedSinceResize = !0, this.currentAnimation = rd(0, Bv, { ...s, onUpdate: a => { this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a) }, onComplete: () => { s.onComplete && s.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); let s = this.getStack(); s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Bv), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { let s = this.getLead(), { targetWithTransforms: a, target: l, layout: c, latestValues: u } = s; if (!(!a || !l || !c)) { if (this !== s && this.layout && c && Ly(this.options.animationType, this.layout.layoutBox, c.layoutBox)) { l = this.target || Me(); let f = Ft(this.layout.layoutBox.x); l.x.min = s.target.x.min, l.x.max = l.x.min + f; let d = Ft(this.layout.layoutBox.y); l.y.min = s.target.y.min, l.y.max = l.y.min + d } tn(a, l), Ni(a, u), es(this.projectionDeltaWithTransform, this.layoutCorrected, a, u) } } registerSharedNode(s, a) { this.sharedNodes.has(s) || this.sharedNodes.set(s, new zR), this.sharedNodes.get(s).add(a); let c = a.options.initialPromotionConfig; a.promote({ transition: c ? c.transition : void 0, preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { let s = this.getStack(); return s ? s.lead === this : !0 } getLead() { var s; let { layoutId: a } = this.options; return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this } getPrevLead() { var s; let { layoutId: a } = this.options; return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0 } getStack() { let { layoutId: s } = this.options; if (s) return this.root.sharedNodes.get(s) } promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) { let c = this.getStack(); c && c.promote(this, l), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { let s = this.getStack(); return s ? s.relegate(this) : !1 } resetSkewAndRotation() { let { visualElement: s } = this.options; if (!s) return; let a = !1, { latestValues: l } = s; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; let c = {}; l.z && Xu("z", s, c, this.animationValues); for (let u = 0; u < Uu.length; u++)Xu(`rotate${Uu[u]}`, s, c, this.animationValues), Xu(`skew${Uu[u]}`, s, c, this.animationValues); s.render(); for (let u in c) s.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]); s.scheduleRender() } getProjectionStyles(s) { var a, l; if (!this.instance || this.isSVG) return; if (!this.isVisible) return HR; let c = { visibility: "" }, u = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, c.opacity = "", c.pointerEvents = ft(s?.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c; let f = this.getLead(); if (!this.projectionDelta || !this.layout || !f.target) { let v = {}; return this.options.layoutId && (v.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, v.pointerEvents = ft(s?.pointerEvents) || ""), this.hasProjected && !ni(this.latestValues) && (v.transform = u ? u({}, "") : "none", this.hasProjected = !1), v } let d = f.animationValues || f.latestValues; this.applyTransformsToTarget(), c.transform = Vv(this.projectionDeltaWithTransform, this.treeScale, d), u && (c.transform = u(d, c.transform)); let { x: p, y: g } = this.projectionDelta; c.transformOrigin = `${p.origin * 100}% ${g.origin * 100}% 0`, f.animationValues ? c.opacity = f === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : c.opacity = f === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0; for (let v in Ua) { if (d[v] === void 0) continue; let { correct: S, applyTo: m } = Ua[v], h = c.transform === "none" ? d[v] : S(d[v], f); if (m) { let y = m.length; for (let x = 0; x < y; x++)c[m[x]] = h } else c[v] = h } return this.options.layoutId && (c.pointerEvents = f === this ? ft(s?.pointerEvents) || "" : "none"), c } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(s => { var a; return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach($v), this.root.sharedNodes.clear() } } } function WR(e) { e.updateLayout() } function UR(e) { var t; let n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) { let { layoutBox: r, measuredBox: i } = e.layout, { animationType: o } = e.options, s = n.source !== e.layout.source; o === "size" ? nn(f => { let d = s ? n.measuredBox[f] : n.layoutBox[f], p = Ft(d); d.min = r[f].min, d.max = d.min + p }) : Ly(o, n.layoutBox, r) && nn(f => { let d = s ? n.measuredBox[f] : n.layoutBox[f], p = Ft(r[f]); d.max = d.min + p, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + p) }); let a = zi(); es(a, r, n.layoutBox); let l = zi(); s ? es(l, e.applyTransform(i, !0), n.measuredBox) : es(l, r, n.layoutBox); let c = !Ry(a), u = !1; if (!e.resumeFrom) { let f = e.getClosestProjectingParent(); if (f && !f.resumeFrom) { let { snapshot: d, layout: p } = f; if (d && p) { let g = Me(); ts(g, n.layoutBox, d.layoutBox); let v = Me(); ts(v, r, p.layoutBox), Py(g, v) || (u = !0), f.options.layoutRoot && (e.relativeTarget = v, e.relativeTargetOrigin = g, e.relativeParent = f) } } } e.notifyListeners("didUpdate", { layout: r, snapshot: n, delta: l, layoutDelta: a, hasLayoutChanged: c, hasRelativeTargetChanged: u }) } else if (e.isLead()) { let { onExitComplete: r } = e.options; r && r() } e.options.transition = void 0 } function XR(e) { ri.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function YR(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function GR(e) { e.clearSnapshot() } function $v(e) { e.clearMeasurements() } function KR(e) { e.isLayoutDirty = !1 } function qR(e) { let { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function zv(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function QR(e) { e.resolveTargetDelta() } function ZR(e) { e.calcProjection() } function JR(e) { e.resetSkewAndRotation() } function eP(e) { e.removeLeadSnapshot() } function Nv(e, t, n) { e.translate = xe(t.translate, 0, n), e.scale = xe(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function Hv(e, t, n, r) { e.min = xe(t.min, n.min, r), e.max = xe(t.max, n.max, r) } function tP(e, t, n, r) { Hv(e.x, t.x, n.x, r), Hv(e.y, t.y, n.y, r) } function nP(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } var rP = { duration: .45, ease: [.4, 0, .1, 1] }, jv = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), Wv = jv("applewebkit/") && !jv("chrome/") ? Math.round : nt; function Uv(e) { e.min = Wv(e.min), e.max = Wv(e.max) } function iP(e) { Uv(e.x), Uv(e.y) } function Ly(e, t, n) { return e === "position" || e === "preserve-aspect" && !af(Av(t), Av(n), .2) } var oP = Iy({ attachResizeListener: (e, t) => Zn(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), ai = { current: void 0 }, My = Iy({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!ai.current) { let e = new oP({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), ai.current = e } return ai.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed" }), Oy = { pan: { Feature: PR }, drag: { Feature: RR, ProjectionNode: My, MeasureLayout: Cy } }, Dy = class extends oy { constructor() { super(...arguments), this.KeyframeResolver = Xg } sortInstanceNodePosition(e, t) { return e.compareDocumentPosition(t) & 2 ? 1 : -1 } getBaseTargetFromProps(e, t) { return e.style ? e.style[t] : void 0 } removeValueFromRenderState(e, { vars: t, style: n }) { delete t[e], delete n[e] } }; function sP(e) { return window.getComputedStyle(e) } var Ay = class extends Dy { constructor() { super(...arguments), this.type = "html" } readValueFromInstance(e, t) { if (ci.has(t)) { let n = $f(t); return n && n.default || 0 } else { let n = sP(e), r = (Ig(t) ? n.getPropertyValue(t) : n[t]) || 0; return typeof r == "string" ? r.trim() : r } } measureInstanceViewportBox(e, { transformPagePoint: t }) { return wy(e, t) } build(e, t, n, r) { Zf(e, t, n, r.transformTemplate) } scrapeMotionValuesFromProps(e, t, n) { return nd(e, t, n) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); let { children: e } = this.props; Te(e) && (this.childSubscription = e.on("change", t => { this.current && (this.current.textContent = `${t}`) })) } renderInstance(e, t, n, r) { uy(e, t, n, r) } }, Vy = class extends Dy { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1 } getBaseTargetFromProps(e, t) { return e[t] } readValueFromInstance(e, t) { if (ci.has(t)) { let n = $f(t); return n && n.default || 0 } return t = fy.has(t) ? t : gf(t), e.getAttribute(t) } measureInstanceViewportBox() { return Me() } scrapeMotionValuesFromProps(e, t, n) { return hy(e, t, n) } build(e, t, n, r) { ed(e, t, n, this.isSVGTag, r.transformTemplate) } renderInstance(e, t, n, r) { dy(e, t, n, r) } mount(e) { this.isSVGTag = td(e.tagName), super.mount(e) } }, By = (e, t) => Qf(e) ? new Vy(t, { enableHardwareAcceleration: !1 }) : new Ay(t, { allowProjection: e !== Uo, enableHardwareAcceleration: !0 }), $y = { layout: { ProjectionNode: My, MeasureLayout: Cy } }, aP = { ...Kf, ...vy, ...Oy, ...$y }, Nt = sy((e, t) => py(e, t, aP, By)); var lP = sy(py); function zy() { let e = D(!1); return Sr(() => (e.current = !0, () => { e.current = !1 }), []), e } function ml() { let e = zy(), [t, n] = ut(0), r = pe(() => { e.current && n(t + 1) }, [t]); return [pe(() => Y.postRender(r), [r]), t] } function id(e) { return H(() => () => e(), []) } var cP = class extends ve { getSnapshotBeforeUpdate(e) { let t = this.props.childRef.current; if (t && e.isPresent && !this.props.isPresent) { let n = this.props.sizeRef.current; n.height = t.offsetHeight || 0, n.width = t.offsetWidth || 0, n.top = t.offsetTop, n.left = t.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } }; function uP({ children: e, isPresent: t }) {
    let n = ei(), r = D(null), i = D({ width: 0, height: 0, top: 0, left: 0 }), { nonce: o } = O(On); return ct(() => {
        let { width: s, height: a, top: l, left: c } = i.current; if (t || !r.current || !s || !a) return; r.current.dataset.motionPopId = n; let u = document.createElement("style"); return o && (u.nonce = o), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `), () => { document.head.removeChild(u) }
    }, [t]), C(cP, { isPresent: t, childRef: r, sizeRef: i, children: mn(e, { ref: r }) })
} var Yu = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s }) => { let a = vn(fP), l = ei(), c = he(() => ({ id: l, initial: t, isPresent: n, custom: i, onExitComplete: u => { a.set(u, !0); for (let f of a.values()) if (!f) return; r && r() }, register: u => (a.set(u, !1), () => a.delete(u)) }), o ? [Math.random()] : [n]); return he(() => { a.forEach((u, f) => a.set(f, !1)) }, [n]), H(() => { !n && !a.size && r && r() }, [n]), s === "popLayout" && (e = C(uP, { isPresent: n, children: e })), C(Ui.Provider, { value: c, children: e }) }; function fP() { return new Map } var ii = e => e.key || ""; function dP(e, t) { e.forEach(n => { let r = ii(n); t.set(r, n) }) } function hP(e) { let t = []; return Rn.forEach(e, n => { en(n) && t.push(n) }), t } var od = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, exitBeforeEnter: i, presenceAffectsLayout: o = !0, mode: s = "sync" }) => { zt(!i, "Replace exitBeforeEnter with mode='wait'"); let a = O(rs).forceRender || ml()[0], l = zy(), c = hP(e), u = c, f = D(new Map).current, d = D(u), p = D(new Map).current, g = D(!0); if (Sr(() => { g.current = !1, dP(c, p), d.current = u }), id(() => { g.current = !0, p.clear(), f.clear() }), g.current) return C(Le, { children: u.map(h => C(Yu, { isPresent: !0, initial: n ? void 0 : !1, presenceAffectsLayout: o, mode: s, children: h }, ii(h))) }); u = [...u]; let v = d.current.map(ii), S = c.map(ii), m = v.length; for (let h = 0; h < m; h++) { let y = v[h]; S.indexOf(y) === -1 && !f.has(y) && f.set(y, void 0) } return s === "wait" && f.size && (u = []), f.forEach((h, y) => { if (S.indexOf(y) !== -1) return; let x = p.get(y); if (!x) return; let k = v.indexOf(y), w = h; w || (w = C(Yu, { isPresent: !1, onExitComplete: () => { f.delete(y); let E = Array.from(p.keys()).filter(I => !S.includes(I)); if (E.forEach(I => p.delete(I)), d.current = c.filter(I => { let F = ii(I); return F === y || E.includes(F) }), !f.size) { if (l.current === !1) return; a(), r && r() } }, custom: t, presenceAffectsLayout: o, mode: s, children: x }, ii(x)), f.set(y, w)), u.splice(k, 0, w) }), u = u.map(h => { let y = h.key; return f.has(y) ? h : C(Yu, { isPresent: !0, presenceAffectsLayout: o, mode: s, children: h }, ii(h)) }), C(Le, { children: f.size ? u : u.map(h => mn(h)) }) }; function Ny({ children: e, isValidProp: t, ...n }) { t && dg(t), n = { ...O(On), ...n }, n.isStatic = vn(() => n.isStatic); let r = he(() => n, [JSON.stringify(n.transition), n.transformPagePoint, n.reducedMotion]); return C(On.Provider, { value: r, children: e }) } var Hy = ge(null), pP = e => !e.isLayoutDirty && e.willUpdate(!1); function Xv() { let e = new Set, t = new WeakMap, n = () => e.forEach(pP); return { add: r => { e.add(r), t.set(r, r.addEventListener("willUpdate", n)) }, remove: r => { e.delete(r); let i = t.get(r); i && (i(), t.delete(r)), n() }, dirty: n } } var jy = e => e === !0, mP = e => jy(e === !0) || e === "id", Wy = ({ children: e, id: t, inherit: n = !0 }) => { let r = O(rs), i = O(Hy), [o, s] = ml(), a = D(null), l = r.id || i; a.current === null && (mP(n) && l && (t = t ? l + "-" + t : l), a.current = { id: t, group: jy(n) && r.group || Xv() }); let c = he(() => ({ ...a.current, forceRender: o }), [s]); return C(rs.Provider, { value: c, children: e }) }; function An(e) { let t = vn(() => Ee(e)), { isStatic: n } = O(On); if (n) { let [, r] = ut(e); H(() => t.on("change", r), []) } return t } var vP = e => e && typeof e == "object" && e.mix, gP = e => vP(e) ? e.mix : void 0; function ds(...e) { let t = !Array.isArray(e[0]), n = t ? 0 : -1, r = e[0 + n], i = e[1 + n], o = e[2 + n], s = e[3 + n], a = Ki(i, o, { mixer: gP(o[0]), ...s }); return t ? a(r) : a } function Uy(e, t) { let n = An(t()), r = () => n.set(t()); return r(), Sr(() => { let i = () => Y.preRender(r, !1, !0), o = e.map(s => s.on("change", i)); return () => { o.forEach(s => s()), dt(r) } }), n } function yP(e) { Jo.current = [], e(); let t = Uy(Jo.current, e); return Jo.current = void 0, t } function St(e, t, n, r) { if (typeof e == "function") return yP(e); let i = typeof t == "function" ? t : ds(t, n, r); return Array.isArray(e) ? Yv(e, i) : Yv([e], ([o]) => i(o)) } function Yv(e, t) { let n = vn(() => []); return Uy(e, () => { n.length = 0; let r = e.length; for (let i = 0; i < r; i++)n[i] = e[i].get(); return t(n) }) } var Xy = ge(null); function bP(e, t, n, r) { if (!r) return e; let i = e.findIndex(u => u.value === t); if (i === -1) return e; let o = r > 0 ? 1 : -1, s = e[i + o]; if (!s) return e; let a = e[i], l = s.layout, c = xe(l.min, l.max, .5); return o === 1 && a.layout.max + n > c || o === -1 && a.layout.min + n < c ? fE(e, i, i + o) : e } function xP({ children: e, as: t = "ul", axis: n = "y", onReorder: r, values: i, ...o }, s) { let a = vn(() => Nt(t)), l = [], c = D(!1); zt(!!i, "Reorder.Group must be provided a values prop"); let u = { axis: n, registerItem: (f, d) => { let p = l.findIndex(g => f === g.value); p !== -1 ? l[p].layout = d[n] : l.push({ value: f, layout: d[n] }), l.sort(wP) }, updateOrder: (f, d, p) => { if (c.current) return; let g = bP(l, f, d, p); l !== g && (c.current = !0, r(g.map(SP).filter(v => i.indexOf(v) !== -1))) } }; return H(() => { c.current = !1 }), C(a, { ...o, ref: s, ignoreStrict: !0, children: C(Xy.Provider, { value: u, children: e }) }) } var TB = Ne(xP); function SP(e) { return e.value } function wP(e, t) { return e.layout.min - t.layout.min } function Gv(e, t = 0) { return Te(e) ? e : An(t) } function kP({ children: e, style: t = {}, value: n, as: r = "li", onDrag: i, layout: o = !0, ...s }, a) { let l = vn(() => Nt(r)), c = O(Xy), u = { x: Gv(t.x), y: Gv(t.y) }, f = St([u.x, u.y], ([v, S]) => v || S ? 1 : "unset"); zt(!!c, "Reorder.Item must be a child of Reorder.Group"); let { axis: d, registerItem: p, updateOrder: g } = c; return C(l, { drag: d, ...s, dragSnapToOrigin: !0, style: { ...t, x: u.x, y: u.y, zIndex: f }, layout: o, onDrag: (v, S) => { let { velocity: m } = S; m[d] && g(n, u[d].get(), m[d]), i && i(v, S) }, onLayoutMeasure: v => p(n, v), ref: a, ignoreStrict: !0, children: e }) } var PB = Ne(kP); var Yy = { renderer: By, ...Kf, ...vy }, CP = { ...Yy, ...Oy, ...$y }; function sd(e, t = {}) { let { isStatic: n } = O(On), r = D(null), i = An(Te(e) ? e.get() : e), o = D(i.get()), s = D(() => { }), a = () => { let c = r.current; c && c.time === 0 && c.sample(Oe.delta), l(), r.current = Bf({ keyframes: [i.get(), o.current], velocity: i.getVelocity(), type: "spring", restDelta: .001, restSpeed: .01, ...t, onUpdate: s.current }) }, l = () => { r.current && r.current.stop() }; return ct(() => i.attach((c, u) => n ? u(c) : (o.current = c, s.current = u, Y.update(a), i.get()), l), [JSON.stringify(t)]), Sr(() => { if (Te(e)) return e.on("change", c => i.set(parseFloat(c))) }, [i]), i } function vl(e, t, n) { var r; if (typeof e == "string") { let i = document; t && (zt(!!t.current, "Scope provided, but no element detected."), i = t.current), n ? ((r = n[e]) !== null && r !== void 0 || (n[e] = i.querySelectorAll(e)), e = n[e]) : e = i.querySelectorAll(e) } else e instanceof Element && (e = [e]); return Array.from(e || []) } var ja = new WeakMap, gr; function TP(e, t) { if (t) { let { inlineSize: n, blockSize: r } = t[0]; return { width: n, height: r } } else return e instanceof SVGElement && "getBBox" in e ? e.getBBox() : { width: e.offsetWidth, height: e.offsetHeight } } function EP({ target: e, contentRect: t, borderBoxSize: n }) { var r; (r = ja.get(e)) === null || r === void 0 || r.forEach(i => { i({ target: e, contentSize: t, get size() { return TP(e, n) } }) }) } function RP(e) { e.forEach(EP) } function PP() { typeof ResizeObserver > "u" || (gr = new ResizeObserver(RP)) } function _P(e, t) { gr || PP(); let n = vl(e); return n.forEach(r => { let i = ja.get(r); i || (i = new Set, ja.set(r, i)), i.add(t), gr?.observe(r) }), () => { n.forEach(r => { let i = ja.get(r); i?.delete(t), i?.size || gr?.unobserve(r) }) } } var Wa = new Set, ns; function FP() { ns = () => { let e = { width: window.innerWidth, height: window.innerHeight }, t = { target: window, size: e, contentSize: e }; Wa.forEach(n => n(t)) }, window.addEventListener("resize", ns) } function IP(e) { return Wa.add(e), ns || FP(), () => { Wa.delete(e), !Wa.size && ns && (ns = void 0) } } function LP(e, t) { return typeof e == "function" ? IP(e) : _P(e, t) } var MP = 50, Kv = () => ({ current: 0, offset: [], progress: 0, scrollLength: 0, targetOffset: 0, targetLength: 0, containerLength: 0, velocity: 0 }), OP = () => ({ time: 0, x: Kv(), y: Kv() }), DP = { x: { length: "Width", position: "Left" }, y: { length: "Height", position: "Top" } }; function qv(e, t, n, r) { let i = n[t], { length: o, position: s } = DP[t], a = i.current, l = n.time; i.current = e[`scroll${s}`], i.scrollLength = e[`scroll${o}`] - e[`client${o}`], i.offset.length = 0, i.offset[0] = 0, i.offset[1] = i.scrollLength, i.progress = xr(0, i.scrollLength, i.current); let c = r - l; i.velocity = c > MP ? 0 : Rf(i.current - a, c) } function AP(e, t, n) { qv(e, "x", t, n), qv(e, "y", t, n), t.time = n } function VP(e, t) { let n = { x: 0, y: 0 }, r = e; for (; r && r !== t;)if (r instanceof HTMLElement) n.x += r.offsetLeft, n.y += r.offsetTop, r = r.offsetParent; else if (r.tagName === "svg") { let i = r.getBoundingClientRect(); r = r.parentElement; let o = r.getBoundingClientRect(); n.x += i.left - o.left, n.y += i.top - o.top } else if (r instanceof SVGGraphicsElement) { let { x: i, y: o } = r.getBBox(); n.x += i, n.y += o; let s = null, a = r.parentNode; for (; !s;)a.tagName === "svg" && (s = a), a = r.parentNode; r = s } else break; return n } var BP = { Enter: [[0, 1], [1, 1]], Exit: [[0, 0], [1, 0]], Any: [[1, 0], [0, 1]], All: [[0, 0], [1, 1]] }, df = { start: 0, center: .5, end: 1 }; function Qv(e, t, n = 0) { let r = 0; if (e in df && (e = df[e]), typeof e == "string") { let i = parseFloat(e); e.endsWith("px") ? r = i : e.endsWith("%") ? e = i / 100 : e.endsWith("vw") ? r = i / 100 * document.documentElement.clientWidth : e.endsWith("vh") ? r = i / 100 * document.documentElement.clientHeight : e = i } return typeof e == "number" && (r = t * e), n + r } var $P = [0, 0]; function zP(e, t, n, r) { let i = Array.isArray(e) ? e : $P, o = 0, s = 0; return typeof e == "number" ? i = [e, e] : typeof e == "string" && (e = e.trim(), e.includes(" ") ? i = e.split(" ") : i = [e, df[e] ? e : "0"]), o = Qv(i[0], n, r), s = Qv(i[1], t), o - s } var NP = { x: 0, y: 0 }; function HP(e) { return "getBBox" in e && e.tagName !== "svg" ? e.getBBox() : { width: e.clientWidth, height: e.clientHeight } } function jP(e, t, n) { let { offset: r = BP.All } = n, { target: i = e, axis: o = "y" } = n, s = o === "y" ? "height" : "width", a = i !== e ? VP(i, e) : NP, l = i === e ? { width: e.scrollWidth, height: e.scrollHeight } : HP(i), c = { width: e.clientWidth, height: e.clientHeight }; t[o].offset.length = 0; let u = !t[o].interpolate, f = r.length; for (let d = 0; d < f; d++) { let p = zP(r[d], c[s], l[s], a[o]); !u && p !== t[o].interpolatorOffsets[d] && (u = !0), t[o].offset[d] = p } u && (t[o].interpolate = Ki(t[o].offset, Vf(r)), t[o].interpolatorOffsets = [...t[o].offset]), t[o].progress = t[o].interpolate(t[o].current) } function WP(e, t = e, n) { if (n.x.targetOffset = 0, n.y.targetOffset = 0, t !== e) { let r = t; for (; r && r !== e;)n.x.targetOffset += r.offsetLeft, n.y.targetOffset += r.offsetTop, r = r.offsetParent } n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth, n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight, n.x.containerLength = e.clientWidth, n.y.containerLength = e.clientHeight } function UP(e, t, n, r = {}) { return { measure: () => WP(e, r.target, n), update: i => { AP(e, n, i), (r.offset || r.target) && jP(e, n, r) }, notify: () => t(n) } } var Go = new WeakMap, Zv = new WeakMap, Gu = new WeakMap, Jv = e => e === document.documentElement ? window : e; function qi(e, { container: t = document.documentElement, ...n } = {}) { let r = Gu.get(t); r || (r = new Set, Gu.set(t, r)); let i = OP(), o = UP(t, e, i, n); if (r.add(o), !Go.has(t)) { let a = () => { for (let d of r) d.measure() }, l = () => { for (let d of r) d.update(Oe.timestamp) }, c = () => { for (let d of r) d.notify() }, u = () => { Y.read(a, !1, !0), Y.read(l, !1, !0), Y.update(c, !1, !0) }; Go.set(t, u); let f = Jv(t); window.addEventListener("resize", u, { passive: !0 }), t !== document.documentElement && Zv.set(t, LP(t, u)), f.addEventListener("scroll", u, { passive: !0 }) } let s = Go.get(t); return Y.read(s, !1, !0), () => { var a; dt(s); let l = Gu.get(t); if (!l || (l.delete(o), l.size)) return; let c = Go.get(t); Go.delete(t), c && (Jv(t).removeEventListener("scroll", c), (a = Zv.get(t)) === null || a === void 0 || a(), window.removeEventListener("resize", c)) } } function eg(e, t) { Xi(!!(!t || t.current), `You have defined a ${e} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`) } var XP = () => ({ scrollX: Ee(0), scrollY: Ee(0), scrollXProgress: Ee(0), scrollYProgress: Ee(0) }); function Gy({ container: e, target: t, layoutEffect: n = !0, ...r } = {}) { let i = vn(XP); return (n ? Sr : H)(() => (eg("target", t), eg("container", e), qi(({ x: s, y: a }) => { i.scrollX.set(s.current), i.scrollXProgress.set(s.progress), i.scrollY.set(a.current), i.scrollYProgress.set(a.progress) }, { ...r, container: e?.current || void 0, target: t?.current || void 0 })), [e, t, JSON.stringify(r.offset)]), i } function YP(e) { let t = D(0), { isStatic: n } = O(On); H(() => { if (n) return; let r = ({ timestamp: i, delta: o }) => { t.current || (t.current = i), e(i - t.current, o) }; return Y.update(r, !0), () => dt(r) }, [e]) } function Ky() { !qf.current && ny(); let [e] = ut(Qa.current); return e } function ui() { let e = Ky(), { reducedMotion: t } = O(On); return t === "never" ? !1 : t === "always" ? !0 : e } function GP(e) { e.values.forEach(t => t.stop()) } function hf(e, t) { [...t].reverse().forEach(r => { let i = e.getVariant(r); i && Xf(e, i), e.variantChildren && e.variantChildren.forEach(o => { hf(o, t) }) }) } function KP(e, t) { if (Array.isArray(t)) return hf(e, t); if (typeof t == "string") return hf(e, [t]); Xf(e, t) } function qy() { let e = !1, t = new Set, n = { subscribe(r) { return t.add(r), () => void t.delete(r) }, start(r, i) { zt(e, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook."); let o = []; return t.forEach(s => { o.push(Gf(s, r, { transitionOverride: i })) }), Promise.all(o) }, set(r) { return zt(e, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."), t.forEach(i => { KP(i, r) }) }, stop() { t.forEach(r => { GP(r) }) }, mount() { return e = !0, () => { e = !1, n.stop() } } }; return n } var Qy = (e, t, n) => { let r = t - e; return ((n - e) % r + r) % r + e }; function qP(e) { return typeof e == "object" && !Array.isArray(e) } function QP(e) { let t = { presenceContext: null, props: {}, visualState: { renderState: { transform: {}, transformOrigin: {}, style: {}, vars: {}, attrs: {} }, latestValues: {} } }, n = _y(e) ? new Vy(t, { enableHardwareAcceleration: !1 }) : new Ay(t, { enableHardwareAcceleration: !0 }); n.mount(e), tr.set(e, n) } function ZP(e, t = 100) { let n = fs({ keyframes: [0, t], ...e }), r = Math.min(Bg(n), tf); return { type: "keyframes", ease: i => n.next(r * i).value / t, duration: Mn(r) } } function tg(e, t, n, r) { var i; return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : (i = r.get(t)) !== null && i !== void 0 ? i : e } function JP(e, t) { return Dg(e) ? e[Qy(0, e.length, t)] : e } function e_(e, t, n) { for (let r = 0; r < e.length; r++) { let i = e[r]; i.at > t && i.at < n && (fl(e, i), r--) } } function t_(e, t, n, r, i, o) { e_(e, i, o); for (let s = 0; s < t.length; s++)e.push({ value: t[s], at: xe(i, o, r[s]), easing: JP(n, s) }) } function n_(e, t) { return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at } var r_ = "easeInOut"; function i_(e, { defaultTransition: t = {}, ...n } = {}, r) { let i = t.duration || .3, o = new Map, s = new Map, a = {}, l = new Map, c = 0, u = 0, f = 0; for (let d = 0; d < e.length; d++) { let p = e[d]; if (typeof p == "string") { l.set(p, u); continue } else if (!Array.isArray(p)) { l.set(p.name, tg(u, p.at, c, l)); continue } let [g, v, S = {}] = p; S.at !== void 0 && (u = tg(u, S.at, c, l)); let m = 0, h = (y, x, k, w = 0, T = 0) => { let E = o_(y), { delay: I = 0, times: F = Vf(E), type: B = "keyframes", ...V } = x, { ease: K = t.ease || "easeOut", duration: Z } = x, j = typeof I == "function" ? I(w, T) : I, ne = E.length; if (ne <= 2 && B === "spring") { let J = 100; if (ne === 2 && l_(E)) { let te = E[1] - E[0]; J = Math.abs(te) } let ie = { ...V }; Z !== void 0 && (ie.duration = Ln(Z)); let se = ZP(ie, J); K = se.ease, Z = se.duration } Z ?? (Z = i); let U = u + j, X = U + Z; F.length === 1 && F[0] === 0 && (F[1] = 1); let z = F.length - E.length; z > 0 && Ag(F, z), E.length === 1 && E.unshift(null), t_(k, E, K, F, U, X), m = Math.max(j + Z, m), f = Math.max(X, f) }; if (Te(g)) { let y = ng(g, s); h(v, S, rg("default", y)) } else { let y = vl(g, r, a), x = y.length; for (let k = 0; k < x; k++) { v = v, S = S; let w = y[k], T = ng(w, s); for (let E in v) h(v[E], s_(S, E), rg(E, T), k, x) } } c = u, u += m } return s.forEach((d, p) => { for (let g in d) { let v = d[g]; v.sort(n_); let S = [], m = [], h = []; for (let x = 0; x < v.length; x++) { let { at: k, value: w, easing: T } = v[x]; S.push(w), m.push(xr(0, f, k)), h.push(T || "easeOut") } m[0] !== 0 && (m.unshift(0), S.unshift(S[0]), h.unshift(r_)), m[m.length - 1] !== 1 && (m.push(1), S.push(null)), o.has(p) || o.set(p, { keyframes: {}, transition: {} }); let y = o.get(p); y.keyframes[g] = S, y.transition[g] = { ...t, duration: f, ease: h, times: m, ...n } } }), o } function ng(e, t) { return !t.has(e) && t.set(e, {}), t.get(e) } function rg(e, t) { return t[e] || (t[e] = []), t[e] } function o_(e) { return Array.isArray(e) ? e : [e] } function s_(e, t) { return e[t] ? { ...e, ...e[t] } : { ...e } } var a_ = e => typeof e == "number", l_ = e => e.every(a_); function Zy(e, t, n, r) { let i = vl(e, r), o = i.length; zt(!!o, "No valid element provided."); let s = []; for (let a = 0; a < o; a++) { let l = i[a]; tr.has(l) || QP(l); let c = tr.get(l), u = { ...n }; typeof u.delay == "function" && (u.delay = u.delay(a, o)), s.push(...Yf(c, { ...t, transition: u }, {})) } return new Wf(s) } var c_ = e => Array.isArray(e) && Array.isArray(e[0]); function u_(e, t, n) { let r = []; return i_(e, t, n).forEach(({ keyframes: o, transition: s }, a) => { let l; Te(a) ? l = rd(a, o.default, s.default) : l = Zy(a, o, s), r.push(l) }), new Wf(r) } var ad = e => { function t(n, r, i) { let o; return c_(n) ? o = u_(n, r, e) : qP(r) ? o = Zy(n, r, i, e) : o = rd(n, r, i), e && e.animations.push(o), o } return t }, Qi = ad(); function f_() { let e = vn(() => ({ current: null, animations: [] })), t = vn(() => ad(e)); return id(() => { e.animations.forEach(n => n.stop()) }), [e, t] } function Jy() { let e = vn(qy); return Sr(e.mount, []), e } var e0 = Jy; var d_ = { some: 0, all: 1 }; function t0(e, t, { root: n, margin: r, amount: i = "some" } = {}) { let o = vl(e), s = new WeakMap, a = c => { c.forEach(u => { let f = s.get(u.target); if (u.isIntersecting !== !!f) if (u.isIntersecting) { let d = t(u); typeof d == "function" ? s.set(u.target, d) : l.unobserve(u.target) } else f && (f(u), s.delete(u.target)) }) }, l = new IntersectionObserver(a, { root: n, rootMargin: r, threshold: typeof i == "number" ? i : d_[i] }); return o.forEach(c => l.observe(c)), () => l.disconnect() } function h_(e, { root: t, margin: n, amount: r, once: i = !1 } = {}) { let [o, s] = ut(!1); return H(() => { if (!e.current || i && o) return; let a = () => (s(!0), i ? void 0 : () => s(!1)), l = { root: t && t.current || void 0, margin: n, amount: r }; return t0(e.current, a, l) }, [t, e, n, i, r]), o } function ld(e) { return e !== null && typeof e == "object" && Sf in e } function n0(e) { if (ld(e)) return e[Sf] } function cd() { return p_ } function p_(e) { ai.current && (ai.current.isUpdating = !1, ai.current.blockUpdate(), e && e()) } function r0() { let [e, t] = ml(), n = cd(), r = D(); return H(() => { Y.postRender(() => Y.postRender(() => { t === r.current && (Ga.current = !1) })) }, [t]), i => { n(() => { Ga.current = !0, e(), i(), r.current = t + 1 }) } } function i0() { return pe(() => { let t = ai.current; t && t.resetTree() }, []) } var ig = () => ({}); var NB = ol({ scrapeMotionValuesFromProps: ig, createRenderState: ig }); var m_ = Ko.reduce((e, t) => (e[t] = n => dt(n), e), {}); Jt(); var qF = {}; _u(qF, { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => BF, createPortal: () => $F, createRoot: () => zF, default: () => wp, findDOMNode: () => NF, flushSync: () => HF, hydrate: () => jF, hydrateRoot: () => WF, render: () => UF, unmountComponentAtNode: () => XF, unstable_batchedUpdates: () => YF, unstable_renderSubtreeIntoContainer: () => GF, version: () => KF }); Jt(); var wl = {}; _u(wl, { default: () => q, unstable_IdlePriority: () => y_, unstable_ImmediatePriority: () => b_, unstable_LowPriority: () => x_, unstable_NormalPriority: () => S_, unstable_Profiling: () => w_, unstable_UserBlockingPriority: () => k_, unstable_cancelCallback: () => C_, unstable_continueExecution: () => T_, unstable_forceFrameRate: () => E_, unstable_getCurrentPriorityLevel: () => R_, unstable_getFirstCallbackNode: () => P_, unstable_next: () => __, unstable_now: () => g_, unstable_pauseExecution: () => F_, unstable_requestPaint: () => I_, unstable_runWithPriority: () => L_, unstable_scheduleCallback: () => M_, unstable_shouldYield: () => O_, unstable_wrapCallback: () => D_ }); Jt(); var q = {}; function hd(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < gl(i, t))) break e; e[r] = t, e[n] = i, n = r } } function gn(e) { return e.length === 0 ? null : e[0] } function bl(e) { if (e.length === 0) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, o = i >>> 1; r < o;) { var s = 2 * (r + 1) - 1, a = e[s], l = s + 1, c = e[l]; if (0 > gl(a, n)) l < i && 0 > gl(c, a) ? (e[r] = c, e[l] = n, r = l) : (e[r] = a, e[s] = n, r = s); else { if (!(l < i && 0 > gl(c, n))) break e; e[r] = c, e[l] = n, r = l } } } return t } function gl(e, t) { var n = e.sortIndex - t.sortIndex; return n !== 0 ? n : e.id - t.id } typeof performance == "object" && typeof performance.now == "function" ? (o0 = performance, q.unstable_now = function () { return o0.now() }) : (ud = Date, s0 = ud.now(), q.unstable_now = function () { return ud.now() - s0 }); var o0, ud, s0, Vn = [], kr = [], v_ = 1, on = null, ht = 3, xl = !1, fi = !1, ps = !1, c0 = typeof setTimeout == "function" ? setTimeout : null, u0 = typeof clearTimeout == "function" ? clearTimeout : null, a0 = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function pd(e) { for (var t = gn(kr); t !== null;) { if (t.callback === null) bl(kr); else { if (!(t.startTime <= e)) break; bl(kr), t.sortIndex = t.expirationTime, hd(Vn, t) } t = gn(kr) } } function md(e) { if (ps = !1, pd(e), !fi) if (gn(Vn) !== null) fi = !0, gd(vd); else { var t = gn(kr); t !== null && yd(md, t.startTime - e) } } function vd(e, t) { fi = !1, ps && (ps = !1, u0(ms), ms = -1), xl = !0; var n = ht; try { for (pd(t), on = gn(Vn); on !== null && (!(on.expirationTime > t) || e && !h0());) { var r = on.callback; if (typeof r == "function") { on.callback = null, ht = on.priorityLevel; var i = r(on.expirationTime <= t); t = q.unstable_now(), typeof i == "function" ? on.callback = i : on === gn(Vn) && bl(Vn), pd(t) } else bl(Vn); on = gn(Vn) } if (on !== null) var o = !0; else { var s = gn(kr); s !== null && yd(md, s.startTime - t), o = !1 } return o } finally { on = null, ht = n, xl = !1 } } var Sl = !1, yl = null, ms = -1, f0 = 5, d0 = -1; function h0() { return !(q.unstable_now() - d0 < f0) } function fd() { if (yl !== null) { var e = q.unstable_now(); d0 = e; var t = !0; try { t = yl(!0, e) } finally { t ? hs() : (Sl = !1, yl = null) } } else Sl = !1 } var hs; typeof a0 == "function" ? hs = function () { a0(fd) } : typeof MessageChannel < "u" ? (dd = new MessageChannel, l0 = dd.port2, dd.port1.onmessage = fd, hs = function () { l0.postMessage(null) }) : hs = function () { c0(fd, 0) }; var dd, l0; function gd(e) { yl = e, Sl || (Sl = !0, hs()) } function yd(e, t) { ms = c0(function () { e(q.unstable_now()) }, t) } q.unstable_IdlePriority = 5; q.unstable_ImmediatePriority = 1; q.unstable_LowPriority = 4; q.unstable_NormalPriority = 3; q.unstable_Profiling = null; q.unstable_UserBlockingPriority = 2; q.unstable_cancelCallback = function (e) { e.callback = null }; q.unstable_continueExecution = function () { fi || xl || (fi = !0, gd(vd)) }; q.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : f0 = 0 < e ? Math.floor(1e3 / e) : 5 }; q.unstable_getCurrentPriorityLevel = function () { return ht }; q.unstable_getFirstCallbackNode = function () { return gn(Vn) }; q.unstable_next = function (e) { switch (ht) { case 1: case 2: case 3: var t = 3; break; default: t = ht }var n = ht; ht = t; try { return e() } finally { ht = n } }; q.unstable_pauseExecution = function () { }; q.unstable_requestPaint = function () { }; q.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = ht; ht = e; try { return t() } finally { ht = n } }; q.unstable_scheduleCallback = function (e, t, n) { var r = q.unstable_now(); switch (typeof n == "object" && n !== null ? (n = n.delay, n = typeof n == "number" && 0 < n ? r + n : r) : n = r, e) { case 1: var i = -1; break; case 2: i = 250; break; case 5: i = 1073741823; break; case 4: i = 1e4; break; default: i = 5e3 }return i = n + i, e = { id: v_++, callback: t, priorityLevel: e, startTime: n, expirationTime: i, sortIndex: -1 }, n > r ? (e.sortIndex = n, hd(kr, e), gn(Vn) === null && e === gn(kr) && (ps ? (u0(ms), ms = -1) : ps = !0, yd(md, n - r))) : (e.sortIndex = i, hd(Vn, e), fi || xl || (fi = !0, gd(vd))), e }; q.unstable_shouldYield = h0; q.unstable_wrapCallback = function (e) { var t = ht; return function () { var n = ht; ht = t; try { return e.apply(this, arguments) } finally { ht = n } } }; var g_ = q.unstable_now, y_ = q.unstable_IdlePriority, b_ = q.unstable_ImmediatePriority, x_ = q.unstable_LowPriority, S_ = q.unstable_NormalPriority, w_ = q.unstable_Profiling, k_ = q.unstable_UserBlockingPriority, C_ = q.unstable_cancelCallback, T_ = q.unstable_continueExecution, E_ = q.unstable_forceFrameRate, R_ = q.unstable_getCurrentPriorityLevel, P_ = q.unstable_getFirstCallbackNode, __ = q.unstable_next, F_ = q.unstable_pauseExecution, I_ = q.unstable_requestPaint, L_ = q.unstable_runWithPriority, M_ = q.unstable_scheduleCallback, O_ = q.unstable_shouldYield, D_ = q.unstable_wrapCallback; var A_ = "default" in _t ? b : _t, V_ = "default" in wl ? q : wl, Xt = {}, xb = A_, Ut = V_; function L(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Sb = new Set, Vs = {}; function Ci(e, t) { bo(e, t), bo(e + "Capture", t) } function bo(e, t) { for (Vs[e] = t, e = 0; e < t.length; e++)Sb.add(t[e]) } var ar = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Nd = Object.prototype.hasOwnProperty, B_ = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, p0 = {}, m0 = {}; function $_(e) { return Nd.call(m0, e) ? !0 : Nd.call(p0, e) ? !1 : B_.test(e) ? m0[e] = !0 : (p0[e] = !0, !1) } function z_(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function N_(e, t, n, r) { if (t === null || typeof t > "u" || z_(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function Ct(e, t, n, r, i, o, s) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = s } var ot = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { ot[e] = new Ct(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; ot[t] = new Ct(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { ot[e] = new Ct(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { ot[e] = new Ct(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { ot[e] = new Ct(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { ot[e] = new Ct(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { ot[e] = new Ct(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { ot[e] = new Ct(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { ot[e] = new Ct(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var Lh = /[\-:]([a-z])/g; function Mh(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(Lh, Mh); ot[t] = new Ct(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(Lh, Mh); ot[t] = new Ct(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(Lh, Mh); ot[t] = new Ct(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { ot[e] = new Ct(e, 1, !1, e.toLowerCase(), null, !1, !1) }); ot.xlinkHref = new Ct("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { ot[e] = new Ct(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function Oh(e, t, n, r) { var i = ot.hasOwnProperty(t) ? ot[t] : null; (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (N_(t, n, i, r) && (n = null), r || i === null ? $_(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type !== 3 && "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var fr = xb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, kl = Symbol.for("react.element"), eo = Symbol.for("react.portal"), to = Symbol.for("react.fragment"), Dh = Symbol.for("react.strict_mode"), Hd = Symbol.for("react.profiler"), wb = Symbol.for("react.provider"), kb = Symbol.for("react.context"), Ah = Symbol.for("react.forward_ref"), jd = Symbol.for("react.suspense"), Wd = Symbol.for("react.suspense_list"), Vh = Symbol.for("react.memo"), Tr = Symbol.for("react.lazy"); Symbol.for("react.scope"); Symbol.for("react.debug_trace_mode"); var Cb = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"); Symbol.for("react.cache"); Symbol.for("react.tracing_marker"); var v0 = Symbol.iterator; function vs(e) { return e === null || typeof e != "object" ? null : (e = v0 && e[v0] || e["@@iterator"], typeof e == "function" ? e : null) } var bd, Fe = Object.assign; function Cs(e) {
    if (bd === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); bd = t && t[1] || "" } return `
`+ bd + e
} var xd = !1; function Sd(e, t) {
    if (!e || xd) return ""; xd = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var r = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { r = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { r = c } e() } } catch (c) {
        if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];)a--; for (; 1 <= s && 0 <= a; s--, a--)if (i[s] !== o[a]) {
                if (s !== 1 || a !== 1) do if (s--, a--, 0 > a || i[s] !== o[a]) {
                    var l = `
`+ i[s].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                } while (1 <= s && 0 <= a); break
            }
        }
    } finally { xd = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? Cs(e) : ""
} function H_(e) { switch (e.tag) { case 5: return Cs(e.type); case 16: return Cs("Lazy"); case 13: return Cs("Suspense"); case 19: return Cs("SuspenseList"); case 0: case 2: case 15: return e = Sd(e.type, !1), e; case 11: return e = Sd(e.type.render, !1), e; case 1: return e = Sd(e.type, !0), e; default: return "" } } function Ud(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case to: return "Fragment"; case eo: return "Portal"; case Hd: return "Profiler"; case Dh: return "StrictMode"; case jd: return "Suspense"; case Wd: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case kb: return (e.displayName || "Context") + ".Consumer"; case wb: return (e._context.displayName || "Context") + ".Provider"; case Ah: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Vh: return t = e.displayName || null, t !== null ? t : Ud(e.type) || "Memo"; case Tr: t = e._payload, e = e._init; try { return Ud(e(t)) } catch { } }return null } function j_(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Ud(t); case 8: return t === Dh ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function $r(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function Tb(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function W_(e) { var t = Tb(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (s) { r = "" + s, o.call(this, s) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (s) { r = "" + s }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Cl(e) { e._valueTracker || (e._valueTracker = W_(e)) } function Eb(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = Tb(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n && (t.setValue(e), !0) } function Zl(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Xd(e, t) { var n = t.checked; return Fe({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function g0(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = $r(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function Rb(e, t) { t = t.checked, t != null && Oh(e, "checked", t, !1) } function Yd(e, t) { Rb(e, t); var n = $r(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Gd(e, t.type, n) : t.hasOwnProperty("defaultValue") && Gd(e, t.type, $r(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function y0(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function Gd(e, t, n) { t === "number" && Zl(e.ownerDocument) === e || (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var Ts = Array.isArray; function ho(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + $r(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) { e[i].selected = !0, r && (e[i].defaultSelected = !0); return } t !== null || e[i].disabled || (t = e[i]) } t !== null && (t.selected = !0) } } function Kd(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(L(91)); return Fe({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function b0(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(L(92)); if (Ts(n)) { if (1 < n.length) throw Error(L(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: $r(n) } } function Pb(e, t) { var n = $r(t.value), r = $r(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function x0(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function _b(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function qd(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? _b(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Tl, Fb = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, i) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (Tl = Tl || document.createElement("div"), Tl.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Tl.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function Bs(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Ps = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, U_ = ["Webkit", "ms", "Moz", "O"]; Object.keys(Ps).forEach(function (e) { U_.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Ps[t] = Ps[e] }) }); function Ib(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Ps.hasOwnProperty(e) && Ps[e] ? ("" + t).trim() : t + "px" } function Lb(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = Ib(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } var X_ = Fe({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Qd(e, t) { if (t) { if (X_[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(L(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(L(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(L(61)) } if (t.style != null && typeof t.style != "object") throw Error(L(62)) } } function Zd(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Jd = null; function Bh(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var eh = null, po = null, mo = null; function S0(e) { if (e = na(e)) { if (typeof eh != "function") throw Error(L(280)); var t = e.stateNode; t && (t = Ec(t), eh(e.stateNode, e.type, t)) } } function Mb(e) { po ? mo ? mo.push(e) : mo = [e] : po = e } function Ob() { if (po) { var e = po, t = mo; if (mo = po = null, S0(e), t) for (e = 0; e < t.length; e++)S0(t[e]) } } function Db(e, t) { return e(t) } function Ab() { } var wd = !1; function Vb(e, t, n) { if (wd) return e(t, n); wd = !0; try { return Db(e, t, n) } finally { wd = !1, (po !== null || mo !== null) && (Ab(), Ob()) } } function $s(e, t) { var n = e.stateNode; if (n === null) return null; var r = Ec(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(L(231, t, typeof n)); return n } var th = !1; if (ar) try { Zi = {}, Object.defineProperty(Zi, "passive", { get: function () { th = !0 } }), window.addEventListener("test", Zi, Zi), window.removeEventListener("test", Zi, Zi) } catch { th = !1 } var Zi; function Y_(e, t, n, r, i, o, s, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (u) { this.onError(u) } } var _s = !1, Jl = null, ec = !1, nh = null, G_ = { onError: function (e) { _s = !0, Jl = e } }; function K_(e, t, n, r, i, o, s, a, l) { _s = !1, Jl = null, Y_.apply(G_, arguments) } function q_(e, t, n, r, i, o, s, a, l) { if (K_.apply(this, arguments), _s) { if (!_s) throw Error(L(198)); var c = Jl; _s = !1, Jl = null, ec || (ec = !0, nh = c) } } function Ti(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, 4098 & t.flags && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Bb(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function w0(e) { if (Ti(e) !== e) throw Error(L(188)) } function Q_(e) { var t = e.alternate; if (!t) { if (t = Ti(e), t === null) throw Error(L(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (i === null) break; var o = i.alternate; if (o === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return w0(i), e; if (o === r) return w0(i), t; o = o.sibling } throw Error(L(188)) } if (n.return !== r.return) n = i, r = o; else { for (var s = !1, a = i.child; a;) { if (a === n) { s = !0, n = i, r = o; break } if (a === r) { s = !0, r = i, n = o; break } a = a.sibling } if (!s) { for (a = o.child; a;) { if (a === n) { s = !0, n = o, r = i; break } if (a === r) { s = !0, r = o, n = i; break } a = a.sibling } if (!s) throw Error(L(189)) } } if (n.alternate !== r) throw Error(L(190)) } if (n.tag !== 3) throw Error(L(188)); return n.stateNode.current === n ? e : t } function $b(e) { return e = Q_(e), e !== null ? zb(e) : null } function zb(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = zb(e); if (t !== null) return t; e = e.sibling } return null } var Nb = Ut.unstable_scheduleCallback, k0 = Ut.unstable_cancelCallback, Z_ = Ut.unstable_shouldYield, J_ = Ut.unstable_requestPaint, He = Ut.unstable_now, e2 = Ut.unstable_getCurrentPriorityLevel, $h = Ut.unstable_ImmediatePriority, Hb = Ut.unstable_UserBlockingPriority, tc = Ut.unstable_NormalPriority, t2 = Ut.unstable_LowPriority, jb = Ut.unstable_IdlePriority, wc = null, Nn = null; function n2(e) { if (Nn && typeof Nn.onCommitFiberRoot == "function") try { Nn.onCommitFiberRoot(wc, e, void 0, (128 & e.current.flags) === 128) } catch { } } var wn = Math.clz32 ? Math.clz32 : o2, r2 = Math.log, i2 = Math.LN2; function o2(e) { return e >>>= 0, e === 0 ? 32 : 31 - (r2(e) / i2 | 0) | 0 } var El = 64, Rl = 4194304; function Es(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function nc(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, s = 268435455 & n; if (s !== 0) { var a = s & ~i; a !== 0 ? r = Es(a) : (o &= s, o !== 0 && (r = Es(o))) } else s = n & ~i, s !== 0 ? r = Es(s) : o !== 0 && (r = Es(o)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & i) && (i = r & -r, o = t & -t, i >= o || i === 16 && (4194240 & o) !== 0)) return t; if (4 & r && (r |= 16 & n), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - wn(t), i = 1 << n, r |= e[n], t &= ~i; return r } function s2(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function a2(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var s = 31 - wn(o), a = 1 << s, l = i[s]; l === -1 ? a & n && !(a & r) || (i[s] = s2(a, t)) : l <= t && (e.expiredLanes |= a), o &= ~a } } function rh(e) { return e = -1073741825 & e.pendingLanes, e !== 0 ? e : 1073741824 & e ? 1073741824 : 0 } function Wb() { var e = El; return El <<= 1, !(4194240 & El) && (El = 64), e } function kd(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function ea(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - wn(t), e[t] = n } function l2(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - wn(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } } function zh(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - wn(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var me = 0; function Ub(e) { return e &= -e, 1 < e ? 4 < e ? 268435455 & e ? 16 : 536870912 : 4 : 1 } var Xb, Nh, Yb, Gb, Kb, ih = !1, Pl = [], Ir = null, Lr = null, Mr = null, zs = new Map, Ns = new Map, Rr = [], c2 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function C0(e, t) { switch (e) { case "focusin": case "focusout": Ir = null; break; case "dragenter": case "dragleave": Lr = null; break; case "mouseover": case "mouseout": Mr = null; break; case "pointerover": case "pointerout": zs.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Ns.delete(t.pointerId) } } function gs(e, t, n, r, i, o) { return e === null || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, t !== null && (t = na(t), t !== null && Nh(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e) } function u2(e, t, n, r, i) { switch (t) { case "focusin": return Ir = gs(Ir, e, t, n, r, i), !0; case "dragenter": return Lr = gs(Lr, e, t, n, r, i), !0; case "mouseover": return Mr = gs(Mr, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return zs.set(o, gs(zs.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, Ns.set(o, gs(Ns.get(o) || null, e, t, n, r, i)), !0 }return !1 } function qb(e) { var t = pi(e.target); if (t !== null) { var n = Ti(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Bb(n), t !== null) { e.blockedOn = t, Kb(e.priority, function () { Yb(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Hl(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = oh(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n !== null) return t = na(n), t !== null && Nh(t), e.blockedOn = n, !1; n = e.nativeEvent; var r = new n.constructor(n.type, n); Jd = r, n.target.dispatchEvent(r), Jd = null, t.shift() } return !0 } function T0(e, t, n) { Hl(e) && n.delete(t) } function f2() { ih = !1, Ir !== null && Hl(Ir) && (Ir = null), Lr !== null && Hl(Lr) && (Lr = null), Mr !== null && Hl(Mr) && (Mr = null), zs.forEach(T0), Ns.forEach(T0) } function ys(e, t) { e.blockedOn === t && (e.blockedOn = null, ih || (ih = !0, Ut.unstable_scheduleCallback(Ut.unstable_NormalPriority, f2))) } function Hs(e) { function t(i) { return ys(i, e) } if (0 < Pl.length) { ys(Pl[0], e); for (var n = 1; n < Pl.length; n++) { var r = Pl[n]; r.blockedOn === e && (r.blockedOn = null) } } for (Ir !== null && ys(Ir, e), Lr !== null && ys(Lr, e), Mr !== null && ys(Mr, e), zs.forEach(t), Ns.forEach(t), n = 0; n < Rr.length; n++)r = Rr[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < Rr.length && (n = Rr[0], n.blockedOn === null);)qb(n), n.blockedOn === null && Rr.shift() } var vo = fr.ReactCurrentBatchConfig, rc = !0; function d2(e, t, n, r) { var i = me, o = vo.transition; vo.transition = null; try { me = 1, Hh(e, t, n, r) } finally { me = i, vo.transition = o } } function h2(e, t, n, r) { var i = me, o = vo.transition; vo.transition = null; try { me = 4, Hh(e, t, n, r) } finally { me = i, vo.transition = o } } function Hh(e, t, n, r) { if (rc) { var i = oh(e, t, n, r); if (i === null) Fd(e, t, r, ic, n), C0(e, r); else if (u2(i, e, t, n, r)) r.stopPropagation(); else if (C0(e, r), 4 & t && -1 < c2.indexOf(e)) { for (; i !== null;) { var o = na(i); if (o !== null && Xb(o), o = oh(e, t, n, r), o === null && Fd(e, t, r, ic, n), o === i) break; i = o } i !== null && r.stopPropagation() } else Fd(e, t, r, null, n) } } var ic = null; function oh(e, t, n, r) { if (ic = null, e = Bh(r), e = pi(e), e !== null) if (t = Ti(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Bb(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return ic = e, null } function Qb(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (e2()) { case $h: return 1; case Hb: return 4; case tc: case t2: return 16; case jb: return 536870912; default: return 16 }default: return 16 } } var _r = null, jh = null, jl = null; function Zb() { if (jl) return jl; var e, t, n = jh, r = n.length, i = "value" in _r ? _r.value : _r.textContent, o = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var s = r - e; for (t = 1; t <= s && n[r - t] === i[o - t]; t++); return jl = i.slice(e, 1 < t ? 1 - t : void 0) } function Wl(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function _l() { return !0 } function E0() { return !1 } function Yt(e) { function t(n, r, i, o, s) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(o) : o[a]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? _l : E0, this.isPropagationStopped = E0, this } return Fe(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = _l) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = _l) }, persist: function () { }, isPersistent: _l }), t } var Cd, Td, bs, Eo = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Wh = Yt(Eo), ta = Fe({}, Eo, { view: 0, detail: 0 }), p2 = Yt(ta), kc = Fe({}, ta, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Uh, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== bs && (bs && e.type === "mousemove" ? (Cd = e.screenX - bs.screenX, Td = e.screenY - bs.screenY) : Td = Cd = 0, bs = e), Cd) }, movementY: function (e) { return "movementY" in e ? e.movementY : Td } }), R0 = Yt(kc), m2 = Fe({}, kc, { dataTransfer: 0 }), v2 = Yt(m2), g2 = Fe({}, ta, { relatedTarget: 0 }), Ed = Yt(g2), y2 = Fe({}, Eo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), b2 = Yt(y2), x2 = Fe({}, Eo, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), S2 = Yt(x2), w2 = Fe({}, Eo, { data: 0 }), P0 = Yt(w2), k2 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, C2 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, T2 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function E2(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = T2[e]) && !!t[e] } function Uh() { return E2 } var R2 = Fe({}, ta, { key: function (e) { if (e.key) { var t = k2[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = Wl(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? C2[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Uh, charCode: function (e) { return e.type === "keypress" ? Wl(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Wl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), P2 = Yt(R2), _2 = Fe({}, kc, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), _0 = Yt(_2), F2 = Fe({}, ta, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Uh }), I2 = Yt(F2), L2 = Fe({}, Eo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), M2 = Yt(L2), O2 = Fe({}, kc, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), D2 = Yt(O2), A2 = [9, 13, 27, 32], Xh = ar && "CompositionEvent" in window, Fs = null; ar && "documentMode" in document && (Fs = document.documentMode); var V2 = ar && "TextEvent" in window && !Fs, Jb = ar && (!Xh || Fs && 8 < Fs && 11 >= Fs), F0 = String.fromCharCode(32), I0 = !1; function ex(e, t) { switch (e) { case "keyup": return A2.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function tx(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var no = !1; function B2(e, t) { switch (e) { case "compositionend": return tx(t); case "keypress": return t.which !== 32 ? null : (I0 = !0, F0); case "textInput": return e = t.data, e === F0 && I0 ? null : e; default: return null } } function $2(e, t) { if (no) return e === "compositionend" || !Xh && ex(e, t) ? (e = Zb(), jl = jh = _r = null, no = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return Jb && t.locale !== "ko" ? null : t.data; default: return null } } var z2 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function L0(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!z2[e.type] : t === "textarea" } function nx(e, t, n, r) { Mb(r), t = oc(t, "onChange"), 0 < t.length && (n = new Wh("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Is = null, js = null; function N2(e) { hx(e, 0) } function Cc(e) { var t = oo(e); if (Eb(t)) return e } function H2(e, t) { if (e === "change") return t } var rx = !1; ar && (ar ? (Il = "oninput" in document, Il || (Rd = document.createElement("div"), Rd.setAttribute("oninput", "return;"), Il = typeof Rd.oninput == "function"), Fl = Il) : Fl = !1, rx = Fl && (!document.documentMode || 9 < document.documentMode)); var Fl, Il, Rd; function M0() { Is && (Is.detachEvent("onpropertychange", ix), js = Is = null) } function ix(e) { if (e.propertyName === "value" && Cc(js)) { var t = []; nx(t, js, e, Bh(e)), Vb(N2, t) } } function j2(e, t, n) { e === "focusin" ? (M0(), Is = t, js = n, Is.attachEvent("onpropertychange", ix)) : e === "focusout" && M0() } function W2(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Cc(js) } function U2(e, t) { if (e === "click") return Cc(t) } function X2(e, t) { if (e === "input" || e === "change") return Cc(t) } function Y2(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Cn = typeof Object.is == "function" ? Object.is : Y2; function Ws(e, t) { if (Cn(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!Nd.call(t, i) || !Cn(e[i], t[i])) return !1 } return !0 } function O0(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function D0(e, t) { var n = O0(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = O0(n) } } function ox(e, t) { return !(!e || !t) && (e === t || (!e || e.nodeType !== 3) && (t && t.nodeType === 3 ? ox(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function sx() { for (var e = window, t = Zl(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (!n) break; e = t.contentWindow, t = Zl(e.document) } return t } function Yh(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function G2(e) { var t = sx(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && ox(n.ownerDocument.documentElement, n)) { if (r !== null && Yh(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = r.end === void 0 ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = D0(n, o); var s = D0(n, r); i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var K2 = ar && "documentMode" in document && 11 >= document.documentMode, ro = null, sh = null, Ls = null, ah = !1; function A0(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; ah || ro == null || ro !== Zl(r) || (r = ro, "selectionStart" in r && Yh(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Ls && Ws(Ls, r) || (Ls = r, r = oc(sh, "onSelect"), 0 < r.length && (t = new Wh("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = ro))) } function Ll(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var io = { animationend: Ll("Animation", "AnimationEnd"), animationiteration: Ll("Animation", "AnimationIteration"), animationstart: Ll("Animation", "AnimationStart"), transitionend: Ll("Transition", "TransitionEnd") }, Pd = {}, ax = {}; ar && (ax = document.createElement("div").style, "AnimationEvent" in window || (delete io.animationend.animation, delete io.animationiteration.animation, delete io.animationstart.animation), "TransitionEvent" in window || delete io.transitionend.transition); function Tc(e) { if (Pd[e]) return Pd[e]; if (!io[e]) return e; var t, n = io[e]; for (t in n) if (n.hasOwnProperty(t) && t in ax) return Pd[e] = n[t]; return e } var lx = Tc("animationend"), cx = Tc("animationiteration"), ux = Tc("animationstart"), fx = Tc("transitionend"), dx = new Map, V0 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Nr(e, t) { dx.set(e, t), Ci(t, [e]) } for (Ml = 0; Ml < V0.length; Ml++)Ol = V0[Ml], B0 = Ol.toLowerCase(), $0 = Ol[0].toUpperCase() + Ol.slice(1), Nr(B0, "on" + $0); var Ol, B0, $0, Ml; Nr(lx, "onAnimationEnd"); Nr(cx, "onAnimationIteration"); Nr(ux, "onAnimationStart"); Nr("dblclick", "onDoubleClick"); Nr("focusin", "onFocus"); Nr("focusout", "onBlur"); Nr(fx, "onTransitionEnd"); bo("onMouseEnter", ["mouseout", "mouseover"]); bo("onMouseLeave", ["mouseout", "mouseover"]); bo("onPointerEnter", ["pointerout", "pointerover"]); bo("onPointerLeave", ["pointerout", "pointerover"]); Ci("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Ci("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Ci("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Ci("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Ci("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Ci("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Rs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), q2 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Rs)); function z0(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, q_(r, t, void 0, e), e.currentTarget = null } function hx(e, t) { t = (4 & t) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var s = r.length - 1; 0 <= s; s--) { var a = r[s], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== o && i.isPropagationStopped()) break e; z0(i, a, c), o = l } else for (s = 0; s < r.length; s++) { if (a = r[s], l = a.instance, c = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped()) break e; z0(i, a, c), o = l } } } if (ec) throw e = nh, ec = !1, nh = null, e } function Se(e, t) { var n = t[dh]; n === void 0 && (n = t[dh] = new Set); var r = e + "__bubble"; n.has(r) || (px(t, e, 2, !1), n.add(r)) } function _d(e, t, n) { var r = 0; t && (r |= 4), px(n, e, r, t) } var Dl = "_reactListening" + Math.random().toString(36).slice(2); function Us(e) { if (!e[Dl]) { e[Dl] = !0, Sb.forEach(function (n) { n !== "selectionchange" && (q2.has(n) || _d(n, !1, e), _d(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[Dl] || (t[Dl] = !0, _d("selectionchange", !1, t)) } } function px(e, t, n, r) { switch (Qb(t)) { case 1: var i = d2; break; case 4: i = h2; break; default: i = Hh }n = i.bind(null, t, n, e), i = void 0, !th || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Fd(e, t, n, r, i) { var o = r; if (!(1 & t) && !(2 & t) && r !== null) e: for (; ;) { if (r === null) return; var s = r.tag; if (s === 3 || s === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (s === 4) for (s = r.return; s !== null;) { var l = s.tag; if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; s = s.return } for (; a !== null;) { if (s = pi(a), s === null) return; if (l = s.tag, l === 5 || l === 6) { r = o = s; continue e } a = a.parentNode } } r = r.return } Vb(function () { var c = o, u = Bh(n), f = []; e: { var d = dx.get(e); if (d !== void 0) { var p = Wh, g = e; switch (e) { case "keypress": if (Wl(n) === 0) break e; case "keydown": case "keyup": p = P2; break; case "focusin": g = "focus", p = Ed; break; case "focusout": g = "blur", p = Ed; break; case "beforeblur": case "afterblur": p = Ed; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": p = R0; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": p = v2; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": p = I2; break; case lx: case cx: case ux: p = b2; break; case fx: p = M2; break; case "scroll": p = p2; break; case "wheel": p = D2; break; case "copy": case "cut": case "paste": p = S2; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": p = _0 }var v = (4 & t) !== 0, S = !v && e === "scroll", m = v ? d !== null ? d + "Capture" : null : d; v = []; for (var h, y = c; y !== null;) { h = y; var x = h.stateNode; if (h.tag === 5 && x !== null && (h = x, m !== null && (x = $s(y, m), x != null && v.push(Xs(y, x, h)))), S) break; y = y.return } 0 < v.length && (d = new p(d, g, null, n, u), f.push({ event: d, listeners: v })) } } if (!(7 & t)) { if (d = e === "mouseover" || e === "pointerover", p = e === "mouseout" || e === "pointerout", (!d || n === Jd || !(g = n.relatedTarget || n.fromElement) || !pi(g) && !g[lr]) && (p || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : window, p ? (g = n.relatedTarget || n.toElement, p = c, g = g ? pi(g) : null, g !== null && (S = Ti(g), g !== S || g.tag !== 5 && g.tag !== 6) && (g = null)) : (p = null, g = c), p !== g)) { if (v = R0, x = "onMouseLeave", m = "onMouseEnter", y = "mouse", e !== "pointerout" && e !== "pointerover" || (v = _0, x = "onPointerLeave", m = "onPointerEnter", y = "pointer"), S = p == null ? d : oo(p), h = g == null ? d : oo(g), d = new v(x, y + "leave", p, n, u), d.target = S, d.relatedTarget = h, x = null, pi(u) === c && (v = new v(m, y + "enter", g, n, u), v.target = h, v.relatedTarget = S, x = v), S = x, p && g) e: { for (v = p, m = g, y = 0, h = v; h; h = Ji(h))y++; for (h = 0, x = m; x; x = Ji(x))h++; for (; 0 < y - h;)v = Ji(v), y--; for (; 0 < h - y;)m = Ji(m), h--; for (; y--;) { if (v === m || m !== null && v === m.alternate) break e; v = Ji(v), m = Ji(m) } v = null } else v = null; p !== null && N0(f, d, p, v, !1), g !== null && S !== null && N0(f, S, g, v, !0) } if (d = c ? oo(c) : window, p = d.nodeName && d.nodeName.toLowerCase(), p === "select" || p === "input" && d.type === "file") var k = H2; else if (L0(d)) if (rx) k = X2; else { k = W2; var w = j2 } else (p = d.nodeName) && p.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (k = U2); switch (k && (k = k(e, c)) ? nx(f, k, n, u) : (w && w(e, d, c), e === "focusout" && (w = d._wrapperState) && w.controlled && d.type === "number" && Gd(d, "number", d.value)), w = c ? oo(c) : window, e) { case "focusin": (L0(w) || w.contentEditable === "true") && (ro = w, sh = c, Ls = null); break; case "focusout": Ls = sh = ro = null; break; case "mousedown": ah = !0; break; case "contextmenu": case "mouseup": case "dragend": ah = !1, A0(f, n, u); break; case "selectionchange": if (K2) break; case "keydown": case "keyup": A0(f, n, u) }var T; if (Xh) e: { switch (e) { case "compositionstart": var E = "onCompositionStart"; break e; case "compositionend": E = "onCompositionEnd"; break e; case "compositionupdate": E = "onCompositionUpdate"; break e }E = void 0 } else no ? ex(e, n) && (E = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (E = "onCompositionStart"); E && (Jb && n.locale !== "ko" && (no || E !== "onCompositionStart" ? E === "onCompositionEnd" && no && (T = Zb()) : (_r = u, jh = "value" in _r ? _r.value : _r.textContent, no = !0)), w = oc(c, E), 0 < w.length && (E = new P0(E, e, null, n, u), f.push({ event: E, listeners: w }), T ? E.data = T : (T = tx(n), T !== null && (E.data = T)))), (T = V2 ? B2(e, n) : $2(e, n)) && (c = oc(c, "onBeforeInput"), 0 < c.length && (u = new P0("onBeforeInput", "beforeinput", null, n, u), f.push({ event: u, listeners: c }), u.data = T)) } hx(f, t) }) } function Xs(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function oc(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var i = e, o = i.stateNode; i.tag === 5 && o !== null && (i = o, o = $s(e, n), o != null && r.unshift(Xs(e, o, i)), o = $s(e, t), o != null && r.push(Xs(e, o, i))), e = e.return } return r } function Ji(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function N0(e, t, n, r, i) { for (var o = t._reactName, s = []; n !== null && n !== r;) { var a = n, l = a.alternate, c = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && c !== null && (a = c, i ? (l = $s(n, o), l != null && s.unshift(Xs(n, l, a))) : i || (l = $s(n, o), l != null && s.push(Xs(n, l, a)))), n = n.return } s.length !== 0 && e.push({ event: t, listeners: s }) } var Q2 = /\r\n?/g, Z2 = /\u0000|\uFFFD/g; function H0(e) {
    return (typeof e == "string" ? e : "" + e).replace(Q2, `
`).replace(Z2, "")
} function Al(e, t, n) { if (t = H0(t), H0(e) !== t && n) throw Error(L(425)) } function sc() { } var lh = null, ch = null; function uh(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var fh = typeof setTimeout == "function" ? setTimeout : void 0, J2 = typeof clearTimeout == "function" ? clearTimeout : void 0, j0 = typeof Promise == "function" ? Promise : void 0, eF = typeof queueMicrotask == "function" ? queueMicrotask : typeof j0 < "u" ? function (e) { return j0.resolve(null).then(e).catch(tF) } : fh; function tF(e) { setTimeout(function () { throw e }) } function Id(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { e.removeChild(i), Hs(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); Hs(t) } function Or(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function W0(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var Ro = Math.random().toString(36).slice(2), zn = "__reactFiber$" + Ro, Ys = "__reactProps$" + Ro, lr = "__reactContainer$" + Ro, dh = "__reactEvents$" + Ro, nF = "__reactListeners$" + Ro, rF = "__reactHandles$" + Ro; function pi(e) { var t = e[zn]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[lr] || n[zn]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = W0(e); e !== null;) { if (n = e[zn]) return n; e = W0(e) } return t } e = n, n = e.parentNode } return null } function na(e) { return e = e[zn] || e[lr], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function oo(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(L(33)) } function Ec(e) { return e[Ys] || null } var hh = [], so = -1; function Hr(e) { return { current: e } } function we(e) { 0 > so || (e.current = hh[so], hh[so] = null, so--) } function ye(e, t) { so++, hh[so] = e.current, e.current = t } var zr = {}, gt = Hr(zr), Ot = Hr(!1), bi = zr; function xo(e, t) { var n = e.type.contextTypes; if (!n) return zr; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, o = {}; for (i in n) o[i] = t[i]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o } function Dt(e) { return e = e.childContextTypes, e != null } function ac() { we(Ot), we(gt) } function U0(e, t, n) { if (gt.current !== zr) throw Error(L(168)); ye(gt, t), ye(Ot, n) } function mx(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in t)) throw Error(L(108, j_(e) || "Unknown", i)); return Fe({}, n, r) } function lc(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || zr, bi = gt.current, ye(gt, e), ye(Ot, Ot.current), !0 } function X0(e, t, n) { var r = e.stateNode; if (!r) throw Error(L(169)); n ? (e = mx(e, t, bi), r.__reactInternalMemoizedMergedChildContext = e, we(Ot), we(gt), ye(gt, e)) : we(Ot), ye(Ot, n) } var rr = null, Rc = !1, Ld = !1; function vx(e) { rr === null ? rr = [e] : rr.push(e) } function iF(e) { Rc = !0, vx(e) } function jr() { if (!Ld && rr !== null) { Ld = !0; var e = 0, t = me; try { var n = rr; for (me = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } rr = null, Rc = !1 } catch (i) { throw rr !== null && (rr = rr.slice(e + 1)), Nb($h, jr), i } finally { me = t, Ld = !1 } } return null } var ao = [], lo = 0, cc = null, uc = 0, sn = [], an = 0, xi = null, ir = 1, or = ""; function di(e, t) { ao[lo++] = uc, ao[lo++] = cc, cc = e, uc = t } function gx(e, t, n) { sn[an++] = ir, sn[an++] = or, sn[an++] = xi, xi = e; var r = ir; e = or; var i = 32 - wn(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - wn(t) + i; if (30 < o) { var s = i - i % 5; o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, ir = 1 << 32 - wn(t) + i | n << i | r, or = o + e } else ir = 1 << o | n << i | r, or = e } function Gh(e) { e.return !== null && (di(e, 1), gx(e, 1, 0)) } function Kh(e) { for (; e === cc;)cc = ao[--lo], ao[lo] = null, uc = ao[--lo], ao[lo] = null; for (; e === xi;)xi = sn[--an], sn[an] = null, or = sn[--an], sn[an] = null, ir = sn[--an], sn[an] = null } var Wt = null, jt = null, Re = !1, Sn = null; function yx(e, t) { var n = ln(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function Y0(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null && (e.stateNode = t, Wt = e, jt = Or(t.firstChild), !0); case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null && (e.stateNode = t, Wt = e, jt = null, !0); case 13: return t = t.nodeType !== 8 ? null : t, t !== null && (n = xi !== null ? { id: ir, overflow: or } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = ln(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, Wt = e, jt = null, !0); default: return !1 } } function ph(e) { return (1 & e.mode) !== 0 && (128 & e.flags) === 0 } function mh(e) { if (Re) { var t = jt; if (t) { var n = t; if (!Y0(e, t)) { if (ph(e)) throw Error(L(418)); t = Or(n.nextSibling); var r = Wt; t && Y0(e, t) ? yx(r, n) : (e.flags = -4097 & e.flags | 2, Re = !1, Wt = e) } } else { if (ph(e)) throw Error(L(418)); e.flags = -4097 & e.flags | 2, Re = !1, Wt = e } } } function G0(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; Wt = e } function Vl(e) { if (e !== Wt) return !1; if (!Re) return G0(e), Re = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !uh(e.type, e.memoizedProps)), t && (t = jt)) { if (ph(e)) throw bx(), Error(L(418)); for (; t;)yx(e, t), t = Or(t.nextSibling) } if (G0(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(L(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { jt = Or(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } jt = null } } else jt = Wt ? Or(e.stateNode.nextSibling) : null; return !0 } function bx() { for (var e = jt; e;)e = Or(e.nextSibling) } function So() { jt = Wt = null, Re = !1 } function qh(e) { Sn === null ? Sn = [e] : Sn.push(e) } var oF = fr.ReactCurrentBatchConfig; function bn(e, t) { if (e && e.defaultProps) { t = Fe({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } var fc = Hr(null), dc = null, co = null, Qh = null; function Zh() { Qh = co = dc = null } function Jh(e) { var t = fc.current; we(fc), e._currentValue = t } function vh(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function go(e, t) { dc = e, Qh = co = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Mt = !0), e.firstContext = null) } function un(e) { var t = e._currentValue; if (Qh !== e) if (e = { context: e, memoizedValue: t, next: null }, co === null) { if (dc === null) throw Error(L(308)); co = e, dc.dependencies = { lanes: 0, firstContext: e } } else co = co.next = e; return t } var mi = null; function ep(e) { mi === null ? mi = [e] : mi.push(e) } function xx(e, t, n, r) { var i = t.interleaved; return i === null ? (n.next = n, ep(t)) : (n.next = i.next, i.next = n), t.interleaved = n, cr(e, r) } function cr(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var Er = !1; function tp(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Sx(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function sr(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Dr(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, 2 & ce) { var i = r.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, cr(e, n) } return i = r.interleaved, i === null ? (t.next = t, ep(r)) : (t.next = i.next, i.next = t), r.interleaved = t, cr(e, n) } function Ul(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (4194240 & n) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, zh(e, n) } } function K0(e, t) { var n = e.updateQueue, r = e.alternate; if (r === null || (r = r.updateQueue, n !== r)) e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t; else { var i = null, o = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; o === null ? i = o = s : o = o.next = s, n = n.next } while (n !== null); o === null ? i = o = t : o = o.next = t } else i = o = t; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, e.updateQueue = n } } function hc(e, t, n, r) { var i = e.updateQueue; Er = !1; var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a, c = l.next; l.next = null, s === null ? o = c : s.next = c, s = l; var u = e.alternate; u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l)) } if (o !== null) { var f = i.baseState; s = 0, u = c = l = null, a = o; do { var d = a.lane, p = a.eventTime; if ((r & d) === d) { u !== null && (u = u.next = { eventTime: p, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var g = e, v = a; switch (d = t, p = n, v.tag) { case 1: if (g = v.payload, typeof g == "function") { f = g.call(p, f, d); break e } f = g; break e; case 3: g.flags = -65537 & g.flags | 128; case 0: if (g = v.payload, d = typeof g == "function" ? g.call(p, f, d) : g, d == null) break e; f = Fe({}, f, d); break e; case 2: Er = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, d = i.effects, d === null ? i.effects = [a] : d.push(a)) } else p = { eventTime: p, lane: d, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, u === null ? (c = u = p, l = f) : u = u.next = p, s |= d; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; d = a, a = d.next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null } } while (1); if (u === null && (l = f), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, t = i.shared.interleaved, t !== null) { i = t; do s |= i.lane, i = i.next; while (i !== t) } else o === null && (i.shared.lanes = 0); wi |= s, e.lanes = s, e.memoizedState = f } } function q0(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(L(191, i)); i.call(r) } } } var wx = new xb.Component().refs; function gh(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : Fe({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var Pc = { isMounted: function (e) { return !!(e = e._reactInternals) && Ti(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = kt(), i = Vr(e), o = sr(r, i); o.payload = t, n != null && (o.callback = n), t = Dr(e, o, i), t !== null && (kn(t, e, i, r), Ul(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = kt(), i = Vr(e), o = sr(r, i); o.tag = 1, o.payload = t, n != null && (o.callback = n), t = Dr(e, o, i), t !== null && (kn(t, e, i, r), Ul(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = kt(), r = Vr(e), i = sr(n, r); i.tag = 2, t != null && (i.callback = t), t = Dr(e, i, r), t !== null && (kn(t, e, r, n), Ul(t, e, r)) } }; function Q0(e, t, n, r, i, o, s) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, s) : !t.prototype || !t.prototype.isPureReactComponent || !Ws(n, r) || !Ws(i, o) } function kx(e, t, n) { var r = !1, i = zr, o = t.contextType; return typeof o == "object" && o !== null ? o = un(o) : (i = Dt(t) ? bi : gt.current, r = t.contextTypes, o = (r = r != null) ? xo(e, i) : zr), t = new t(n, o), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Pc, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function Z0(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Pc.enqueueReplaceState(t, t.state, null) } function yh(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = wx, tp(e); var o = t.contextType; typeof o == "object" && o !== null ? i.context = un(o) : (o = Dt(t) ? bi : gt.current, i.context = xo(e, o)), i.state = e.memoizedState, o = t.getDerivedStateFromProps, typeof o == "function" && (gh(e, t, o, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && Pc.enqueueReplaceState(i, i.state, null), hc(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308) } function xs(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(L(309)); var r = n.stateNode } if (!r) throw Error(L(147, e)); var i = r, o = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function (s) { var a = i.refs; a === wx && (a = i.refs = {}), s === null ? delete a[o] : a[o] = s }, t._stringRef = o, t) } if (typeof e != "string") throw Error(L(284)); if (!n._owner) throw Error(L(290, e)) } return e } function Bl(e, t) { throw e = Object.prototype.toString.call(t), Error(L(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function J0(e) { var t = e._init; return t(e._payload) } function Cx(e) { function t(m, h) { if (e) { var y = m.deletions; y === null ? (m.deletions = [h], m.flags |= 16) : y.push(h) } } function n(m, h) { if (!e) return null; for (; h !== null;)t(m, h), h = h.sibling; return null } function r(m, h) { for (m = new Map; h !== null;)h.key !== null ? m.set(h.key, h) : m.set(h.index, h), h = h.sibling; return m } function i(m, h) { return m = Br(m, h), m.index = 0, m.sibling = null, m } function o(m, h, y) { return m.index = y, e ? (y = m.alternate, y !== null ? (y = y.index, y < h ? (m.flags |= 2, h) : y) : (m.flags |= 2, h)) : (m.flags |= 1048576, h) } function s(m) { return e && m.alternate === null && (m.flags |= 2), m } function a(m, h, y, x) { return h === null || h.tag !== 6 ? (h = $d(y, m.mode, x), h.return = m, h) : (h = i(h, y), h.return = m, h) } function l(m, h, y, x) { var k = y.type; return k === to ? u(m, h, y.props.children, x, y.key) : h !== null && (h.elementType === k || typeof k == "object" && k !== null && k.$$typeof === Tr && J0(k) === h.type) ? (x = i(h, y.props), x.ref = xs(m, h, y), x.return = m, x) : (x = Ql(y.type, y.key, y.props, null, m.mode, x), x.ref = xs(m, h, y), x.return = m, x) } function c(m, h, y, x) { return h === null || h.tag !== 4 || h.stateNode.containerInfo !== y.containerInfo || h.stateNode.implementation !== y.implementation ? (h = zd(y, m.mode, x), h.return = m, h) : (h = i(h, y.children || []), h.return = m, h) } function u(m, h, y, x, k) { return h === null || h.tag !== 7 ? (h = yi(y, m.mode, x, k), h.return = m, h) : (h = i(h, y), h.return = m, h) } function f(m, h, y) { if (typeof h == "string" && h !== "" || typeof h == "number") return h = $d("" + h, m.mode, y), h.return = m, h; if (typeof h == "object" && h !== null) { switch (h.$$typeof) { case kl: return y = Ql(h.type, h.key, h.props, null, m.mode, y), y.ref = xs(m, null, h), y.return = m, y; case eo: return h = zd(h, m.mode, y), h.return = m, h; case Tr: var x = h._init; return f(m, x(h._payload), y) }if (Ts(h) || vs(h)) return h = yi(h, m.mode, y, null), h.return = m, h; Bl(m, h) } return null } function d(m, h, y, x) { var k = h !== null ? h.key : null; if (typeof y == "string" && y !== "" || typeof y == "number") return k !== null ? null : a(m, h, "" + y, x); if (typeof y == "object" && y !== null) { switch (y.$$typeof) { case kl: return y.key === k ? l(m, h, y, x) : null; case eo: return y.key === k ? c(m, h, y, x) : null; case Tr: return k = y._init, d(m, h, k(y._payload), x) }if (Ts(y) || vs(y)) return k !== null ? null : u(m, h, y, x, null); Bl(m, y) } return null } function p(m, h, y, x, k) { if (typeof x == "string" && x !== "" || typeof x == "number") return m = m.get(y) || null, a(h, m, "" + x, k); if (typeof x == "object" && x !== null) { switch (x.$$typeof) { case kl: return m = m.get(x.key === null ? y : x.key) || null, l(h, m, x, k); case eo: return m = m.get(x.key === null ? y : x.key) || null, c(h, m, x, k); case Tr: var w = x._init; return p(m, h, y, w(x._payload), k) }if (Ts(x) || vs(x)) return m = m.get(y) || null, u(h, m, x, k, null); Bl(h, x) } return null } function g(m, h, y, x) { for (var k = null, w = null, T = h, E = h = 0, I = null; T !== null && E < y.length; E++) { T.index > E ? (I = T, T = null) : I = T.sibling; var F = d(m, T, y[E], x); if (F === null) { T === null && (T = I); break } e && T && F.alternate === null && t(m, T), h = o(F, h, E), w === null ? k = F : w.sibling = F, w = F, T = I } if (E === y.length) return n(m, T), Re && di(m, E), k; if (T === null) { for (; E < y.length; E++)T = f(m, y[E], x), T !== null && (h = o(T, h, E), w === null ? k = T : w.sibling = T, w = T); return Re && di(m, E), k } for (T = r(m, T); E < y.length; E++)I = p(T, m, E, y[E], x), I !== null && (e && I.alternate !== null && T.delete(I.key === null ? E : I.key), h = o(I, h, E), w === null ? k = I : w.sibling = I, w = I); return e && T.forEach(function (B) { return t(m, B) }), Re && di(m, E), k } function v(m, h, y, x) { var k = vs(y); if (typeof k != "function") throw Error(L(150)); if (y = k.call(y), y == null) throw Error(L(151)); for (var w = k = null, T = h, E = h = 0, I = null, F = y.next(); T !== null && !F.done; E++, F = y.next()) { T.index > E ? (I = T, T = null) : I = T.sibling; var B = d(m, T, F.value, x); if (B === null) { T === null && (T = I); break } e && T && B.alternate === null && t(m, T), h = o(B, h, E), w === null ? k = B : w.sibling = B, w = B, T = I } if (F.done) return n(m, T), Re && di(m, E), k; if (T === null) { for (; !F.done; E++, F = y.next())F = f(m, F.value, x), F !== null && (h = o(F, h, E), w === null ? k = F : w.sibling = F, w = F); return Re && di(m, E), k } for (T = r(m, T); !F.done; E++, F = y.next())F = p(T, m, E, F.value, x), F !== null && (e && F.alternate !== null && T.delete(F.key === null ? E : F.key), h = o(F, h, E), w === null ? k = F : w.sibling = F, w = F); return e && T.forEach(function (V) { return t(m, V) }), Re && di(m, E), k } function S(m, h, y, x) { if (typeof y == "object" && y !== null && y.type === to && y.key === null && (y = y.props.children), typeof y == "object" && y !== null) { switch (y.$$typeof) { case kl: e: { for (var k = y.key, w = h; w !== null;) { if (w.key === k) { if (k = y.type, k === to) { if (w.tag === 7) { n(m, w.sibling), h = i(w, y.props.children), h.return = m, m = h; break e } } else if (w.elementType === k || typeof k == "object" && k !== null && k.$$typeof === Tr && J0(k) === w.type) { n(m, w.sibling), h = i(w, y.props), h.ref = xs(m, w, y), h.return = m, m = h; break e } n(m, w); break } t(m, w), w = w.sibling } y.type === to ? (h = yi(y.props.children, m.mode, x, y.key), h.return = m, m = h) : (x = Ql(y.type, y.key, y.props, null, m.mode, x), x.ref = xs(m, h, y), x.return = m, m = x) } return s(m); case eo: e: { for (w = y.key; h !== null;) { if (h.key === w) { if (h.tag === 4 && h.stateNode.containerInfo === y.containerInfo && h.stateNode.implementation === y.implementation) { n(m, h.sibling), h = i(h, y.children || []), h.return = m, m = h; break e } n(m, h); break } t(m, h), h = h.sibling } h = zd(y, m.mode, x), h.return = m, m = h } return s(m); case Tr: return w = y._init, S(m, h, w(y._payload), x) }if (Ts(y)) return g(m, h, y, x); if (vs(y)) return v(m, h, y, x); Bl(m, y) } return typeof y == "string" && y !== "" || typeof y == "number" ? (y = "" + y, h !== null && h.tag === 6 ? (n(m, h.sibling), h = i(h, y), h.return = m, m = h) : (n(m, h), h = $d(y, m.mode, x), h.return = m, m = h), s(m)) : n(m, h) } return S } var wo = Cx(!0), Tx = Cx(!1), ra = {}, Hn = Hr(ra), Gs = Hr(ra), Ks = Hr(ra); function vi(e) { if (e === ra) throw Error(L(174)); return e } function np(e, t) { switch (ye(Ks, t), ye(Gs, e), ye(Hn, ra), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : qd(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = qd(t, e) }we(Hn), ye(Hn, t) } function ko() { we(Hn), we(Gs), we(Ks) } function Ex(e) { vi(Ks.current); var t = vi(Hn.current), n = qd(t, e.type); t !== n && (ye(Gs, e), ye(Hn, n)) } function rp(e) { Gs.current === e && (we(Hn), we(Gs)) } var Pe = Hr(0); function pc(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (128 & t.flags) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var Md = []; function ip() { for (var e = 0; e < Md.length; e++)Md[e]._workInProgressVersionPrimary = null; Md.length = 0 } var Xl = fr.ReactCurrentDispatcher, Od = fr.ReactCurrentBatchConfig, Si = 0, _e = null, Xe = null, qe = null, mc = !1, Ms = !1, qs = 0, sF = 0; function pt() { throw Error(L(321)) } function op(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!Cn(e[n], t[n])) return !1; return !0 } function sp(e, t, n, r, i, o) { if (Si = o, _e = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Xl.current = e === null || e.memoizedState === null ? uF : fF, e = n(r, i), Ms) { o = 0; do { if (Ms = !1, qs = 0, 25 <= o) throw Error(L(301)); o += 1, qe = Xe = null, t.updateQueue = null, Xl.current = dF, e = n(r, i) } while (Ms) } if (Xl.current = vc, t = Xe !== null && Xe.next !== null, Si = 0, qe = Xe = _e = null, mc = !1, t) throw Error(L(300)); return e } function ap() { var e = qs !== 0; return qs = 0, e } function $n() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return qe === null ? _e.memoizedState = qe = e : qe = qe.next = e, qe } function fn() { if (Xe === null) { var e = _e.alternate; e = e !== null ? e.memoizedState : null } else e = Xe.next; var t = qe === null ? _e.memoizedState : qe.next; if (t !== null) qe = t, Xe = e; else { if (e === null) throw Error(L(310)); Xe = e, e = { memoizedState: Xe.memoizedState, baseState: Xe.baseState, baseQueue: Xe.baseQueue, queue: Xe.queue, next: null }, qe === null ? _e.memoizedState = qe = e : qe = qe.next = e } return qe } function Qs(e, t) { return typeof t == "function" ? t(e) : t } function Dd(e) { var t = fn(), n = t.queue; if (n === null) throw Error(L(311)); n.lastRenderedReducer = e; var r = Xe, i = r.baseQueue, o = n.pending; if (o !== null) { if (i !== null) { var s = i.next; i.next = o.next, o.next = s } r.baseQueue = i = o, n.pending = null } if (i !== null) { o = i.next, r = r.baseState; var a = s = null, l = null, c = o; do { var u = c.lane; if ((Si & u) === u) l !== null && (l = l.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), r = c.hasEagerState ? c.eagerState : e(r, c.action); else { var f = { lane: u, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; l === null ? (a = l = f, s = r) : l = l.next = f, _e.lanes |= u, wi |= u } c = c.next } while (c !== null && c !== o); l === null ? s = r : l.next = a, Cn(r, t.memoizedState) || (Mt = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { i = e; do o = i.lane, _e.lanes |= o, wi |= o, i = i.next; while (i !== e) } else i === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Ad(e) { var t = fn(), n = t.queue; if (n === null) throw Error(L(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (i !== null) { n.pending = null; var s = i = i.next; do o = e(o, s.action), s = s.next; while (s !== i); Cn(o, t.memoizedState) || (Mt = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function Rx() { } function Px(e, t) { var n = _e, r = fn(), i = t(), o = !Cn(r.memoizedState, i); if (o && (r.memoizedState = i, Mt = !0), r = r.queue, lp(Ix.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || qe !== null && 1 & qe.memoizedState.tag) { if (n.flags |= 2048, Zs(9, Fx.bind(null, n, r, i, t), void 0, null), Qe === null) throw Error(L(349)); 30 & Si || _x(n, t, i) } return i } function _x(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = _e.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, _e.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function Fx(e, t, n, r) { t.value = n, t.getSnapshot = r, Lx(t) && Mx(e) } function Ix(e, t, n) { return n(function () { Lx(t) && Mx(e) }) } function Lx(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Cn(e, n) } catch { return !0 } } function Mx(e) { var t = cr(e, 1); t !== null && kn(t, e, 1, -1) } function eb(e) { var t = $n(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Qs, lastRenderedState: e }, t.queue = e, e = e.dispatch = cF.bind(null, _e, e), [t.memoizedState, e] } function Zs(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = _e.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, _e.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function Ox() { return fn().memoizedState } function Yl(e, t, n, r) { var i = $n(); _e.flags |= e, i.memoizedState = Zs(1 | t, n, void 0, r === void 0 ? null : r) } function _c(e, t, n, r) { var i = fn(); r = r === void 0 ? null : r; var o = void 0; if (Xe !== null) { var s = Xe.memoizedState; if (o = s.destroy, r !== null && op(r, s.deps)) { i.memoizedState = Zs(t, n, o, r); return } } _e.flags |= e, i.memoizedState = Zs(1 | t, n, o, r) } function tb(e, t) { return Yl(8390656, 8, e, t) } function lp(e, t) { return _c(2048, 8, e, t) } function Dx(e, t) { return _c(4, 2, e, t) } function Ax(e, t) { return _c(4, 4, e, t) } function Vx(e, t) { return typeof t == "function" ? (e = e(), t(e), function () { t(null) }) : t != null ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Bx(e, t, n) { return n = n != null ? n.concat([e]) : null, _c(4, 4, Vx.bind(null, t, e), n) } function cp() { } function $x(e, t) { var n = fn(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && op(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function zx(e, t) { var n = fn(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && op(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Nx(e, t, n) { return 21 & Si ? (Cn(n, t) || (n = Wb(), _e.lanes |= n, wi |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Mt = !0), e.memoizedState = n) } function aF(e, t) { var n = me; me = n !== 0 && 4 > n ? n : 4, e(!0); var r = Od.transition; Od.transition = {}; try { e(!1), t() } finally { me = n, Od.transition = r } } function Hx() { return fn().memoizedState } function lF(e, t, n) { var r = Vr(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, jx(e)) Wx(t, n); else if (n = xx(e, t, n, r), n !== null) { var i = kt(); kn(n, e, r, i), Ux(n, t, r) } } function cF(e, t, n) { var r = Vr(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (jx(e)) Wx(t, i); else { var o = e.alternate; if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try { var s = t.lastRenderedState, a = o(s, n); if (i.hasEagerState = !0, i.eagerState = a, Cn(a, s)) { var l = t.interleaved; l === null ? (i.next = i, ep(t)) : (i.next = l.next, l.next = i), t.interleaved = i; return } } catch { } n = xx(e, t, i, r), n !== null && (i = kt(), kn(n, e, r, i), Ux(n, t, r)) } } function jx(e) { var t = e.alternate; return e === _e || t !== null && t === _e } function Wx(e, t) { Ms = mc = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function Ux(e, t, n) { if (4194240 & n) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, zh(e, n) } } var vc = { readContext: un, useCallback: pt, useContext: pt, useEffect: pt, useImperativeHandle: pt, useInsertionEffect: pt, useLayoutEffect: pt, useMemo: pt, useReducer: pt, useRef: pt, useState: pt, useDebugValue: pt, useDeferredValue: pt, useTransition: pt, useMutableSource: pt, useSyncExternalStore: pt, useId: pt, unstable_isNewReconciler: !1 }, uF = { readContext: un, useCallback: function (e, t) { return $n().memoizedState = [e, t === void 0 ? null : t], e }, useContext: un, useEffect: tb, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, Yl(4194308, 4, Vx.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Yl(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Yl(4, 2, e, t) }, useMemo: function (e, t) { var n = $n(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = $n(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = lF.bind(null, _e, e), [r.memoizedState, e] }, useRef: function (e) { var t = $n(); return e = { current: e }, t.memoizedState = e }, useState: eb, useDebugValue: cp, useDeferredValue: function (e) { return $n().memoizedState = e }, useTransition: function () { var e = eb(!1), t = e[0]; return e = aF.bind(null, e[1]), $n().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = _e, i = $n(); if (Re) { if (n === void 0) throw Error(L(407)); n = n() } else { if (n = t(), Qe === null) throw Error(L(349)); 30 & Si || _x(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, tb(Ix.bind(null, r, o, e), [e]), r.flags |= 2048, Zs(9, Fx.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = $n(), t = Qe.identifierPrefix; if (Re) { var n = or, r = ir; n = (r & ~(1 << 32 - wn(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = qs++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = sF++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, fF = { readContext: un, useCallback: $x, useContext: un, useEffect: lp, useImperativeHandle: Bx, useInsertionEffect: Dx, useLayoutEffect: Ax, useMemo: zx, useReducer: Dd, useRef: Ox, useState: function () { return Dd(Qs) }, useDebugValue: cp, useDeferredValue: function (e) { var t = fn(); return Nx(t, Xe.memoizedState, e) }, useTransition: function () { var e = Dd(Qs)[0], t = fn().memoizedState; return [e, t] }, useMutableSource: Rx, useSyncExternalStore: Px, useId: Hx, unstable_isNewReconciler: !1 }, dF = { readContext: un, useCallback: $x, useContext: un, useEffect: lp, useImperativeHandle: Bx, useInsertionEffect: Dx, useLayoutEffect: Ax, useMemo: zx, useReducer: Ad, useRef: Ox, useState: function () { return Ad(Qs) }, useDebugValue: cp, useDeferredValue: function (e) { var t = fn(); return Xe === null ? t.memoizedState = e : Nx(t, Xe.memoizedState, e) }, useTransition: function () { var e = Ad(Qs)[0], t = fn().memoizedState; return [e, t] }, useMutableSource: Rx, useSyncExternalStore: Px, useId: Hx, unstable_isNewReconciler: !1 }; function Co(e, t) {
    try { var n = "", r = t; do n += H_(r), r = r.return; while (r); var i = n } catch (o) {
        i = `
Error generating stack: `+ o.message + `
`+ o.stack
    } return { value: e, source: t, stack: i, digest: null }
} function Vd(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function bh(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var hF = typeof WeakMap == "function" ? WeakMap : Map; function Xx(e, t, n) { n = sr(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { yc || (yc = !0, Ph = r), bh(e, t) }, n } function Yx(e, t, n) { n = sr(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { bh(e, t) } } var o = e.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () { bh(e, t), typeof r != "function" && (Ar === null ? Ar = new Set([this]) : Ar.add(this)); var s = t.stack; this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" }) }), n } function nb(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new hF; var i = new Set; r.set(t, i) } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = RF.bind(null, e, t, n), t.then(e, e)) } function rb(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t === null || t.dehydrated !== null), t) return e; e = e.return } while (e !== null); return null } function ib(e, t, n, r, i) { return 1 & e.mode ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = sr(-1, 1), t.tag = 2, Dr(n, t, 1))), n.lanes |= 1), e) } var pF = fr.ReactCurrentOwner, Mt = !1; function wt(e, t, n, r) { t.child = e === null ? Tx(t, null, n, r) : wo(t, e.child, n, r) } function ob(e, t, n, r, i) { n = n.render; var o = t.ref; return go(t, i), r = sp(e, t, n, r, o, i), n = ap(), e !== null && !Mt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, ur(e, t, i)) : (Re && n && Gh(t), t.flags |= 1, wt(e, t, r, i), t.child) } function sb(e, t, n, r, i) { if (e === null) { var o = n.type; return typeof o == "function" && !gp(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = o, Gx(e, t, o, r, i)) : (e = Ql(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e) } if (o = e.child, !(e.lanes & i)) { var s = o.memoizedProps; if (n = n.compare, n = n !== null ? n : Ws, n(s, r) && e.ref === t.ref) return ur(e, t, i) } return t.flags |= 1, e = Br(o, r), e.ref = t.ref, e.return = t, t.child = e } function Gx(e, t, n, r, i) { if (e !== null) { var o = e.memoizedProps; if (Ws(o, r) && e.ref === t.ref) { if (Mt = !1, t.pendingProps = r = o, (e.lanes & i) === 0) return t.lanes = e.lanes, ur(e, t, i); 131072 & e.flags && (Mt = !0) } } return xh(e, t, n, r, i) } function Kx(e, t, n) { var r = t.pendingProps, i = r.children, o = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ye(fo, Ht), Ht |= n; else { if (!(1073741824 & n)) return e = o !== null ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, ye(fo, Ht), Ht |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = o !== null ? o.baseLanes : n, ye(fo, Ht), Ht |= r } else o !== null ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, ye(fo, Ht), Ht |= r; return wt(e, t, i, n), t.child } function qx(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function xh(e, t, n, r, i) { var o = Dt(n) ? bi : gt.current; return o = xo(t, o), go(t, i), n = sp(e, t, n, r, o, i), r = ap(), e !== null && !Mt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, ur(e, t, i)) : (Re && r && Gh(t), t.flags |= 1, wt(e, t, n, i), t.child) } function ab(e, t, n, r, i) { if (Dt(n)) { var o = !0; lc(t) } else o = !1; if (go(t, i), t.stateNode === null) Gl(e, t), kx(t, n, r), yh(t, n, r, i), r = !0; else if (e === null) { var s = t.stateNode, a = t.memoizedProps; s.props = a; var l = s.context, c = n.contextType; typeof c == "object" && c !== null ? c = un(c) : (c = Dt(n) ? bi : gt.current, c = xo(t, c)); var u = n.getDerivedStateFromProps, f = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function"; f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== c) && Z0(t, s, r, c), Er = !1; var d = t.memoizedState; s.state = d, hc(t, r, s, i), l = t.memoizedState, a !== r || d !== l || Ot.current || Er ? (typeof u == "function" && (gh(t, n, u, r), l = t.memoizedState), (a = Er || Q0(t, n, a, r, d, l, c)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), s.props = r, s.state = l, s.context = c, r = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, Sx(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : bn(t.type, a), s.props = c, f = t.pendingProps, d = s.context, l = n.contextType, typeof l == "object" && l !== null ? l = un(l) : (l = Dt(n) ? bi : gt.current, l = xo(t, l)); var p = n.getDerivedStateFromProps; (u = typeof p == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== f || d !== l) && Z0(t, s, r, l), Er = !1, d = t.memoizedState, s.state = d, hc(t, r, s, i); var g = t.memoizedState; a !== f || d !== g || Ot.current || Er ? (typeof p == "function" && (gh(t, n, p, r), g = t.memoizedState), (c = Er || Q0(t, n, c, r, d, g, l) || !1) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, g, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, g, l)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = g), s.props = r, s.state = g, s.context = l, r = c) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1) } return Sh(e, t, n, r, o, i) } function Sh(e, t, n, r, i, o) { qx(e, t); var s = (128 & t.flags) !== 0; if (!r && !s) return i && X0(t, n, !1), ur(e, t, o); r = t.stateNode, pF.current = t; var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && s ? (t.child = wo(t, e.child, null, o), t.child = wo(t, null, a, o)) : wt(e, t, a, o), t.memoizedState = r.state, i && X0(t, n, !0), t.child } function Qx(e) { var t = e.stateNode; t.pendingContext ? U0(e, t.pendingContext, t.pendingContext !== t.context) : t.context && U0(e, t.context, !1), np(e, t.containerInfo) } function lb(e, t, n, r, i) { return So(), qh(i), t.flags |= 256, wt(e, t, n, r), t.child } var wh = { dehydrated: null, treeContext: null, retryLane: 0 }; function kh(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Zx(e, t, n) { var r, i = t.pendingProps, o = Pe.current, s = !1, a = (128 & t.flags) !== 0; if ((r = a) || (r = (e === null || e.memoizedState !== null) && (2 & o) !== 0), r ? (s = !0, t.flags &= -129) : e !== null && e.memoizedState === null || (o |= 1), ye(Pe, 1 & o), e === null) return mh(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (1 & t.mode ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (a = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, a = { mode: "hidden", children: a }, !(1 & i) && s !== null ? (s.childLanes = 0, s.pendingProps = a) : s = Lc(a, i, 0, null), e = yi(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = kh(n), t.memoizedState = wh, e) : up(t, a)); if (o = e.memoizedState, o !== null && (r = o.dehydrated, r !== null)) return mF(e, t, a, i, r, o, n); if (s) { s = i.fallback, a = t.mode, o = e.child, r = o.sibling; var l = { mode: "hidden", children: i.children }; return !(1 & a) && t.child !== o ? (i = t.child, i.childLanes = 0, i.pendingProps = l, t.deletions = null) : (i = Br(o, l), i.subtreeFlags = 14680064 & o.subtreeFlags), r !== null ? s = Br(r, s) : (s = yi(s, a, n, null), s.flags |= 2), s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, a = e.child.memoizedState, a = a === null ? kh(n) : { baseLanes: a.baseLanes | n, cachePool: null, transitions: a.transitions }, s.memoizedState = a, s.childLanes = e.childLanes & ~n, t.memoizedState = wh, i } return s = e.child, e = s.sibling, i = Br(s, { mode: "visible", children: i.children }), !(1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function up(e, t) { return t = Lc({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function $l(e, t, n, r) { return r !== null && qh(r), wo(t, e.child, null, n), e = up(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function mF(e, t, n, r, i, o, s) { if (n) return 256 & t.flags ? (t.flags &= -257, r = Vd(Error(L(422))), $l(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = Lc({ mode: "visible", children: r.children }, i, 0, null), o = yi(o, i, s, null), o.flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, 1 & t.mode && wo(t, e.child, null, s), t.child.memoizedState = kh(s), t.memoizedState = wh, o); if (!(1 & t.mode)) return $l(e, t, s, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, o = Error(L(419)), r = Vd(o, r, void 0), $l(e, t, s, r) } if (a = (s & e.childLanes) !== 0, Mt || a) { if (r = Qe, r !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | s) ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, cr(e, i), kn(r, e, i, -1)) } return vp(), r = Vd(Error(L(421))), $l(e, t, s, r) } return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = PF.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, jt = Or(i.nextSibling), Wt = t, Re = !0, Sn = null, e !== null && (sn[an++] = ir, sn[an++] = or, sn[an++] = xi, ir = e.id, or = e.overflow, xi = t), t = up(t, r.children), t.flags |= 4096, t) } function cb(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), vh(e.return, t, n) } function Bd(e, t, n, r, i) { var o = e.memoizedState; o === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function Jx(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (wt(e, t, r.children, n), r = Pe.current, 2 & r) r = 1 & r | 2, t.flags |= 128; else { if (e !== null && 128 & e.flags) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && cb(e, n, t); else if (e.tag === 19) cb(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (ye(Pe, r), !(1 & t.mode)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; n !== null;)e = n.alternate, e !== null && pc(e) === null && (i = n), n = n.sibling; n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Bd(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; i !== null;) { if (e = i.alternate, e !== null && pc(e) === null) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } Bd(t, !0, n, null, o); break; case "together": Bd(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Gl(e, t) { !(1 & t.mode) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function ur(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), wi |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(L(153)); if (t.child !== null) { for (e = t.child, n = Br(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = Br(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function vF(e, t, n) { switch (t.tag) { case 3: Qx(t), So(); break; case 5: Ex(t); break; case 1: Dt(t.type) && lc(t); break; case 4: np(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; ye(fc, r._currentValue), r._currentValue = i; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (ye(Pe, 1 & Pe.current), t.flags |= 128, null) : n & t.child.childLanes ? Zx(e, t, n) : (ye(Pe, 1 & Pe.current), e = ur(e, t, n), e !== null ? e.sibling : null); ye(Pe, 1 & Pe.current); break; case 19: if (r = (n & t.childLanes) !== 0, 128 & e.flags) { if (r) return Jx(e, t, n); t.flags |= 128 } if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), ye(Pe, Pe.current), r) break; return null; case 22: case 23: return t.lanes = 0, Kx(e, t, n) }return ur(e, t, n) } var e1, Ch, t1, n1; e1 = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Ch = function () { }; t1 = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, vi(Hn.current); var o = null; switch (n) { case "input": i = Xd(e, i), r = Xd(e, r), o = []; break; case "select": i = Fe({}, i, { value: void 0 }), r = Fe({}, r, { value: void 0 }), o = []; break; case "textarea": i = Kd(e, i), r = Kd(e, r), o = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = sc) }Qd(n, r); var s; n = null; for (c in i) if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null) if (c === "style") { var a = i[c]; for (s in a) a.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (Vs.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null)); for (c in r) { var l = r[c]; if (a = i?.[c], r.hasOwnProperty(c) && l !== a && (l != null || a != null)) if (c === "style") if (a) { for (s in a) !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in l) l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), n[s] = l[s]) } else n || (o || (o = []), o.push(c, n)), n = l; else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (Vs.hasOwnProperty(c) ? (l != null && c === "onScroll" && Se("scroll", e), o || a === l || (o = [])) : (o = o || []).push(c, l)) } n && (o = o || []).push("style", n); var c = o; (t.updateQueue = c) && (t.flags |= 4) } }; n1 = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function Ss(e, t) { if (!Re) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function mt(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function gF(e, t, n) { var r = t.pendingProps; switch (Kh(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return mt(t), null; case 1: return Dt(t.type) && ac(), mt(t), null; case 3: return r = t.stateNode, ko(), we(Ot), we(gt), ip(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), e !== null && e.child !== null || (Vl(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(256 & t.flags) || (t.flags |= 1024, Sn !== null && (Ih(Sn), Sn = null))), Ch(e, t), mt(t), null; case 5: rp(t); var i = vi(Ks.current); if (n = t.type, e !== null && t.stateNode != null) t1(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(L(166)); return mt(t), null } if (e = vi(Hn.current), Vl(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[zn] = t, r[Ys] = o, e = (1 & t.mode) !== 0, n) { case "dialog": Se("cancel", r), Se("close", r); break; case "iframe": case "object": case "embed": Se("load", r); break; case "video": case "audio": for (i = 0; i < Rs.length; i++)Se(Rs[i], r); break; case "source": Se("error", r); break; case "img": case "image": case "link": Se("error", r), Se("load", r); break; case "details": Se("toggle", r); break; case "input": g0(r, o), Se("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, Se("invalid", r); break; case "textarea": b0(r, o), Se("invalid", r) }Qd(n, o), i = null; for (var s in o) if (o.hasOwnProperty(s)) { var a = o[s]; s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && Al(r.textContent, a, e), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && Al(r.textContent, a, e), i = ["children", "" + a]) : Vs.hasOwnProperty(s) && a != null && s === "onScroll" && Se("scroll", r) } switch (n) { case "input": Cl(r), y0(r, o, !0); break; case "textarea": Cl(r), x0(r); break; case "select": case "option": break; default: typeof o.onClick == "function" && (r.onclick = sc) }r = i, t.updateQueue = r, r !== null && (t.flags |= 4) } else { s = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = _b(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, { is: r.is }) : (e = s.createElement(n), n === "select" && (s = e, r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n), e[zn] = t, e[Ys] = r, e1(e, t, !1, !1), t.stateNode = e; e: { switch (s = Zd(n, r), n) { case "dialog": Se("cancel", e), Se("close", e), i = r; break; case "iframe": case "object": case "embed": Se("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Rs.length; i++)Se(Rs[i], e); i = r; break; case "source": Se("error", e), i = r; break; case "img": case "image": case "link": Se("error", e), Se("load", e), i = r; break; case "details": Se("toggle", e), i = r; break; case "input": g0(e, r), i = Xd(e, r), Se("invalid", e); break; case "option": i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = Fe({}, r, { value: void 0 }), Se("invalid", e); break; case "textarea": b0(e, r), i = Kd(e, r), Se("invalid", e); break; default: i = r }Qd(n, i), a = i; for (o in a) if (a.hasOwnProperty(o)) { var l = a[o]; o === "style" ? Lb(e, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Fb(e, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && Bs(e, l) : typeof l == "number" && Bs(e, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (Vs.hasOwnProperty(o) ? l != null && o === "onScroll" && Se("scroll", e) : l != null && Oh(e, o, l, s)) } switch (n) { case "input": Cl(e), y0(e, r, !1); break; case "textarea": Cl(e), x0(e); break; case "option": r.value != null && e.setAttribute("value", "" + $r(r.value)); break; case "select": e.multiple = !!r.multiple, o = r.value, o != null ? ho(e, !!r.multiple, o, !1) : r.defaultValue != null && ho(e, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (e.onclick = sc) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return mt(t), null; case 6: if (e && t.stateNode != null) n1(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(L(166)); if (n = vi(Ks.current), vi(Hn.current), Vl(t)) { if (r = t.stateNode, n = t.memoizedProps, r[zn] = t, (o = r.nodeValue !== n) && (e = Wt, e !== null)) switch (e.tag) { case 3: Al(r.nodeValue, n, (1 & e.mode) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && Al(r.nodeValue, n, (1 & e.mode) !== 0) }o && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[zn] = t, t.stateNode = r } return mt(t), null; case 13: if (we(Pe), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Re && jt !== null && 1 & t.mode && !(128 & t.flags)) bx(), So(), t.flags |= 98560, o = !1; else if (o = Vl(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!o) throw Error(L(318)); if (o = t.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(L(317)); o[zn] = t } else So(), !(128 & t.flags) && (t.memoizedState = null), t.flags |= 4; mt(t), o = !1 } else Sn !== null && (Ih(Sn), Sn = null), o = !0; if (!o) return 65536 & t.flags ? t : null } return 128 & t.flags ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, 1 & t.mode && (e === null || 1 & Pe.current ? Ye === 0 && (Ye = 3) : vp())), t.updateQueue !== null && (t.flags |= 4), mt(t), null); case 4: return ko(), Ch(e, t), e === null && Us(t.stateNode.containerInfo), mt(t), null; case 10: return Jh(t.type._context), mt(t), null; case 17: return Dt(t.type) && ac(), mt(t), null; case 19: if (we(Pe), o = t.memoizedState, o === null) return mt(t), null; if (r = (128 & t.flags) !== 0, s = o.rendering, s === null) if (r) Ss(o, !1); else { if (Ye !== 0 || e !== null && 128 & e.flags) for (e = t.child; e !== null;) { if (s = pc(e), s !== null) { for (t.flags |= 128, Ss(o, !1), r = s.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)o = n, e = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, e = s.dependencies, o.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return ye(Pe, 1 & Pe.current | 2), t.child } e = e.sibling } o.tail !== null && He() > To && (t.flags |= 128, r = !0, Ss(o, !1), t.lanes = 4194304) } else { if (!r) if (e = pc(s), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), Ss(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !Re) return mt(t), null } else 2 * He() - o.renderingStartTime > To && n !== 1073741824 && (t.flags |= 128, r = !0, Ss(o, !1), t.lanes = 4194304); o.isBackwards ? (s.sibling = t.child, t.child = s) : (n = o.last, n !== null ? n.sibling = s : t.child = s, o.last = s) } return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = He(), t.sibling = null, n = Pe.current, ye(Pe, r ? 1 & n | 2 : 1 & n), t) : (mt(t), null); case 22: case 23: return mp(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && 1 & t.mode ? 1073741824 & Ht && (mt(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : mt(t), null; case 24: return null; case 25: return null }throw Error(L(156, t.tag)) } function yF(e, t) { switch (Kh(t), t.tag) { case 1: return Dt(t.type) && ac(), e = t.flags, 65536 & e ? (t.flags = -65537 & e | 128, t) : null; case 3: return ko(), we(Ot), we(gt), ip(), e = t.flags, 65536 & e && !(128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return rp(t), null; case 13: if (we(Pe), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(L(340)); So() } return e = t.flags, 65536 & e ? (t.flags = -65537 & e | 128, t) : null; case 19: return we(Pe), null; case 4: return ko(), null; case 10: return Jh(t.type._context), null; case 22: case 23: return mp(), null; case 24: return null; default: return null } } var zl = !1, vt = !1, bF = typeof WeakSet == "function" ? WeakSet : Set, A = null; function uo(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { De(e, t, r) } else n.current = null } function r1(e, t, n) { try { n() } catch (r) { De(e, t, r) } } var ub = !1; function xF(e, t) { if (lh = rc, e = sx(), Yh(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch { n = null; break e } var s = 0, a = -1, l = -1, c = 0, u = 0, f = e, d = null; t: for (; ;) { for (var p; f !== n || i !== 0 && f.nodeType !== 3 || (a = s + i), f !== o || r !== 0 && f.nodeType !== 3 || (l = s + r), f.nodeType === 3 && (s += f.nodeValue.length), (p = f.firstChild) !== null;)d = f, f = p; for (; ;) { if (f === e) break t; if (d === n && ++c === i && (a = s), d === o && ++u === r && (l = s), (p = f.nextSibling) !== null) break; f = d, d = f.parentNode } f = p } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ch = { focusedElem: e, selectionRange: n }, rc = !1, A = t; A !== null;)if (t = A, e = t.child, (1028 & t.subtreeFlags) !== 0 && e !== null) e.return = t, A = e; else for (; A !== null;) { t = A; try { var g = t.alternate; if (1024 & t.flags) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var v = g.memoizedProps, S = g.memoizedState, m = t.stateNode, h = m.getSnapshotBeforeUpdate(t.elementType === t.type ? v : bn(t.type, v), S); m.__reactInternalSnapshotBeforeUpdate = h } break; case 3: var y = t.stateNode.containerInfo; y.nodeType === 1 ? y.textContent = "" : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(L(163)) } } catch (x) { De(t, t.return, x) } if (e = t.sibling, e !== null) { e.return = t.return, A = e; break } A = t.return } return g = ub, ub = !1, g } function Os(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, o !== void 0 && r1(t, n, o) } i = i.next } while (i !== r) } } function Fc(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function Th(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function i1(e) { var t = e.alternate; t !== null && (e.alternate = null, i1(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[zn], delete t[Ys], delete t[dh], delete t[nF], delete t[rF])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function o1(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function fb(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || o1(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (2 & e.flags || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function Eh(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = sc)); else if (r !== 4 && (e = e.child, e !== null)) for (Eh(e, t, n), e = e.sibling; e !== null;)Eh(e, t, n), e = e.sibling } function Rh(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (Rh(e, t, n), e = e.sibling; e !== null;)Rh(e, t, n), e = e.sibling } var rt = null, xn = !1; function Cr(e, t, n) { for (n = n.child; n !== null;)s1(e, t, n), n = n.sibling } function s1(e, t, n) { if (Nn && typeof Nn.onCommitFiberUnmount == "function") try { Nn.onCommitFiberUnmount(wc, n) } catch { } switch (n.tag) { case 5: vt || uo(n, t); case 6: var r = rt, i = xn; rt = null, Cr(e, t, n), rt = r, xn = i, rt !== null && (xn ? (e = rt, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : rt.removeChild(n.stateNode)); break; case 18: rt !== null && (xn ? (e = rt, n = n.stateNode, e.nodeType === 8 ? Id(e.parentNode, n) : e.nodeType === 1 && Id(e, n), Hs(e)) : Id(rt, n.stateNode)); break; case 4: r = rt, i = xn, rt = n.stateNode.containerInfo, xn = !0, Cr(e, t, n), rt = r, xn = i; break; case 0: case 11: case 14: case 15: if (!vt && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var o = i, s = o.destroy; o = o.tag, s !== void 0 && (2 & o || 4 & o) && r1(n, t, s), i = i.next } while (i !== r) } Cr(e, t, n); break; case 1: if (!vt && (uo(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { De(n, t, a) } Cr(e, t, n); break; case 21: Cr(e, t, n); break; case 22: 1 & n.mode ? (vt = (r = vt) || n.memoizedState !== null, Cr(e, t, n), vt = r) : Cr(e, t, n); break; default: Cr(e, t, n) } } function db(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new bF), t.forEach(function (r) { var i = _F.bind(null, e, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function yn(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, s = t, a = s; e: for (; a !== null;) { switch (a.tag) { case 5: rt = a.stateNode, xn = !1; break e; case 3: rt = a.stateNode.containerInfo, xn = !0; break e; case 4: rt = a.stateNode.containerInfo, xn = !0; break e }a = a.return } if (rt === null) throw Error(L(160)); s1(o, s, i), rt = null, xn = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (c) { De(i, t, c) } } if (12854 & t.subtreeFlags) for (t = t.child; t !== null;)a1(t, e), t = t.sibling } function a1(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (yn(t, e), Bn(e), 4 & r) { try { Os(3, e, e.return), Fc(3, e) } catch (v) { De(e, e.return, v) } try { Os(5, e, e.return) } catch (v) { De(e, e.return, v) } } break; case 1: yn(t, e), Bn(e), 512 & r && n !== null && uo(n, n.return); break; case 5: if (yn(t, e), Bn(e), 512 & r && n !== null && uo(n, n.return), 32 & e.flags) { var i = e.stateNode; try { Bs(i, "") } catch (v) { De(e, e.return, v) } } if (4 & r && (i = e.stateNode, i != null)) { var o = e.memoizedProps, s = n !== null ? n.memoizedProps : o, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && o.type === "radio" && o.name != null && Rb(i, o), Zd(a, s); var c = Zd(a, o); for (s = 0; s < l.length; s += 2) { var u = l[s], f = l[s + 1]; u === "style" ? Lb(i, f) : u === "dangerouslySetInnerHTML" ? Fb(i, f) : u === "children" ? Bs(i, f) : Oh(i, u, f, c) } switch (a) { case "input": Yd(i, o); break; case "textarea": Pb(i, o); break; case "select": var d = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var p = o.value; p != null ? ho(i, !!o.multiple, p, !1) : d !== !!o.multiple && (o.defaultValue != null ? ho(i, !!o.multiple, o.defaultValue, !0) : ho(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[Ys] = o } catch (v) { De(e, e.return, v) } } break; case 6: if (yn(t, e), Bn(e), 4 & r) { if (e.stateNode === null) throw Error(L(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (v) { De(e, e.return, v) } } break; case 3: if (yn(t, e), Bn(e), 4 & r && n !== null && n.memoizedState.isDehydrated) try { Hs(t.containerInfo) } catch (v) { De(e, e.return, v) } break; case 4: yn(t, e), Bn(e); break; case 13: yn(t, e), Bn(e), i = e.child, 8192 & i.flags && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (hp = He())), 4 & r && db(e); break; case 22: if (u = n !== null && n.memoizedState !== null, 1 & e.mode ? (vt = (c = vt) || u, yn(t, e), vt = c) : yn(t, e), Bn(e), 8192 & r) { if (c = e.memoizedState !== null, (e.stateNode.isHidden = c) && !u && 1 & e.mode) for (A = e, u = e.child; u !== null;) { for (f = A = u; A !== null;) { switch (d = A, p = d.child, d.tag) { case 0: case 11: case 14: case 15: Os(4, d, d.return); break; case 1: uo(d, d.return); var g = d.stateNode; if (typeof g.componentWillUnmount == "function") { r = d, n = d.return; try { t = r, g.props = t.memoizedProps, g.state = t.memoizedState, g.componentWillUnmount() } catch (v) { De(r, n, v) } } break; case 5: uo(d, d.return); break; case 22: if (d.memoizedState !== null) { pb(f); continue } }p !== null ? (p.return = d, A = p) : pb(f) } u = u.sibling } e: for (u = null, f = e; ;) { if (f.tag === 5) { if (u === null) { u = f; try { i = f.stateNode, c ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Ib("display", s)) } catch (v) { De(e, e.return, v) } } } else if (f.tag === 6) { if (u === null) try { f.stateNode.nodeValue = c ? "" : f.memoizedProps } catch (v) { De(e, e.return, v) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === e) break e; for (; f.sibling === null;) { if (f.return === null || f.return === e) break e; u === f && (u = null), f = f.return } u === f && (u = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: yn(t, e), Bn(e), 4 & r && db(e); break; case 21: break; default: yn(t, e), Bn(e) } } function Bn(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; n !== null;) { if (o1(n)) { var r = n; break e } n = n.return } throw Error(L(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (Bs(i, ""), r.flags &= -33); var o = fb(e); Rh(e, o, i); break; case 3: case 4: var s = r.stateNode.containerInfo, a = fb(e); Eh(e, a, s); break; default: throw Error(L(161)) } } catch (l) { De(e, e.return, l) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function SF(e, t, n) { A = e, l1(e, t, n) } function l1(e, t, n) { for (var r = (1 & e.mode) !== 0; A !== null;) { var i = A, o = i.child; if (i.tag === 22 && r) { var s = i.memoizedState !== null || zl; if (!s) { var a = i.alternate, l = a !== null && a.memoizedState !== null || vt; a = zl; var c = vt; if (zl = s, (vt = l) && !c) for (A = i; A !== null;)s = A, l = s.child, s.tag === 22 && s.memoizedState !== null ? mb(i) : l !== null ? (l.return = s, A = l) : mb(i); for (; o !== null;)A = o, l1(o, t, n), o = o.sibling; A = i, zl = a, vt = c } hb(e, t, n) } else 8772 & i.subtreeFlags && o !== null ? (o.return = i, A = o) : hb(e, t, n) } } function hb(e) { for (; A !== null;) { var t = A; if (8772 & t.flags) { var n = t.alternate; try { if (8772 & t.flags) switch (t.tag) { case 0: case 11: case 15: vt || Fc(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !vt) if (n === null) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : bn(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; o !== null && q0(t, o, r); break; case 3: var s = t.updateQueue; if (s !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }q0(t, s, n) } break; case 5: var a = t.stateNode; if (n === null && 4 & t.flags) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var c = t.alternate; if (c !== null) { var u = c.memoizedState; if (u !== null) { var f = u.dehydrated; f !== null && Hs(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(L(163)) }vt || 512 & t.flags && Th(t) } catch (d) { De(t, t.return, d) } } if (t === e) { A = null; break } if (n = t.sibling, n !== null) { n.return = t.return, A = n; break } A = t.return } } function pb(e) { for (; A !== null;) { var t = A; if (t === e) { A = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, A = n; break } A = t.return } } function mb(e) { for (; A !== null;) { var t = A; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { Fc(4, t) } catch (l) { De(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var i = t.return; try { r.componentDidMount() } catch (l) { De(t, i, l) } } var o = t.return; try { Th(t) } catch (l) { De(t, o, l) } break; case 5: var s = t.return; try { Th(t) } catch (l) { De(t, s, l) } } } catch (l) { De(t, t.return, l) } if (t === e) { A = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, A = a; break } A = t.return } } var wF = Math.ceil, gc = fr.ReactCurrentDispatcher, fp = fr.ReactCurrentOwner, cn = fr.ReactCurrentBatchConfig, ce = 0, Qe = null, Ue = null, it = 0, Ht = 0, fo = Hr(0), Ye = 0, Js = null, wi = 0, Ic = 0, dp = 0, Ds = null, Lt = null, hp = 0, To = 1 / 0, nr = null, yc = !1, Ph = null, Ar = null, Nl = !1, Fr = null, bc = 0, As = 0, _h = null, Kl = -1, ql = 0; function kt() { return 6 & ce ? He() : Kl !== -1 ? Kl : Kl = He() } function Vr(e) { return 1 & e.mode ? 2 & ce && it !== 0 ? it & -it : oF.transition !== null ? (ql === 0 && (ql = Wb()), ql) : (e = me, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Qb(e.type)), e) : 1 } function kn(e, t, n, r) { if (50 < As) throw As = 0, _h = null, Error(L(185)); ea(e, n, r), 2 & ce && e === Qe || (e === Qe && (!(2 & ce) && (Ic |= n), Ye === 4 && Pr(e, it)), At(e, r), n === 1 && ce === 0 && !(1 & t.mode) && (To = He() + 500, Rc && jr())) } function At(e, t) { var n = e.callbackNode; a2(e, t); var r = nc(e, e === Qe ? it : 0); if (r === 0) n !== null && k0(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && k0(n), t === 1) e.tag === 0 ? iF(vb.bind(null, e)) : vx(vb.bind(null, e)), eF(function () { !(6 & ce) && jr() }), n = null; else { switch (Ub(r)) { case 1: n = $h; break; case 4: n = Hb; break; case 16: n = tc; break; case 536870912: n = jb; break; default: n = tc }n = v1(n, c1.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function c1(e, t) { if (Kl = -1, ql = 0, 6 & ce) throw Error(L(327)); var n = e.callbackNode; if (yo() && e.callbackNode !== n) return null; var r = nc(e, e === Qe ? it : 0); if (r === 0) return null; if (30 & r || r & e.expiredLanes || t) t = xc(e, r); else { t = r; var i = ce; ce |= 2; var o = f1(); Qe === e && it === t || (nr = null, To = He() + 500, gi(e, t)); do try { TF(); break } catch (a) { u1(e, a) } while (1); Zh(), gc.current = o, ce = i, Ue !== null ? t = 0 : (Qe = null, it = 0, t = Ye) } if (t !== 0) { if (t === 2 && (i = rh(e), i !== 0 && (r = i, t = Fh(e, i))), t === 1) throw n = Js, gi(e, 0), Pr(e, r), At(e, He()), n; if (t === 6) Pr(e, r); else { if (i = e.current.alternate, !(30 & r) && !kF(i) && (t = xc(e, r), t === 2 && (o = rh(e), o !== 0 && (r = o, t = Fh(e, o))), t === 1)) throw n = Js, gi(e, 0), Pr(e, r), At(e, He()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(L(345)); case 2: hi(e, Lt, nr); break; case 3: if (Pr(e, r), (130023424 & r) === r && (t = hp + 500 - He(), 10 < t)) { if (nc(e, 0) !== 0) break; if (i = e.suspendedLanes, (i & r) !== r) { kt(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = fh(hi.bind(null, e, Lt, nr), t); break } hi(e, Lt, nr); break; case 4: if (Pr(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - wn(r); o = 1 << s, s = t[s], s > i && (i = s), r &= ~o } if (r = i, r = He() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * wF(r / 1960)) - r, 10 < r) { e.timeoutHandle = fh(hi.bind(null, e, Lt, nr), r); break } hi(e, Lt, nr); break; case 5: hi(e, Lt, nr); break; default: throw Error(L(329)) } } } return At(e, He()), e.callbackNode === n ? c1.bind(null, e) : null } function Fh(e, t) { var n = Ds; return e.current.memoizedState.isDehydrated && (gi(e, t).flags |= 256), e = xc(e, t), e !== 2 && (t = Lt, Lt = n, t !== null && Ih(t)), e } function Ih(e) { Lt === null ? Lt = e : Lt.push.apply(Lt, e) } function kF(e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!Cn(o(), i)) return !1 } catch { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function Pr(e, t) { for (t &= ~dp, t &= ~Ic, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - wn(t), r = 1 << n; e[n] = -1, t &= ~r } } function vb(e) { if (6 & ce) throw Error(L(327)); yo(); var t = nc(e, 0); if (!(1 & t)) return At(e, He()), null; var n = xc(e, t); if (e.tag !== 0 && n === 2) { var r = rh(e); r !== 0 && (t = r, n = Fh(e, r)) } if (n === 1) throw n = Js, gi(e, 0), Pr(e, t), At(e, He()), n; if (n === 6) throw Error(L(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, hi(e, Lt, nr), At(e, He()), null } function pp(e, t) { var n = ce; ce |= 1; try { return e(t) } finally { ce = n, ce === 0 && (To = He() + 500, Rc && jr()) } } function ki(e) { Fr !== null && Fr.tag === 0 && !(6 & ce) && yo(); var t = ce; ce |= 1; var n = cn.transition, r = me; try { if (cn.transition = null, me = 1, e) return e() } finally { me = r, cn.transition = n, ce = t, !(6 & ce) && jr() } } function mp() { Ht = fo.current, we(fo) } function gi(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, J2(n)), Ue !== null) for (n = Ue.return; n !== null;) { var r = n; switch (Kh(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && ac(); break; case 3: ko(), we(Ot), we(gt), ip(); break; case 5: rp(r); break; case 4: ko(); break; case 13: we(Pe); break; case 19: we(Pe); break; case 10: Jh(r.type._context); break; case 22: case 23: mp() }n = n.return } if (Qe = e, Ue = e = Br(e.current, null), it = Ht = t, Ye = 0, Js = null, dp = Ic = wi = 0, Lt = Ds = null, mi !== null) { for (t = 0; t < mi.length; t++)if (n = mi[t], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, o = n.pending; if (o !== null) { var s = o.next; o.next = i, r.next = s } n.pending = r } mi = null } return e } function u1(e, t) { do { var n = Ue; try { if (Zh(), Xl.current = vc, mc) { for (var r = _e.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } mc = !1 } if (Si = 0, qe = Xe = _e = null, Ms = !1, qs = 0, fp.current = null, n === null || n.return === null) { Ye = 1, Js = t, Ue = null; break } e: { var o = e, s = n.return, a = n, l = t; if (t = it, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var c = l, u = a, f = u.tag; if (!(1 & u.mode) && (f === 0 || f === 11 || f === 15)) { var d = u.alternate; d ? (u.updateQueue = d.updateQueue, u.memoizedState = d.memoizedState, u.lanes = d.lanes) : (u.updateQueue = null, u.memoizedState = null) } var p = rb(s); if (p !== null) { p.flags &= -257, ib(p, s, a, o, t), 1 & p.mode && nb(o, c, t), t = p, l = c; var g = t.updateQueue; if (g === null) { var v = new Set; v.add(l), t.updateQueue = v } else g.add(l); break e } if (!(1 & t)) { nb(o, c, t), vp(); break e } l = Error(L(426)) } else if (Re && 1 & a.mode) { var S = rb(s); if (S !== null) { !(65536 & S.flags) && (S.flags |= 256), ib(S, s, a, o, t), qh(Co(l, a)); break e } } o = l = Co(l, a), Ye !== 4 && (Ye = 2), Ds === null ? Ds = [o] : Ds.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t; var m = Xx(o, l, t); K0(o, m); break e; case 1: a = l; var h = o.type, y = o.stateNode; if (!(128 & o.flags) && (typeof h.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (Ar === null || !Ar.has(y)))) { o.flags |= 65536, t &= -t, o.lanes |= t; var x = Yx(o, a, t); K0(o, x); break e } }o = o.return } while (o !== null) } h1(n) } catch (k) { t = k, Ue === n && n !== null && (Ue = n = n.return); continue } break } while (1) } function f1() { var e = gc.current; return gc.current = vc, e === null ? vc : e } function vp() { Ye !== 0 && Ye !== 3 && Ye !== 2 || (Ye = 4), Qe === null || !(268435455 & wi) && !(268435455 & Ic) || Pr(Qe, it) } function xc(e, t) { var n = ce; ce |= 2; var r = f1(); Qe === e && it === t || (nr = null, gi(e, t)); do try { CF(); break } catch (i) { u1(e, i) } while (1); if (Zh(), ce = n, gc.current = r, Ue !== null) throw Error(L(261)); return Qe = null, it = 0, Ye } function CF() { for (; Ue !== null;)d1(Ue) } function TF() { for (; Ue !== null && !Z_();)d1(Ue) } function d1(e) { var t = m1(e.alternate, e, Ht); e.memoizedProps = e.pendingProps, t === null ? h1(e) : Ue = t, fp.current = null } function h1(e) { var t = e; do { var n = t.alternate; if (e = t.return, 32768 & t.flags) { if (n = yF(n, t), n !== null) { n.flags &= 32767, Ue = n; return } if (e === null) { Ye = 6, Ue = null; return } e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } else if (n = gF(n, t, Ht), n !== null) { Ue = n; return } if (t = t.sibling, t !== null) { Ue = t; return } Ue = t = e } while (t !== null); Ye === 0 && (Ye = 5) } function hi(e, t, n) { var r = me, i = cn.transition; try { cn.transition = null, me = 1, EF(e, t, n, r) } finally { cn.transition = i, me = r } return null } function EF(e, t, n, r) { do yo(); while (Fr !== null); if (6 & ce) throw Error(L(327)); n = e.finishedWork; var i = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(L(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (l2(e, o), e === Qe && (Ue = Qe = null, it = 0), !(2064 & n.subtreeFlags) && !(2064 & n.flags) || Nl || (Nl = !0, v1(tc, function () { return yo(), null })), o = (15990 & n.flags) !== 0, 15990 & n.subtreeFlags || o) { o = cn.transition, cn.transition = null; var s = me; me = 1; var a = ce; ce |= 4, fp.current = null, xF(e, n), a1(n, e), G2(ch), rc = !!lh, ch = lh = null, e.current = n, SF(n, e, i), J_(), ce = a, me = s, cn.transition = o } else e.current = n; if (Nl && (Nl = !1, Fr = e, bc = i), o = e.pendingLanes, o === 0 && (Ar = null), n2(n.stateNode, r), At(e, He()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (yc) throw yc = !1, e = Ph, Ph = null, e; return 1 & bc && e.tag !== 0 && yo(), o = e.pendingLanes, 1 & o ? e === _h ? As++ : (As = 0, _h = e) : As = 0, jr(), null } function yo() { if (Fr !== null) { var e = Ub(bc), t = cn.transition, n = me; try { if (cn.transition = null, me = 16 > e ? 16 : e, Fr === null) var r = !1; else { if (e = Fr, Fr = null, bc = 0, 6 & ce) throw Error(L(331)); var i = ce; for (ce |= 4, A = e.current; A !== null;) { var o = A, s = o.child; if (16 & A.flags) { var a = o.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var c = a[l]; for (A = c; A !== null;) { var u = A; switch (u.tag) { case 0: case 11: case 15: Os(8, u, o) }var f = u.child; if (f !== null) f.return = u, A = f; else for (; A !== null;) { u = A; var d = u.sibling, p = u.return; if (i1(u), u === c) { A = null; break } if (d !== null) { d.return = p, A = d; break } A = p } } } var g = o.alternate; if (g !== null) { var v = g.child; if (v !== null) { g.child = null; do { var S = v.sibling; v.sibling = null, v = S } while (v !== null) } } A = o } } if (2064 & o.subtreeFlags && s !== null) s.return = o, A = s; else e: for (; A !== null;) { if (o = A, 2048 & o.flags) switch (o.tag) { case 0: case 11: case 15: Os(9, o, o.return) }var m = o.sibling; if (m !== null) { m.return = o.return, A = m; break e } A = o.return } } var h = e.current; for (A = h; A !== null;) { s = A; var y = s.child; if (2064 & s.subtreeFlags && y !== null) y.return = s, A = y; else e: for (s = h; A !== null;) { if (a = A, 2048 & a.flags) try { switch (a.tag) { case 0: case 11: case 15: Fc(9, a) } } catch (k) { De(a, a.return, k) } if (a === s) { A = null; break e } var x = a.sibling; if (x !== null) { x.return = a.return, A = x; break e } A = a.return } } if (ce = i, jr(), Nn && typeof Nn.onPostCommitFiberRoot == "function") try { Nn.onPostCommitFiberRoot(wc, e) } catch { } r = !0 } return r } finally { me = n, cn.transition = t } } return !1 } function gb(e, t, n) { t = Co(n, t), t = Xx(e, t, 1), e = Dr(e, t, 1), t = kt(), e !== null && (ea(e, 1, t), At(e, t)) } function De(e, t, n) { if (e.tag === 3) gb(e, e, n); else for (; t !== null;) { if (t.tag === 3) { gb(t, e, n); break } if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Ar === null || !Ar.has(r))) { e = Co(n, e), e = Yx(t, e, 1), t = Dr(t, e, 1), e = kt(), t !== null && (ea(t, 1, e), At(t, e)); break } } t = t.return } } function RF(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = kt(), e.pingedLanes |= e.suspendedLanes & n, Qe === e && (it & n) === n && (Ye === 4 || Ye === 3 && (130023424 & it) === it && 500 > He() - hp ? gi(e, 0) : dp |= n), At(e, t) } function p1(e, t) { t === 0 && (1 & e.mode ? (t = Rl, Rl <<= 1, !(130023424 & Rl) && (Rl = 4194304)) : t = 1); var n = kt(); e = cr(e, t), e !== null && (ea(e, t, n), At(e, n)) } function PF(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), p1(e, n) } function _F(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(L(314)) }r !== null && r.delete(t), p1(e, n) } var m1; m1 = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || Ot.current) Mt = !0; else { if (!(e.lanes & n) && !(128 & t.flags)) return Mt = !1, vF(e, t, n); Mt = (131072 & e.flags) !== 0 } else Mt = !1, Re && 1048576 & t.flags && gx(t, uc, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Gl(e, t), e = t.pendingProps; var i = xo(t, gt.current); go(t, n), i = sp(null, t, r, e, i, n); var o = ap(); return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Dt(r) ? (o = !0, lc(t)) : o = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, tp(t), i.updater = Pc, t.stateNode = i, i._reactInternals = t, yh(t, r, e, n), t = Sh(null, t, r, !0, o, n)) : (t.tag = 0, Re && o && Gh(t), wt(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Gl(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = IF(r), e = bn(r, e), i) { case 0: t = xh(null, t, r, e, n); break e; case 1: t = ab(null, t, r, e, n); break e; case 11: t = ob(null, t, r, e, n); break e; case 14: t = sb(null, t, r, bn(r.type, e), n); break e }throw Error(L(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : bn(r, i), xh(e, t, r, i, n); case 1: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : bn(r, i), ab(e, t, r, i, n); case 3: e: { if (Qx(t), e === null) throw Error(L(387)); r = t.pendingProps, o = t.memoizedState, i = o.element, Sx(e, t), hc(t, r, null, n); var s = t.memoizedState; if (r = s.element, o.isDehydrated) { if (o = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, 256 & t.flags) { i = Co(Error(L(423)), t), t = lb(e, t, r, n, i); break e } if (r !== i) { i = Co(Error(L(424)), t), t = lb(e, t, r, n, i); break e } for (jt = Or(t.stateNode.containerInfo.firstChild), Wt = t, Re = !0, Sn = null, n = Tx(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (So(), r === i) { t = ur(e, t, n); break e } wt(e, t, r, n) } t = t.child } return t; case 5: return Ex(t), e === null && mh(t), r = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, s = i.children, uh(r, i) ? s = null : o !== null && uh(r, o) && (t.flags |= 32), qx(e, t), wt(e, t, s, n), t.child; case 6: return e === null && mh(t), null; case 13: return Zx(e, t, n); case 4: return np(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = wo(t, null, r, n) : wt(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : bn(r, i), ob(e, t, r, i, n); case 7: return wt(e, t, t.pendingProps, n), t.child; case 8: return wt(e, t, t.pendingProps.children, n), t.child; case 12: return wt(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, s = i.value, ye(fc, r._currentValue), r._currentValue = s, o !== null) if (Cn(o.value, s)) { if (o.children === i.children && !Ot.current) { t = ur(e, t, n); break e } } else for (o = t.child, o !== null && (o.return = t); o !== null;) { var a = o.dependencies; if (a !== null) { s = o.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (o.tag === 1) { l = sr(-1, n & -n), l.tag = 2; var c = o.updateQueue; if (c !== null) { c = c.shared; var u = c.pending; u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l } } o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), vh(o.return, n, t), a.lanes |= n; break } l = l.next } } else if (o.tag === 10) s = o.type === t.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(L(341)); s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), vh(s, n, t), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === t) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } wt(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, go(t, n), i = un(i), r = r(i), t.flags |= 1, wt(e, t, r, n), t.child; case 14: return r = t.type, i = bn(r, t.pendingProps), i = bn(r.type, i), sb(e, t, r, i, n); case 15: return Gx(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : bn(r, i), Gl(e, t), t.tag = 1, Dt(r) ? (e = !0, lc(t)) : e = !1, go(t, n), kx(t, r, i), yh(t, r, i, n), Sh(null, t, r, !0, e, n); case 19: return Jx(e, t, n); case 22: return Kx(e, t, n) }throw Error(L(156, t.tag)) }; function v1(e, t) { return Nb(e, t) } function FF(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function ln(e, t, n, r) { return new FF(e, t, n, r) } function gp(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function IF(e) { if (typeof e == "function") return gp(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Ah) return 11; if (e === Vh) return 14 } return 2 } function Br(e, t) { var n = e.alternate; return n === null ? (n = ln(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Ql(e, t, n, r, i, o) { var s = 2; if (r = e, typeof e == "function") gp(e) && (s = 1); else if (typeof e == "string") s = 5; else e: switch (e) { case to: return yi(n.children, i, o, t); case Dh: s = 8, i |= 8; break; case Hd: return e = ln(12, n, t, 2 | i), e.elementType = Hd, e.lanes = o, e; case jd: return e = ln(13, n, t, i), e.elementType = jd, e.lanes = o, e; case Wd: return e = ln(19, n, t, i), e.elementType = Wd, e.lanes = o, e; case Cb: return Lc(n, i, o, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case wb: s = 10; break e; case kb: s = 9; break e; case Ah: s = 11; break e; case Vh: s = 14; break e; case Tr: s = 16, r = null; break e }throw Error(L(130, e == null ? e : typeof e, "")) }return t = ln(s, n, t, i), t.elementType = e, t.type = r, t.lanes = o, t } function yi(e, t, n, r) { return e = ln(7, e, r, t), e.lanes = n, e } function Lc(e, t, n, r) { return e = ln(22, e, r, t), e.elementType = Cb, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function $d(e, t, n) { return e = ln(6, e, null, t), e.lanes = n, e } function zd(e, t, n) { return t = ln(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function LF(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = kd(0), this.expirationTimes = kd(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = kd(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function yp(e, t, n, r, i, o, s, a, l) { return e = new LF(e, t, n, a, l), t === 1 ? (t = 1, o === !0 && (t |= 8)) : t = 0, o = ln(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, tp(o), e } function MF(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: eo, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function g1(e) { if (!e) return zr; e = e._reactInternals; e: { if (Ti(e) !== e || e.tag !== 1) throw Error(L(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Dt(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(L(171)) } if (e.tag === 1) { var n = e.type; if (Dt(n)) return mx(e, n, t) } return t } function y1(e, t, n, r, i, o, s, a, l) { return e = yp(n, r, !0, e, i, o, s, a, l), e.context = g1(null), n = e.current, r = kt(), i = Vr(n), o = sr(r, i), o.callback = t ?? null, Dr(n, o, i), e.current.lanes = i, ea(e, i, r), At(e, r), e } function Mc(e, t, n, r) { var i = t.current, o = kt(), s = Vr(i); return n = g1(n), t.context === null ? t.context = n : t.pendingContext = n, t = sr(o, s), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = Dr(i, t, s), e !== null && (kn(e, i, s, o), Ul(e, i, s)), s } function Sc(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function yb(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function bp(e, t) { yb(e, t), (e = e.alternate) && yb(e, t) } function OF() { return null } var b1 = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function xp(e) { this._internalRoot = e } Oc.prototype.render = xp.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(L(409)); Mc(e, t, null, null) }; Oc.prototype.unmount = xp.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; ki(function () { Mc(null, e, null, null) }), t[lr] = null } }; function Oc(e) { this._internalRoot = e } Oc.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Gb(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Rr.length && t !== 0 && t < Rr[n].priority; n++); Rr.splice(n, 0, e), n === 0 && qb(e) } }; function Sp(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Dc(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function bb() { } function DF(e, t, n, r, i) { if (i) { if (typeof r == "function") { var o = r; r = function () { var c = Sc(s); o.call(c) } } var s = y1(t, r, e, 0, null, !1, !1, "", bb); return e._reactRootContainer = s, e[lr] = s.current, Us(e.nodeType === 8 ? e.parentNode : e), ki(), s } for (; i = e.lastChild;)e.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var c = Sc(l); a.call(c) } } var l = yp(e, 0, !1, null, null, !1, !1, "", bb); return e._reactRootContainer = l, e[lr] = l.current, Us(e.nodeType === 8 ? e.parentNode : e), ki(function () { Mc(t, l, n, r) }), l } function Ac(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var s = o; if (typeof i == "function") { var a = i; i = function () { var l = Sc(s); a.call(l) } } Mc(t, s, e, i) } else s = DF(n, t, e, i, r); return Sc(s) } Xb = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Es(t.pendingLanes); n !== 0 && (zh(t, 1 | n), At(t, He()), !(6 & ce) && (To = He() + 500, jr())) } break; case 13: ki(function () { var r = cr(e, 1); if (r !== null) { var i = kt(); kn(r, e, 1, i) } }), bp(e, 1) } }; Nh = function (e) { if (e.tag === 13) { var t = cr(e, 134217728); if (t !== null) { var n = kt(); kn(t, e, 134217728, n) } bp(e, 134217728) } }; Yb = function (e) { if (e.tag === 13) { var t = Vr(e), n = cr(e, t); if (n !== null) { var r = kt(); kn(n, e, t, r) } bp(e, t) } }; Gb = function () { return me }; Kb = function (e, t) { var n = me; try { return me = e, t() } finally { me = n } }; eh = function (e, t, n) { switch (t) { case "input": if (Yd(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = Ec(r); if (!i) throw Error(L(90)); Eb(r), Yd(r, i) } } } break; case "textarea": Pb(e, n); break; case "select": t = n.value, t != null && ho(e, !!n.multiple, t, !1) } }; Db = pp; Ab = ki; var AF = { usingClientEntryPoint: !1, Events: [na, oo, Ec, Mb, Ob, pp] }, ws = { findFiberByHostInstance: pi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, VF = { bundleType: ws.bundleType, version: ws.version, rendererPackageName: ws.rendererPackageName, rendererConfig: ws.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: fr.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = $b(e), e === null ? null : e.stateNode }, findFiberByHostInstance: ws.findFiberByHostInstance || OF, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (ks = __REACT_DEVTOOLS_GLOBAL_HOOK__, !ks.isDisabled && ks.supportsFiber)) try { wc = ks.inject(VF), Nn = ks } catch { } var ks; Xt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = AF; Xt.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Sp(t)) throw Error(L(200)); return MF(e, t, null, n) }; Xt.createRoot = function (e, t) { if (!Sp(e)) throw Error(L(299)); var n = !1, r = "", i = b1; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = yp(e, 1, !1, null, null, n, !1, r, i), e[lr] = t.current, Us(e.nodeType === 8 ? e.parentNode : e), new xp(t) }; Xt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(L(188)) : (e = Object.keys(e).join(","), Error(L(268, e))); return e = $b(t), e = e === null ? null : e.stateNode, e }; Xt.flushSync = function (e) { return ki(e) }; Xt.hydrate = function (e, t, n) { if (!Dc(t)) throw Error(L(200)); return Ac(null, e, t, !0, n) }; Xt.hydrateRoot = function (e, t, n) { if (!Sp(e)) throw Error(L(405)); var r = n != null && n.hydratedSources || null, i = !1, o = "", s = b1; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), t = y1(t, null, e, 1, n ?? null, i, !1, o, s), e[lr] = t.current, Us(e), r) for (e = 0; e < r.length; e++)n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Oc(t) }; Xt.render = function (e, t, n) { if (!Dc(t)) throw Error(L(200)); return Ac(null, e, t, !1, n) }; Xt.unmountComponentAtNode = function (e) { if (!Dc(e)) throw Error(L(40)); return !!e._reactRootContainer && (ki(function () { Ac(null, null, e, !1, function () { e._reactRootContainer = null, e[lr] = null }) }), !0) }; Xt.unstable_batchedUpdates = pp; Xt.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Dc(n)) throw Error(L(200)); if (e == null || e._reactInternals === void 0) throw Error(L(38)); return Ac(e, t, n, !1, r) }; Xt.version = "18.2.0-next-9e3b772b8-20220608"; function x1() { if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE == "function") try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(x1) } catch (e) { console.error(e) } } x1(); var Gt = Xt, wp = Gt, BF = Gt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, $F = Gt.createPortal, zF = Gt.createRoot, NF = Gt.findDOMNode, HF = Gt.flushSync, jF = Gt.hydrate, WF = Gt.hydrateRoot, UF = Gt.render, XF = Gt.unmountComponentAtNode, YF = Gt.unstable_batchedUpdates, GF = Gt.unstable_renderSubtreeIntoContainer, KF = Gt.version; var QF = rn({ "../../../node_modules/hsluv/dist/hsluv.cjs"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Hsluv = void 0; var t = class { constructor() { this.hex = "#000000", this.rgb_r = 0, this.rgb_g = 0, this.rgb_b = 0, this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0, this.luv_l = 0, this.luv_u = 0, this.luv_v = 0, this.lch_l = 0, this.lch_c = 0, this.lch_h = 0, this.hsluv_h = 0, this.hsluv_s = 0, this.hsluv_l = 0, this.hpluv_h = 0, this.hpluv_p = 0, this.hpluv_l = 0, this.r0s = 0, this.r0i = 0, this.r1s = 0, this.r1i = 0, this.g0s = 0, this.g0i = 0, this.g1s = 0, this.g1i = 0, this.b0s = 0, this.b0i = 0, this.b1s = 0, this.b1i = 0 } static fromLinear(n) { return n <= .0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055 } static toLinear(n) { return n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92 } static yToL(n) { return n <= t.epsilon ? n / t.refY * t.kappa : 116 * Math.pow(n / t.refY, 1 / 3) - 16 } static lToY(n) { return n <= 8 ? t.refY * n / t.kappa : t.refY * Math.pow((n + 16) / 116, 3) } static rgbChannelToHex(n) { let r = Math.round(n * 255), i = r % 16, o = (r - i) / 16 | 0; return t.hexChars.charAt(o) + t.hexChars.charAt(i) } static hexToRgbChannel(n, r) { let i = t.hexChars.indexOf(n.charAt(r)), o = t.hexChars.indexOf(n.charAt(r + 1)); return (i * 16 + o) / 255 } static distanceFromOriginAngle(n, r, i) { let o = r / (Math.sin(i) - n * Math.cos(i)); return o < 0 ? 1 / 0 : o } static distanceFromOrigin(n, r) { return Math.abs(r) / Math.sqrt(Math.pow(n, 2) + 1) } static min6(n, r, i, o, s, a) { return Math.min(n, Math.min(r, Math.min(i, Math.min(o, Math.min(s, a))))) } rgbToHex() { this.hex = "#", this.hex += t.rgbChannelToHex(this.rgb_r), this.hex += t.rgbChannelToHex(this.rgb_g), this.hex += t.rgbChannelToHex(this.rgb_b) } hexToRgb() { this.hex = this.hex.toLowerCase(), this.rgb_r = t.hexToRgbChannel(this.hex, 1), this.rgb_g = t.hexToRgbChannel(this.hex, 3), this.rgb_b = t.hexToRgbChannel(this.hex, 5) } xyzToRgb() { this.rgb_r = t.fromLinear(t.m_r0 * this.xyz_x + t.m_r1 * this.xyz_y + t.m_r2 * this.xyz_z), this.rgb_g = t.fromLinear(t.m_g0 * this.xyz_x + t.m_g1 * this.xyz_y + t.m_g2 * this.xyz_z), this.rgb_b = t.fromLinear(t.m_b0 * this.xyz_x + t.m_b1 * this.xyz_y + t.m_b2 * this.xyz_z) } rgbToXyz() { let n = t.toLinear(this.rgb_r), r = t.toLinear(this.rgb_g), i = t.toLinear(this.rgb_b); this.xyz_x = .41239079926595 * n + .35758433938387 * r + .18048078840183 * i, this.xyz_y = .21263900587151 * n + .71516867876775 * r + .072192315360733 * i, this.xyz_z = .019330818715591 * n + .11919477979462 * r + .95053215224966 * i } xyzToLuv() { let n = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z, r = 4 * this.xyz_x, i = 9 * this.xyz_y; n !== 0 ? (r /= n, i /= n) : (r = NaN, i = NaN), this.luv_l = t.yToL(this.xyz_y), this.luv_l === 0 ? (this.luv_u = 0, this.luv_v = 0) : (this.luv_u = 13 * this.luv_l * (r - t.refU), this.luv_v = 13 * this.luv_l * (i - t.refV)) } luvToXyz() { if (this.luv_l === 0) { this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0; return } let n = this.luv_u / (13 * this.luv_l) + t.refU, r = this.luv_v / (13 * this.luv_l) + t.refV; this.xyz_y = t.lToY(this.luv_l), this.xyz_x = 0 - 9 * this.xyz_y * n / ((n - 4) * r - n * r), this.xyz_z = (9 * this.xyz_y - 15 * r * this.xyz_y - r * this.xyz_x) / (3 * r) } luvToLch() { if (this.lch_l = this.luv_l, this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v), this.lch_c < 1e-8) this.lch_h = 0; else { let n = Math.atan2(this.luv_v, this.luv_u); this.lch_h = n * 180 / Math.PI, this.lch_h < 0 && (this.lch_h = 360 + this.lch_h) } } lchToLuv() { let n = this.lch_h / 180 * Math.PI; this.luv_l = this.lch_l, this.luv_u = Math.cos(n) * this.lch_c, this.luv_v = Math.sin(n) * this.lch_c } calculateBoundingLines(n) { let r = Math.pow(n + 16, 3) / 1560896, i = r > t.epsilon ? r : n / t.kappa, o = i * (284517 * t.m_r0 - 94839 * t.m_r2), s = i * (838422 * t.m_r2 + 769860 * t.m_r1 + 731718 * t.m_r0), a = i * (632260 * t.m_r2 - 126452 * t.m_r1), l = i * (284517 * t.m_g0 - 94839 * t.m_g2), c = i * (838422 * t.m_g2 + 769860 * t.m_g1 + 731718 * t.m_g0), u = i * (632260 * t.m_g2 - 126452 * t.m_g1), f = i * (284517 * t.m_b0 - 94839 * t.m_b2), d = i * (838422 * t.m_b2 + 769860 * t.m_b1 + 731718 * t.m_b0), p = i * (632260 * t.m_b2 - 126452 * t.m_b1); this.r0s = o / a, this.r0i = s * n / a, this.r1s = o / (a + 126452), this.r1i = (s - 769860) * n / (a + 126452), this.g0s = l / u, this.g0i = c * n / u, this.g1s = l / (u + 126452), this.g1i = (c - 769860) * n / (u + 126452), this.b0s = f / p, this.b0i = d * n / p, this.b1s = f / (p + 126452), this.b1i = (d - 769860) * n / (p + 126452) } calcMaxChromaHpluv() { let n = t.distanceFromOrigin(this.r0s, this.r0i), r = t.distanceFromOrigin(this.r1s, this.r1i), i = t.distanceFromOrigin(this.g0s, this.g0i), o = t.distanceFromOrigin(this.g1s, this.g1i), s = t.distanceFromOrigin(this.b0s, this.b0i), a = t.distanceFromOrigin(this.b1s, this.b1i); return t.min6(n, r, i, o, s, a) } calcMaxChromaHsluv(n) { let r = n / 360 * Math.PI * 2, i = t.distanceFromOriginAngle(this.r0s, this.r0i, r), o = t.distanceFromOriginAngle(this.r1s, this.r1i, r), s = t.distanceFromOriginAngle(this.g0s, this.g0i, r), a = t.distanceFromOriginAngle(this.g1s, this.g1i, r), l = t.distanceFromOriginAngle(this.b0s, this.b0i, r), c = t.distanceFromOriginAngle(this.b1s, this.b1i, r); return t.min6(i, o, s, a, l, c) } hsluvToLch() { if (this.hsluv_l > 99.9999999) this.lch_l = 100, this.lch_c = 0; else if (this.hsluv_l < 1e-8) this.lch_l = 0, this.lch_c = 0; else { this.lch_l = this.hsluv_l, this.calculateBoundingLines(this.hsluv_l); let n = this.calcMaxChromaHsluv(this.hsluv_h); this.lch_c = n / 100 * this.hsluv_s } this.lch_h = this.hsluv_h } lchToHsluv() { if (this.lch_l > 99.9999999) this.hsluv_s = 0, this.hsluv_l = 100; else if (this.lch_l < 1e-8) this.hsluv_s = 0, this.hsluv_l = 0; else { this.calculateBoundingLines(this.lch_l); let n = this.calcMaxChromaHsluv(this.lch_h); this.hsluv_s = this.lch_c / n * 100, this.hsluv_l = this.lch_l } this.hsluv_h = this.lch_h } hpluvToLch() { if (this.hpluv_l > 99.9999999) this.lch_l = 100, this.lch_c = 0; else if (this.hpluv_l < 1e-8) this.lch_l = 0, this.lch_c = 0; else { this.lch_l = this.hpluv_l, this.calculateBoundingLines(this.hpluv_l); let n = this.calcMaxChromaHpluv(); this.lch_c = n / 100 * this.hpluv_p } this.lch_h = this.hpluv_h } lchToHpluv() { if (this.lch_l > 99.9999999) this.hpluv_p = 0, this.hpluv_l = 100; else if (this.lch_l < 1e-8) this.hpluv_p = 0, this.hpluv_l = 0; else { this.calculateBoundingLines(this.lch_l); let n = this.calcMaxChromaHpluv(); this.hpluv_p = this.lch_c / n * 100, this.hpluv_l = this.lch_l } this.hpluv_h = this.lch_h } hsluvToRgb() { this.hsluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb() } hpluvToRgb() { this.hpluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb() } hsluvToHex() { this.hsluvToRgb(), this.rgbToHex() } hpluvToHex() { this.hpluvToRgb(), this.rgbToHex() } rgbToHsluv() { this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHsluv() } rgbToHpluv() { this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHpluv() } hexToHsluv() { this.hexToRgb(), this.rgbToHsluv() } hexToHpluv() { this.hexToRgb(), this.rgbToHpluv() } }; e.Hsluv = t, t.hexChars = "0123456789abcdef", t.refY = 1, t.refU = .19783000664283, t.refV = .46831999493879, t.kappa = 903.2962962, t.epsilon = .0088564516, t.m_r0 = 3.240969941904521, t.m_r1 = -1.537383177570093, t.m_r2 = -.498610760293, t.m_g0 = -.96924363628087, t.m_g1 = 1.87596750150772, t.m_g2 = .041555057407175, t.m_b0 = .055630079696993, t.m_b1 = -.20397695888897, t.m_b2 = 1.056971514242878 } }), ZF = rn({ "../../../node_modules/eventemitter3/index.js"(e, t) { "use strict"; var n = Object.prototype.hasOwnProperty, r = "~"; function i() { } Object.create && (i.prototype = Object.create(null), new i().__proto__ || (r = !1)); function o(c, u, f) { this.fn = c, this.context = u, this.once = f || !1 } function s(c, u, f, d, p) { if (typeof f != "function") throw new TypeError("The listener must be a function"); var g = new o(f, d || c, p), v = r ? r + u : u; return c._events[v] ? c._events[v].fn ? c._events[v] = [c._events[v], g] : c._events[v].push(g) : (c._events[v] = g, c._eventsCount++), c } function a(c, u) { --c._eventsCount === 0 ? c._events = new i : delete c._events[u] } function l() { this._events = new i, this._eventsCount = 0 } l.prototype.eventNames = function () { var u = [], f, d; if (this._eventsCount === 0) return u; for (d in f = this._events) n.call(f, d) && u.push(r ? d.slice(1) : d); return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(f)) : u }, l.prototype.listeners = function (u) { var f = r ? r + u : u, d = this._events[f]; if (!d) return []; if (d.fn) return [d.fn]; for (var p = 0, g = d.length, v = new Array(g); p < g; p++)v[p] = d[p].fn; return v }, l.prototype.listenerCount = function (u) { var f = r ? r + u : u, d = this._events[f]; return d ? d.fn ? 1 : d.length : 0 }, l.prototype.emit = function (u, f, d, p, g, v) { var S = r ? r + u : u; if (!this._events[S]) return !1; var m = this._events[S], h = arguments.length, y, x; if (m.fn) { switch (m.once && this.removeListener(u, m.fn, void 0, !0), h) { case 1: return m.fn.call(m.context), !0; case 2: return m.fn.call(m.context, f), !0; case 3: return m.fn.call(m.context, f, d), !0; case 4: return m.fn.call(m.context, f, d, p), !0; case 5: return m.fn.call(m.context, f, d, p, g), !0; case 6: return m.fn.call(m.context, f, d, p, g, v), !0 }for (x = 1, y = new Array(h - 1); x < h; x++)y[x - 1] = arguments[x]; m.fn.apply(m.context, y) } else { var k = m.length, w; for (x = 0; x < k; x++)switch (m[x].once && this.removeListener(u, m[x].fn, void 0, !0), h) { case 1: m[x].fn.call(m[x].context); break; case 2: m[x].fn.call(m[x].context, f); break; case 3: m[x].fn.call(m[x].context, f, d); break; case 4: m[x].fn.call(m[x].context, f, d, p); break; default: if (!y) for (w = 1, y = new Array(h - 1); w < h; w++)y[w - 1] = arguments[w]; m[x].fn.apply(m[x].context, y) } } return !0 }, l.prototype.on = function (u, f, d) { return s(this, u, f, d, !1) }, l.prototype.once = function (u, f, d) { return s(this, u, f, d, !0) }, l.prototype.removeListener = function (u, f, d, p) { var g = r ? r + u : u; if (!this._events[g]) return this; if (!f) return a(this, g), this; var v = this._events[g]; if (v.fn) v.fn === f && (!p || v.once) && (!d || v.context === d) && a(this, g); else { for (var S = 0, m = [], h = v.length; S < h; S++)(v[S].fn !== f || p && !v[S].once || d && v[S].context !== d) && m.push(v[S]); m.length ? this._events[g] = m.length === 1 ? m[0] : m : a(this, g) } return this }, l.prototype.removeAllListeners = function (u) { var f; return u ? (f = r ? r + u : u, this._events[f] && a(this, f)) : (this._events = new i, this._eventsCount = 0), this }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = r, l.EventEmitter = l, typeof t < "u" && (t.exports = l) } }), em = rn({ "../../../node_modules/process/browser.js"(e, t) { var n = t.exports = {}, r, i; function o() { throw new Error("setTimeout has not been defined") } function s() { throw new Error("clearTimeout has not been defined") } (function () { try { typeof setTimeout == "function" ? r = setTimeout : r = o } catch { r = o } try { typeof clearTimeout == "function" ? i = clearTimeout : i = s } catch { i = s } })(); function a(m) { if (r === setTimeout) return setTimeout(m, 0); if ((r === o || !r) && setTimeout) return r = setTimeout, setTimeout(m, 0); try { return r(m, 0) } catch { try { return r.call(null, m, 0) } catch { return r.call(this, m, 0) } } } function l(m) { if (i === clearTimeout) return clearTimeout(m); if ((i === s || !i) && clearTimeout) return i = clearTimeout, clearTimeout(m); try { return i(m) } catch { try { return i.call(null, m) } catch { return i.call(this, m) } } } var c = [], u = !1, f, d = -1; function p() { !u || !f || (u = !1, f.length ? c = f.concat(c) : d = -1, c.length && g()) } function g() { if (!u) { var m = a(p); u = !0; for (var h = c.length; h;) { for (f = c, c = []; ++d < h;)f && f[d].run(); d = -1, h = c.length } f = null, u = !1, l(m) } } n.nextTick = function (m) { var h = new Array(arguments.length - 1); if (arguments.length > 1) for (var y = 1; y < arguments.length; y++)h[y - 1] = arguments[y]; c.push(new v(m, h)), c.length === 1 && !u && a(g) }; function v(m, h) { this.fun = m, this.array = h } v.prototype.run = function () { this.fun.apply(null, this.array) }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}; function S() { } n.on = S, n.addListener = S, n.once = S, n.off = S, n.removeListener = S, n.removeAllListeners = S, n.emit = S, n.prependListener = S, n.prependOnceListener = S, n.listeners = function (m) { return [] }, n.binding = function (m) { throw new Error("process.binding is not supported") }, n.cwd = function () { return "/" }, n.chdir = function (m) { throw new Error("process.chdir is not supported") }, n.umask = function () { return 0 } } }), JF = rn({ "../../../node_modules/@juggle/resize-observer/lib/exports/resize-observer.umd.js"(e, t) { (function (n, r) { typeof e == "object" && typeof t < "u" ? r(e) : typeof define == "function" && define.amd ? define(["exports"], r) : (n = typeof globalThis < "u" ? globalThis : n || self, r(n.ResizeObserver = {})) })(e, function (n) { "use strict"; var r = [], i = function () { return r.some(function (P) { return P.activeTargets.length > 0 }) }, o = function () { return r.some(function (P) { return P.skippedTargets.length > 0 }) }, s = "ResizeObserver loop completed with undelivered notifications.", a = function () { var P; typeof ErrorEvent == "function" ? P = new ErrorEvent("error", { message: s }) : (P = document.createEvent("Event"), P.initEvent("error", !1, !1), P.message = s), window.dispatchEvent(P) }, l; (function (P) { P.BORDER_BOX = "border-box", P.CONTENT_BOX = "content-box", P.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box" })(l || (l = {})); var c = function (P) { return Object.freeze(P) }, u = function () { function P(_, M) { this.inlineSize = _, this.blockSize = M, c(this) } return P }(), f = function () { function P(_, M, N, le) { return this.x = _, this.y = M, this.width = N, this.height = le, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, c(this) } return P.prototype.toJSON = function () { var _ = this, M = _.x, N = _.y, le = _.top, bt = _.right, et = _.bottom, ze = _.left, Qn = _.width, $t = _.height; return { x: M, y: N, top: le, right: bt, bottom: et, left: ze, width: Qn, height: $t } }, P.fromRect = function (_) { return new P(_.x, _.y, _.width, _.height) }, P }(), d = function (P) { return P instanceof SVGElement && "getBBox" in P }, p = function (P) { if (d(P)) { var _ = P.getBBox(), M = _.width, N = _.height; return !M && !N } var le = P, bt = le.offsetWidth, et = le.offsetHeight; return !(bt || et || P.getClientRects().length) }, g = function (P) { var _, M; if (P instanceof Element) return !0; var N = (M = (_ = P) === null || _ === void 0 ? void 0 : _.ownerDocument) === null || M === void 0 ? void 0 : M.defaultView; return !!(N && P instanceof N.Element) }, v = function (P) { switch (P.tagName) { case "INPUT": if (P.type !== "image") break; case "VIDEO": case "AUDIO": case "EMBED": case "OBJECT": case "CANVAS": case "IFRAME": case "IMG": return !0 }return !1 }, S = typeof window < "u" ? window : {}, m = new WeakMap, h = /auto|scroll/, y = /^tb|vertical/, x = /msie|trident/i.test(S.navigator && S.navigator.userAgent), k = function (P) { return parseFloat(P || "0") }, w = function (P, _, M) { return P === void 0 && (P = 0), _ === void 0 && (_ = 0), M === void 0 && (M = !1), new u((M ? _ : P) || 0, (M ? P : _) || 0) }, T = c({ devicePixelContentBoxSize: w(), borderBoxSize: w(), contentBoxSize: w(), contentRect: new f(0, 0, 0, 0) }), E = function (P, _) { if (_ === void 0 && (_ = !1), m.has(P) && !_) return m.get(P); if (p(P)) return m.set(P, T), T; var M = getComputedStyle(P), N = d(P) && P.ownerSVGElement && P.getBBox(), le = !x && M.boxSizing === "border-box", bt = y.test(M.writingMode || ""), et = !N && h.test(M.overflowY || ""), ze = !N && h.test(M.overflowX || ""), Qn = N ? 0 : k(M.paddingTop), $t = N ? 0 : k(M.paddingRight), Jr = N ? 0 : k(M.paddingBottom), Oi = N ? 0 : k(M.paddingLeft), Dk = N ? 0 : k(M.borderTopWidth), Ak = N ? 0 : k(M.borderRightWidth), Vk = N ? 0 : k(M.borderBottomWidth), Bk = N ? 0 : k(M.borderLeftWidth), Cm = Oi + $t, Tm = Qn + Jr, Ru = Bk + Ak, Pu = Dk + Vk, Em = ze ? P.offsetHeight - Pu - P.clientHeight : 0, Rm = et ? P.offsetWidth - Ru - P.clientWidth : 0, $k = le ? Cm + Ru : 0, zk = le ? Tm + Pu : 0, Ma = N ? N.width : k(M.width) - $k - Rm, Oa = N ? N.height : k(M.height) - zk - Em, Nk = Ma + Cm + Rm + Ru, Hk = Oa + Tm + Em + Pu, Pm = c({ devicePixelContentBoxSize: w(Math.round(Ma * devicePixelRatio), Math.round(Oa * devicePixelRatio), bt), borderBoxSize: w(Nk, Hk, bt), contentBoxSize: w(Ma, Oa, bt), contentRect: new f(Oi, Qn, Ma, Oa) }); return m.set(P, Pm), Pm }, I = function (P, _, M) { var N = E(P, M), le = N.borderBoxSize, bt = N.contentBoxSize, et = N.devicePixelContentBoxSize; switch (_) { case l.DEVICE_PIXEL_CONTENT_BOX: return et; case l.BORDER_BOX: return le; default: return bt } }, F = function () { function P(_) { var M = E(_); this.target = _, this.contentRect = M.contentRect, this.borderBoxSize = c([M.borderBoxSize]), this.contentBoxSize = c([M.contentBoxSize]), this.devicePixelContentBoxSize = c([M.devicePixelContentBoxSize]) } return P }(), B = function (P) { if (p(P)) return 1 / 0; for (var _ = 0, M = P.parentNode; M;)_ += 1, M = M.parentNode; return _ }, V = function () { var P = 1 / 0, _ = []; r.forEach(function (et) { if (et.activeTargets.length !== 0) { var ze = []; et.activeTargets.forEach(function ($t) { var Jr = new F($t.target), Oi = B($t.target); ze.push(Jr), $t.lastReportedSize = I($t.target, $t.observedBox), Oi < P && (P = Oi) }), _.push(function () { et.callback.call(et.observer, ze, et.observer) }), et.activeTargets.splice(0, et.activeTargets.length) } }); for (var M = 0, N = _; M < N.length; M++) { var le = N[M]; le() } return P }, K = function (P) { r.forEach(function (M) { M.activeTargets.splice(0, M.activeTargets.length), M.skippedTargets.splice(0, M.skippedTargets.length), M.observationTargets.forEach(function (le) { le.isActive() && (B(le.target) > P ? M.activeTargets.push(le) : M.skippedTargets.push(le)) }) }) }, Z = function () { var P = 0; for (K(P); i();)P = V(), K(P); return o() && a(), P > 0 }, j, ne = [], U = function () { return ne.splice(0).forEach(function (P) { return P() }) }, X = function (P) { if (!j) { var _ = 0, M = document.createTextNode(""), N = { characterData: !0 }; new MutationObserver(function () { return U() }).observe(M, N), j = function () { M.textContent = "" + (_ ? _-- : _++) } } ne.push(P), j() }, z = function (P) { X(function () { requestAnimationFrame(P) }) }, J = 0, ie = function () { return !!J }, se = 250, te = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, re = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"], Qt = function (P) { return P === void 0 && (P = 0), Date.now() + P }, fe = !1, Pt = function () { function P() { var _ = this; this.stopped = !0, this.listener = function () { return _.schedule() } } return P.prototype.run = function (_) { var M = this; if (_ === void 0 && (_ = se), !fe) { fe = !0; var N = Qt(_); z(function () { var le = !1; try { le = Z() } finally { if (fe = !1, _ = N - Qt(), !ie()) return; le ? M.run(1e3) : _ > 0 ? M.run(_) : M.start() } }) } }, P.prototype.schedule = function () { this.stop(), this.run() }, P.prototype.observe = function () { var _ = this, M = function () { return _.observer && _.observer.observe(document.body, te) }; document.body ? M() : S.addEventListener("DOMContentLoaded", M) }, P.prototype.start = function () { var _ = this; this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), re.forEach(function (M) { return S.addEventListener(M, _.listener, !0) })) }, P.prototype.stop = function () { var _ = this; this.stopped || (this.observer && this.observer.disconnect(), re.forEach(function (M) { return S.removeEventListener(M, _.listener, !0) }), this.stopped = !0) }, P }(), ee = new Pt, Zt = function (P) { !J && P > 0 && ee.start(), J += P, !J && ee.stop() }, hn = function (P) { return !d(P) && !v(P) && getComputedStyle(P).display === "inline" }, Kn = function () { function P(_, M) { this.target = _, this.observedBox = M || l.CONTENT_BOX, this.lastReportedSize = { inlineSize: 0, blockSize: 0 } } return P.prototype.isActive = function () { var _ = I(this.target, this.observedBox, !0); return hn(this.target) && (this.lastReportedSize = _), this.lastReportedSize.inlineSize !== _.inlineSize || this.lastReportedSize.blockSize !== _.blockSize }, P }(), Mi = function () { function P(_, M) { this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = _, this.callback = M } return P }(), pn = new WeakMap, Bt = function (P, _) { for (var M = 0; M < P.length; M += 1)if (P[M].target === _) return M; return -1 }, qn = function () { function P() { } return P.connect = function (_, M) { var N = new Mi(_, M); pn.set(_, N) }, P.observe = function (_, M, N) { var le = pn.get(_), bt = le.observationTargets.length === 0; Bt(le.observationTargets, M) < 0 && (bt && r.push(le), le.observationTargets.push(new Kn(M, N && N.box)), Zt(1), ee.schedule()) }, P.unobserve = function (_, M) { var N = pn.get(_), le = Bt(N.observationTargets, M), bt = N.observationTargets.length === 1; le >= 0 && (bt && r.splice(r.indexOf(N), 1), N.observationTargets.splice(le, 1), Zt(-1)) }, P.disconnect = function (_) { var M = this, N = pn.get(_); N.observationTargets.slice().forEach(function (le) { return M.unobserve(_, le.target) }), N.activeTargets.splice(0, N.activeTargets.length) }, P }(), Eu = function () { function P(_) { if (arguments.length === 0) throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present."); if (typeof _ != "function") throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function."); qn.connect(this, _) } return P.prototype.observe = function (_, M) { if (arguments.length === 0) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present."); if (!g(_)) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element"); qn.observe(this, _, M) }, P.prototype.unobserve = function (_) { if (arguments.length === 0) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present."); if (!g(_)) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element"); qn.unobserve(this, _) }, P.prototype.disconnect = function () { qn.disconnect(this) }, P.toString = function () { return "function ResizeObserver () { [polyfill code] }" }, P }(); n.ResizeObserver = Eu, n.ResizeObserverEntry = F, n.ResizeObserverSize = u, Object.defineProperty(n, "__esModule", { value: !0 }) }) } }), eI = rn({ "../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js"(e) { "use strict"; var t = typeof Symbol == "function" && Symbol.for, n = t ? Symbol.for("react.element") : 60103, r = t ? Symbol.for("react.portal") : 60106, i = t ? Symbol.for("react.fragment") : 60107, o = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, a = t ? Symbol.for("react.provider") : 60109, l = t ? Symbol.for("react.context") : 60110, c = t ? Symbol.for("react.async_mode") : 60111, u = t ? Symbol.for("react.concurrent_mode") : 60111, f = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, p = t ? Symbol.for("react.suspense_list") : 60120, g = t ? Symbol.for("react.memo") : 60115, v = t ? Symbol.for("react.lazy") : 60116, S = t ? Symbol.for("react.block") : 60121, m = t ? Symbol.for("react.fundamental") : 60117, h = t ? Symbol.for("react.responder") : 60118, y = t ? Symbol.for("react.scope") : 60119; function x(w) { if (typeof w == "object" && w !== null) { var T = w.$$typeof; switch (T) { case n: switch (w = w.type, w) { case c: case u: case i: case s: case o: case d: return w; default: switch (w = w && w.$$typeof, w) { case l: case f: case v: case g: case a: return w; default: return T } }case r: return T } } } function k(w) { return x(w) === u } e.AsyncMode = c, e.ConcurrentMode = u, e.ContextConsumer = l, e.ContextProvider = a, e.Element = n, e.ForwardRef = f, e.Fragment = i, e.Lazy = v, e.Memo = g, e.Portal = r, e.Profiler = s, e.StrictMode = o, e.Suspense = d, e.isAsyncMode = function (w) { return k(w) || x(w) === c }, e.isConcurrentMode = k, e.isContextConsumer = function (w) { return x(w) === l }, e.isContextProvider = function (w) { return x(w) === a }, e.isElement = function (w) { return typeof w == "object" && w !== null && w.$$typeof === n }, e.isForwardRef = function (w) { return x(w) === f }, e.isFragment = function (w) { return x(w) === i }, e.isLazy = function (w) { return x(w) === v }, e.isMemo = function (w) { return x(w) === g }, e.isPortal = function (w) { return x(w) === r }, e.isProfiler = function (w) { return x(w) === s }, e.isStrictMode = function (w) { return x(w) === o }, e.isSuspense = function (w) { return x(w) === d }, e.isValidElementType = function (w) { return typeof w == "string" || typeof w == "function" || w === i || w === u || w === s || w === o || w === d || w === p || typeof w == "object" && w !== null && (w.$$typeof === v || w.$$typeof === g || w.$$typeof === a || w.$$typeof === l || w.$$typeof === f || w.$$typeof === m || w.$$typeof === h || w.$$typeof === y || w.$$typeof === S) }, e.typeOf = x } }), tI = rn({ "../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(e, t) { "use strict"; t.exports = eI() } }), fu = rn({ "../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(e, t) { "use strict"; var n = tI(), r = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, i = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, o = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, s = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, a = {}; a[n.ForwardRef] = o, a[n.Memo] = s; function l(S) { return n.isMemo(S) ? s : a[S.$$typeof] || r } var c = Object.defineProperty, u = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, d = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, g = Object.prototype; function v(S, m, h) { if (typeof m != "string") { if (g) { var y = p(m); y && y !== g && v(S, y, h) } var x = u(m); f && (x = x.concat(f(m))); for (var k = l(S), w = l(m), T = 0; T < x.length; ++T) { var E = x[T]; if (!i[E] && !(h && h[E]) && !(w && w[E]) && !(k && k[E])) { var I = d(m, E); try { c(S, E, I) } catch { } } } } return S } t.exports = v } }), nI = rn({
    "../../../node_modules/archy/index.js"(e, t) {
        t.exports = function n(r, i, o) {
            i === void 0 && (i = ""), o || (o = {}); var s = function (u) { var f = { "\u2502": "|", "\u2514": "`", "\u251C": "+", "\u2500": "-", "\u252C": "-" }; return o.unicode === !1 ? f[u] : u }; typeof r == "string" && (r = { label: r }); var a = r.nodes || [], l = (r.label || "").split(`
`), c = `
`+ i + (a.length ? s("\u2502") : " ") + " "; return i + l.join(c) + `
`+ a.map(function (u, f) { var d = f === a.length - 1, p = u.nodes && u.nodes.length, g = i + (d ? " " : s("\u2502")) + " "; return i + s(d ? "\u2514" : "\u251C") + s("\u2500") + s(p ? "\u252C" : "\u2500") + " " + n(u, g, o).slice(i.length + 2) }).join("")
        }
    }
}), rI = rn({ "../../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js"(e, t) { (function () { function n(m, h) { document.addEventListener ? m.addEventListener("scroll", h, !1) : m.attachEvent("scroll", h) } function r(m) { document.body ? m() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function h() { document.removeEventListener("DOMContentLoaded", h), m() }) : document.attachEvent("onreadystatechange", function h() { (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", h), m()) }) } function i(m) { this.a = document.createElement("div"), this.a.setAttribute("aria-hidden", "true"), this.a.appendChild(document.createTextNode(m)), this.b = document.createElement("span"), this.c = document.createElement("span"), this.h = document.createElement("span"), this.f = document.createElement("span"), this.g = -1, this.b.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.c.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.f.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.h.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.b.appendChild(this.h), this.c.appendChild(this.f), this.a.appendChild(this.b), this.a.appendChild(this.c) } function o(m, h) { m.a.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + h + ";" } function s(m) { var h = m.a.offsetWidth, y = h + 100; return m.f.style.width = y + "px", m.c.scrollLeft = y, m.b.scrollLeft = m.b.scrollWidth + 100, m.g !== h ? (m.g = h, !0) : !1 } function a(m, h) { function y() { var k = x; s(k) && k.a.parentNode && h(k.g) } var x = m; n(m.b, y), n(m.c, y), s(m) } function l(m, h) { var y = h || {}; this.family = m, this.style = y.style || "normal", this.weight = y.weight || "normal", this.stretch = y.stretch || "normal" } var c = null, u = null, f = null, d = null; function p() { if (u === null) if (g() && /Apple/.test(window.navigator.vendor)) { var m = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent); u = !!m && 603 > parseInt(m[1], 10) } else u = !1; return u } function g() { return d === null && (d = !!document.fonts), d } function v() { if (f === null) { var m = document.createElement("div"); try { m.style.font = "condensed 100px sans-serif" } catch { } f = m.style.font !== "" } return f } function S(m, h) { return [m.style, m.weight, v() ? m.stretch : "", "100px", h].join(" ") } l.prototype.load = function (m, h) { var y = this, x = m || "BESbswy", k = 0, w = h || 3e3, T = new Date().getTime(); return new Promise(function (E, I) { if (g() && !p()) { var F = new Promise(function (V, K) { function Z() { new Date().getTime() - T >= w ? K(Error("" + w + "ms timeout exceeded")) : document.fonts.load(S(y, '"' + y.family + '"'), x).then(function (j) { 1 <= j.length ? V() : setTimeout(Z, 25) }, K) } Z() }), B = new Promise(function (V, K) { k = setTimeout(function () { K(Error("" + w + "ms timeout exceeded")) }, w) }); Promise.race([B, F]).then(function () { clearTimeout(k), E(y) }, I) } else r(function () { function V() { var re; (re = U != -1 && X != -1 || U != -1 && z != -1 || X != -1 && z != -1) && ((re = U != X && U != z && X != z) || (c === null && (re = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), c = !!re && (536 > parseInt(re[1], 10) || parseInt(re[1], 10) === 536 && 11 >= parseInt(re[2], 10))), re = c && (U == J && X == J && z == J || U == ie && X == ie && z == ie || U == se && X == se && z == se)), re = !re), re && (te.parentNode && te.parentNode.removeChild(te), clearTimeout(k), E(y)) } function K() { if (new Date().getTime() - T >= w) te.parentNode && te.parentNode.removeChild(te), I(Error("" + w + "ms timeout exceeded")); else { var re = document.hidden; (re === !0 || re === void 0) && (U = Z.a.offsetWidth, X = j.a.offsetWidth, z = ne.a.offsetWidth, V()), k = setTimeout(K, 50) } } var Z = new i(x), j = new i(x), ne = new i(x), U = -1, X = -1, z = -1, J = -1, ie = -1, se = -1, te = document.createElement("div"); te.dir = "ltr", o(Z, S(y, "sans-serif")), o(j, S(y, "serif")), o(ne, S(y, "monospace")), te.appendChild(Z.a), te.appendChild(j.a), te.appendChild(ne.a), document.body.appendChild(te), J = Z.a.offsetWidth, ie = j.a.offsetWidth, se = ne.a.offsetWidth, K(), a(Z, function (re) { U = re, V() }), o(Z, S(y, '"' + y.family + '",sans-serif')), a(j, function (re) { X = re, V() }), o(j, S(y, '"' + y.family + '",serif')), a(ne, function (re) { z = re, V() }), o(ne, S(y, '"' + y.family + '",monospace')) }) }) }, typeof t == "object" ? t.exports = l : (window.FontFaceObserver = l, window.FontFaceObserver.prototype.load = l.prototype.load) })() } }); function jp(e, t) { let n = { style: t }; return b.isValidElement(e) ? b.cloneElement(e, n) : b.createElement(e, n) } var iI = class extends Error { }, XS = class extends Error { }, oI = class extends ve { constructor(e) { super(e), this.state = { error: void 0, forceUpdateKey: e.forceUpdateKey } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { if (e.forceUpdateKey !== t.forceUpdateKey) { let n = { forceUpdateKey: e.forceUpdateKey }; return t.error && (n.error = void 0), n } return null } render() { if (this.state.error === void 0) return this.props.children; if (!(this.state.error instanceof iI)) { let n = new XS; throw n.cause = this.state.error, n } let { notFoundPage: e, defaultPageStyle: t } = this.props; if (!e) throw this.state.error; return jp(e, t) } }, sI = ":([a-z]\\w*)", _i = new RegExp(sI, "gi"); function YS(e, t) { return e.replace(_i, (n, r) => { let i = t[r]; return typeof i != "string" || i.length === 0 ? n : encodeURIComponent(i) }) } function GS(e, t) { if (!e.startsWith("/") || !t.startsWith("/")) throw new Error("from/to paths are expected to be absolute"); let [n] = S1(e), [r, i] = S1(t), o = aI(n, r); return o === "" && (o = "."), !o.startsWith(".") && !o.startsWith("/") && (o = "./" + o), o + "/" + i } function S1(e) { let t = e.lastIndexOf("/"); return [e.substring(0, t + 1), e.substring(t + 1)] } var kp = 46, Mo = 47, qr = (e, t) => e.charCodeAt(t), w1 = (e, t) => e.lastIndexOf(t), Do = (e, t, n) => e.slice(t, n); function aI(e, t) { if (e === t || (e = "/" + C1(e), t = "/" + C1(t), e === t)) return ""; let n = 1, r = e.length, i = r - n, o = 1, s = t.length - o, a = i < s ? i : s, l = -1, c = 0; for (; c < a; c++) { let f = qr(e, n + c); if (f !== qr(t, o + c)) break; f === Mo && (l = c) } if (c === a) if (s > a) { if (qr(t, o + c) === Mo) return Do(t, o + c + 1); if (c === 0) return Do(t, o + c) } else i > a && (qr(e, n + c) === Mo ? l = c : c === 0 && (l = 0)); let u = ""; for (c = n + l + 1; c <= r; ++c)(c === r || qr(e, c) === Mo) && (u += u.length === 0 ? ".." : "/.."); return `${u}${Do(t, o + l)}` } var lI = !1, Vc = "/", k1 = e => e === Mo; function C1(e) { let t = "", n = 0, r = -1, i = 0, o = 0; for (let s = 0; s <= e.length; ++s) { if (s < e.length) o = qr(e, s); else { if (k1(o)) break; o = Mo } if (k1(o)) { if (!(r === s - 1 || i === 1)) if (i === 2) { if (t.length < 2 || n !== 2 || qr(t, t.length - 1) !== kp || qr(t, t.length - 2) !== kp) { if (t.length > 2) { let a = w1(t, Vc); a === -1 ? (t = "", n = 0) : (t = Do(t, 0, a), n = t.length - 1 - w1(t, Vc)), r = s, i = 0; continue } else if (t.length !== 0) { t = "", n = 0, r = s, i = 0; continue } } lI && (t += t.length > 0 ? `${Vc}..` : "..", n = 2) } else t.length > 0 ? t += `${Vc}${Do(e, r + 1, s)}` : t = Do(e, r + 1, s), n = s - r - 1; r = s, i = 0 } else o === kp && i !== -1 ? ++i : i = -1 } return t } function KS(e) { let t = typeof window < "u" ? window.location.search : ""; return t ? cI(t, e) : e } function cI(e, t) { let n = t.indexOf("#"), r = n === -1 ? t : t.substring(0, n), i = n === -1 ? "" : t.substring(n), o = r.indexOf("?"); if (o === -1) return r + e + i; let s = new URLSearchParams(e), a = r.substring(o + 1), l = new URLSearchParams(a); for (let [c, u] of s) l.has(c) || l.append(c, u); return r.substring(0, o + 1) + l.toString() + i } function fa(e) { return typeof e == "object" && e !== null && !Array.isArray(e) } function Ao(e) { return typeof e == "string" } var uI = "preload"; function qS(e) { return typeof e == "object" && e !== null && !b.isValidElement(e) && uI in e } function Q$(e) { let t = b.lazy(e), n, r, i = b.forwardRef(function (s, a) { return b.createElement(r ?? t, a ? { ref: a, ...s } : s) }); return i.preload = () => (n || (n = e().then(o => (r = o.default, r))), n), i } function tm(e, t) { if (t && e) return e.elements && t in e.elements ? e.elements[t] : t } function fI(e) { return /bot|Mediapartners-Google|Google-PageRenderer|yandex|ia_archiver/iu.test(e) } function dI(e) { if ("scheduler" in window) { let t = { priority: e ? "user-blocking" : "user-visible" }; if ("yield" in scheduler) return scheduler.yield(t); if ("postTask" in scheduler) return scheduler.postTask(() => { }, t) } return e ? Promise.resolve() : new Promise(t => { setTimeout(t, 0) }) } async function hI(e, t, n, r, i, o, s) { var a, l, c; let u = e, f = !1, d = { ...o }, p = Array.from(u.matchAll(_i)), g = await Promise.all(p.map(async h => { var y; let x = h?.[0], k = h?.[1]; if (!x || !k) throw new Error("Failed to replace path variables: unexpected regex match group"); let w = o[k]; if (!w || !Ao(w)) throw new Error(`No slug found for path variable ${k}`); let T = await ((y = s?.[i]) === null || y === void 0 ? void 0 : y.call(s)); if (!T || !t) return w; let E = await T.getRecordIdBySlug(w, t); if (!E) return w; let I = await T.getSlugByRecordId(E, n); if (!I) { f = !0; let F = await T.getSlugByRecordId(E, r); return F && (d[k] = F), F ?? w } return d[k] = I, I })), v = 0, S = "", m = !1; for (let h = 0; h < p.length; h++) { let y = p[h], x = g[h]; !y || !x || (S += u.substring(v, y.index), v = ((a = y.index) !== null && a !== void 0 ? a : 0) + ((c = (l = y[0]) === null || l === void 0 ? void 0 : l.length) !== null && c !== void 0 ? c : 0), S += g[h], m = !0) } return m && (u = S), { path: u, pathVariables: d, isMissingInLocale: f } } async function pI({ currentLocale: e, nextLocale: t, defaultLocale: n, route: r, pathVariables: i, collectionUtils: o, preserveQueryParams: s }) { let { path: a } = r, l = { path: a, pathVariables: i, isMissingInLocale: !1 }; if (!a) return l; if (i && r.collectionId) try { l = await hI(a, e, t, n, r.collectionId, i, o) } catch { } return t.slug && (l.path = "/" + t.slug + l.path), s && l.path && (l.path = KS(l.path)), l } function mI(e, t, { global: n, routes: r }) { var i; return ((i = r[e]) === null || i === void 0 ? void 0 : i[t]) || n } var vI = { global: void 0, routes: {} }, QS = b.createContext(vI); function tz({ children: e, value: t }) { return C(QS.Provider, { value: t, children: e }) } function gI() { return b.useContext(QS) } var Cp = 10, yI = 1e4; function bI(e) { let t = Cp, n = e.next(0), r = [n.value]; for (; !n.done && t < yI;)n = e.next(t), r.push(n.value), t += Cp; return r.length === 1 && r.push(n.value), { easing: `linear(${r.join(",")})`, duration: t - Cp } } var pr = e => `--view-transition-${e}`; function Wp(e) { return [parseFloat(e), e.endsWith("px") ? "px" : "%"] } function ZS(e) { let { innerWidth: t, innerHeight: n } = window, [r, i] = Wp(e.x), [o, s] = Wp(e.y); return { x: i === "px" ? r : t * (r / 100), y: s === "px" ? o : n * (o / 100) } } var xI = {
    makeKeyframe: (e, t, n) => { let r = 0; return (n === "exit" && e.angularDirection === "clockwise" && t === "start" || n === "exit" && e.angularDirection === "counter-clockwise" && t === "end" || n === "enter" && e.angularDirection === "counter-clockwise" && t === "start" || n === "enter" && e.angularDirection === "clockwise" && t === "end") && (r = e.sweepAngle / 360 * 100), `${pr("conic-offset")}: ${r}%;` }, makeStyles: (e, t) => { let n = `var(${pr("conic-offset")})`, r = t === "exit" && e.angularDirection === "clockwise" || t === "enter" && e.angularDirection === "counter-clockwise", i = r ? "transparent" : "black", o = r ? "black" : "transparent", s = "conic-gradient(from "; return s += `${e.angle}deg at ${e.x} ${e.y}, `, s += `${i} 0%, ${i} ${n}, `, s += `${o} ${n}, ${o} 100%)`, `mask-image: ${s}; -webkit-mask-image: ${s};` }, makePropertyRules: () => `
        @property ${pr("conic-offset")} {
            syntax: '<percentage>';
            initial-value: 0%;
            inherits: false;
        }
    `}, SI = { makeKeyframe: (e, t) => { let { x: n, y: r } = ZS(e); return t === "start" ? `clip-path: circle(0 at ${n}px ${r}px);` : `clip-path: circle(${Math.hypot(Math.max(n, window.innerWidth - n), Math.max(r, window.innerHeight - r))}px at ${n}px ${r}px);` } }, wI = { makeKeyframe: (e, t) => { let { x: n, y: r } = ZS(e), i = window.innerHeight - r, o = window.innerWidth - n; return t === "start" ? `clip-path: inset(${r}px ${o}px ${i}px ${n}px round ${e.round}px);` : "clip-path: inset(0 round 0);" } }, kI = {
        makeKeyframe: (e, t, n) => { let [, r] = Wp(e.width), i = `0${r}`; return (t === "start" && n === "exit" || t === "end" && n === "enter") && (i = e.width), `${pr("blinds-width")}: ${i};` }, makeStyles: (e, t) => { let n = `var(${pr("blinds-width")})`, r = t === "exit" ? "transparent" : "black", i = t === "exit" ? "black" : "transparent", o = "repeating-linear-gradient("; return o += e.angle + 90 + "deg, ", o += `${r} 0px, ${r} ${n}, `, o += `${i} ${n}, ${i} ${e.width})`, `mask-image: ${o}; -webkit-mask-image: ${o};` }, makePropertyRules: () => `
            @property ${pr("blinds-width")} {
                syntax: '<length-percentage>';
                initial-value: 0px;
                inherits: false;
            }
        `}, CI = {
        makeKeyframe: (e, t, n) => { let r = t === "start" && n === "exit" || t === "end" && n === "enter" ? 1 : 0; return `${pr("wipe-offset")}: ${r};` }, makeStyles: (e, t) => { let n = `var(${pr("wipe-offset")})`, r = t === "exit" ? "transparent" : "black", i = t === "exit" ? "black" : "transparent", o = "linear-gradient("; return o += e.angle + 90 + "deg, ", o += `${r} calc(calc(0% - ${e.width}) + calc(calc(100% + ${e.width}) * ${n})), `, o += `${i} calc(calc(100% + ${e.width}) * ${n}))`, `mask-image: ${o}; -webkit-mask-image: ${o};` }, makePropertyRules: () => `
            @property ${pr("wipe-offset")} {
                syntax: '<number>';
                initial-value: 0;
                inherits: false;
            }
        `}, TI = { circle: SI, conic: xI, inset: wI, blinds: kI, wipe: CI }, EI = { opacity: 1, x: "0px", y: "0px", scale: 1, rotate: 0, rotateX: 0, rotateY: 0, mask: void 0 }; function T1(e, t, n, r) {
    var i; let o = `
      opacity: ${e.opacity};
      transform: translate(${e.x}, ${e.y}) scale(${e.scale}) rotateX(${e.rotateX}deg) rotateY(${e.rotateY}deg) rotateZ(${e.rotate}deg);
    `; return e.mask && (o += ((i = r?.makeKeyframe) === null || i === void 0 ? void 0 : i.call(r, e.mask, t, n)) || ""), o
} function RI(e) { return e ? TI[e] : void 0 } function E1(e, { transition: t, ...n }) {
    var r; let i = "view-transition-" + e, o = { duration: "0s", easing: "linear" }; if (t.type === "tween") o.duration = t.duration + "s", o.easing = `cubic-bezier(${t.ease.join(",")})`; else if (t.type === "spring") { let { easing: c, duration: u } = bI(fs({ keyframes: [0, 1], stiffness: t.stiffness, damping: t.damping, mass: t.mass, restDelta: .001, restSpeed: 1e-4 })); o.duration = u + "ms", o.easing = c } let s = RI((r = n?.mask) === null || r === void 0 ? void 0 : r.type), a = T1(n, "start", e, s), l = T1({ ...EI, mask: n.mask }, "end", e, s); return e === "exit" && ([a, l] = [l, a]), `
        ${n.mask && s?.makePropertyRules ? s.makePropertyRules(n.mask) : ""}

        @keyframes ${i} {
            0% {
                ${a}
            }

            100% {
                ${l}
            }
        }

        ::view-transition-${e === "enter" ? "new" : "old"}(root) {
            animation-name: ${i};
            animation-duration: ${o.duration};
            animation-delay: ${t.delay}s;
            animation-timing-function: ${o.easing};
            animation-fill-mode: both;
            ${n.mask && s?.makeStyles ? s.makeStyles(n.mask, e) : ""}
        }
    `} var JS = "view-transition-styles", PI = { x: "0px", y: "0px", scale: 1, opacity: 1, rotate3d: !1, rotate: 0, rotateX: 0, rotateY: 0, mask: void 0, transition: { type: "tween", delay: 0, duration: .2, ease: [.27, 0, .51, 1], stiffness: 400, damping: 30, mass: 1 } }; function _I({ exit: e = PI, enter: t }) {
    let n = document.createElement("style"); n.id = JS; let r = `
        @media (prefers-reduced-motion) {
            ::view-transition-group(*),
            ::view-transition-old(*),
            ::view-transition-new(*) {
                animation: none !important;
            }
        }
    `; (e.mask || t.mask || e.opacity || t.opacity || e.transition.delay || t.transition.delay) && (r += `
            ::view-transition-old(*),
            ::view-transition-new(*) {
                mix-blend-mode: normal;
            }
        `), r += `
        ::view-transition-old(*),
        ::view-transition-new(*) {
            backface-visibility: hidden;
        }
    `, r += E1("exit", e), r += E1("enter", t), n.textContent = r, document.head.appendChild(n)
} function FI() { Y.render(() => { let e = document.getElementById(JS); e && document.head.removeChild(e) }) } function II() { return !!document.startViewTransition } function LI(e, t) { if (!II()) return void e(); _I(t); let n = document.startViewTransition(e); return Promise.all([n.ready, n.finished]).then(FI).catch(() => { }), n } function ew() { let e = gI(), t = D(void 0); return H(() => { t.current && (t.current(), t.current = void 0) }), pe((n, r, i) => { let o = mI(n, r, e); if (o) { let s = new Promise(l => { t.current = l }); return LI(async () => { i(), await s }, o) } else return i() }, [e]) } function R1(e, t, { currentRoutePath: n, currentPathVariables: r, hash: i, pathVariables: o, localeId: s, preserveQueryParams: a }) { let { path: l } = t; if (l) try { let c = Ca(t, { currentRoutePath: n, currentPathVariables: r, hash: i, pathVariables: o, preserveQueryParams: a }); nw({ routeId: e, hash: i, pathVariables: o, localeId: s }, c) } catch { } } function MI(e) { let t = "routeId"; return fa(e) && Ao(e[t]) } function tw(e, t) { window.history.replaceState(e, "", t) } function nw(e, t) { window.history.pushState(e, "", t) } function OI({ disabled: e, routeId: t, initialPathVariables: n, initialLocaleId: r }) { b.useLayoutEffect(() => { e || tw({ routeId: t, pathVariables: n, localeId: r }) }, []) } function DI(e, t) { let n = ew(), r = b.useRef(void 0), i = b.useCallback(({ state: s }) => { var a, l, c; if (!fa(s)) return; let { routeId: u, hash: f, pathVariables: d, localeId: p } = s; if (!Ao(u)) return; let g = () => { t(u, Ao(p) ? p : void 0, Ao(f) ? f : void 0, fa(d) ? d : void 0, !1, !0) }, v = n(e.current, u, g); v ? v.updateCallbackDone.then((a = r.current) === null || a === void 0 ? void 0 : a.resolve).catch((l = r.current) === null || l === void 0 ? void 0 : l.reject) : (c = r.current) === null || c === void 0 || c.resolve() }, [e, t, n]), o = pe(s => { s.navigationType === "traverse" && s.intercept({ async handler() { await new Promise((a, l) => { r.current = { resolve: a, reject: l } }) }, scroll: "after-transition" }) }, []); b.useEffect(() => { var s; return window.addEventListener("popstate", i), (s = window.navigation) === null || s === void 0 || s.addEventListener("navigate", o), () => { var a; window.removeEventListener("popstate", i), (a = window.navigation) === null || a === void 0 || a.removeEventListener("navigate", o) } }, [i, o]) } function AI(e, t, n) { let r = tm(t, e); if (!r) return; let i = Object.assign({}, t?.elements, n); return r.replace(_i, (o, s) => { var a; return String((a = i[s]) !== null && a !== void 0 ? a : o) }) } function Ca(e, { currentRoutePath: t, currentPathVariables: n, hash: r, pathVariables: i, hashVariables: o, relative: s = !0, preserveQueryParams: a }) { var l; let c = t ?? "/"; n && (c = c.replace(_i, (g, v) => String(n[v] || g))); let f = (l = e?.path) !== null && l !== void 0 ? l : "/"; i && (f = f.replace(_i, (g, v) => String(i[v] || g))); let d = AI(r, e, o), p = c === f && d; return s && (f = GS(c, f)), (a || p) && (f = KS(f)), d && (f = `${f}#${d}`), f } async function VI(e, t, n) { if (!e.path || !t) return !1; let i = `${n.slug ? `/${n.slug}` : ""}${YS(e.path, t)}`; return (await fetch(i, { method: "HEAD", redirect: "manual" })).type === "opaqueredirect" ? (window.location.href = window.location.origin + i, !0) : !1 } async function BI(e) { let t = await pI(e); if (t) { try { localStorage.setItem("preferredLocale", e.nextLocale.code) } catch { } try { if (typeof t.path != "string") throw new Error("Expected result.path to be a string"); if (t.isMissingInLocale && await VI(e.route, t.pathVariables, e.nextLocale)) return; nw({ routeId: e.routeId, pathVariables: t.pathVariables, localeId: e.nextLocale.id, paginationInfo: window.history.state.paginationInfo }, t.path) } catch { } return t } } function $I(e, t) { try { let n = window.history.state; if (!MI(n)) return; let r = { ...n.paginationInfo, [e]: t }; tw({ ...n, paginationInfo: r }) } catch { } } function zI(e, t) { if (e.routeId !== t.routeId) return !1; if (e.pathVariables === t.pathVariables) return !0; let n = e.pathVariables || {}, r = t.pathVariables || {}; return n.length === r.length && Object.keys(n).every(i => n[i] === r[i]) } var aa = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset"], rw = e => { var t, n; !((n = (t = e.target) === null || t === void 0 ? void 0 : t.closest) === null || n === void 0) && n.call(t, "#main") && (e.stopPropagation(), performance.mark("framer-react-event-handling-prevented")) }; typeof window < "u" && (window.__FRAMER_TURN_OFF_REACT_EVENT_HANDLING__ = function () { if (!aa) return; let e = { capture: !0 }; aa.forEach(t => document.body.addEventListener(t, rw, e)), window.__FRAMER_TURN_OFF_REACT_EVENT_HANDLING__ = void 0 }); function P1() { if (!aa) return; let e = { capture: !0 }; aa.forEach(t => document.body.removeEventListener(t, rw, e)), aa = void 0 } function Po(e, t, n) { try { performance.measure(e, t, n) } catch (r) { console.warn(`Could not measure ${e}`, r) } } var _1 = !1, F1 = !1, I1 = !1; function NI({ addHydrationMarkers: e, turnOffEventHandlerHack: t }) { let n = "framer-hydration-", r = `${n}start`, i = `${n}render-end`, o = `${n}layout-effects-end`, s = `${n}effects-end`, a = `${n}first-paint`; return ct(() => { F1 || (F1 = !0, e && (performance.mark(i), Po(`${n}render`, r, i))) }, []), Pn(() => { I1 || (I1 = !0, e && (performance.mark(o), Po(`${n}layout-effects`, i, o)), requestAnimationFrame(() => { var l, c, u; let f = `${n}browser-render-start`; e && (performance.mark(f), Po(`${n}uho`, (c = (l = performance.getEntriesByName(s)[0]) === null || l === void 0 ? void 0 : l.name) !== null && c !== void 0 ? c : (u = performance.getEntriesByName(o)[0]) === null || u === void 0 ? void 0 : u.name, f)), setTimeout(() => { t && P1(), e && (performance.mark(a), Po(`${n}time-to-first-paint`, r, a), Po(`${n}browser-render`, f, a)) }, 0) })) }, []), H(() => { var l, c, u; _1 || (_1 = !0, t && P1(), e && (performance.mark(s), Po(`${n}effects`, (c = (l = performance.getEntriesByName(a)[0]) === null || l === void 0 ? void 0 : l.name) !== null && c !== void 0 ? c : (u = performance.getEntriesByName(o)[0]) === null || u === void 0 ? void 0 : u.name, s))) }, []), null } function iw(e) { return b.useCallback(t => e[t], [e]) } var nm = (() => b.createContext({}))(); function HI({ api: e, children: t }) { return C(nm.Provider, { value: e, children: t }) } function Ta() { return b.useContext(nm) } function jI({ routes: e, children: t }) { let n = iw(e); return C(nm.Provider, { value: { getRoute: n }, children: t }) } var WI = class extends ve { constructor() { super(...arguments), this.state = { error: void 0 } } static getDerivedStateFromError(e) { return console.error("Derived error in SuspenseErrorBoundary", e), { error: e } } componentDidCatch(e, t) { var n; console.error("Caught error in SuspenseErrorBoundary", e, t), (n = window.__framer_events) === null || n === void 0 || n.push(["published_site_load_recoverable_error", { message: String(e), componentStack: t?.componentStack }]) } render() { if (this.state.error === void 0) return this.props.children; if (this.state.error instanceof XS) throw this.state.error.cause; return C(Xo, { children: this.props.fallbackChildren }) } }, UI = (() => typeof window < "u" ? new Promise(() => { }) : null)(); function XI() { if (typeof window > "u") return null; throw UI } function YI({ children: e }) { return C(WI, { fallbackChildren: e, children: C(Xo, { fallback: C(XI, {}), children: e }) }) } var L1 = "default"; function GI() { let [e, t] = b.useState(0); return [e, b.useCallback(() => t(n => n + 1), [])] } var KI = async () => { }, qI = { activeLocale: null, locales: [], setLocale: KI }, ow = b.createContext(qI); function du() { return b.useContext(ow) } function dz() { var e, t; return (t = (e = du().activeLocale) === null || e === void 0 ? void 0 : e.code) !== null && t !== void 0 ? t : "en-US" } function QI(e) { let t = `start-${e}`, n = `end-${e}`, r = D(void 0); return H(() => { r.current && (r.current(), r.current = void 0) }), pe(() => { let i = new Promise(o => { r.current = o }); performance.mark(t), i.then(() => { performance.mark(n), performance.measure(e, t, n) }).catch(() => { }) }, [e, t, n]) } function M1(e, t, n) { let r = e && document.getElementById(e); if (r) { eL(r, t); return } n || window.scrollTo(0, 0) } function ZI(e) { let t = b.useRef([]); return b.useLayoutEffect(() => { var n; !((n = t.current) === null || n === void 0) && n.length && (t.current.forEach(r => r()), t.current = []) }, [e]), b.useCallback(n => { t.current.push(n) }, []) } function JI({ defaultPageStyle: e, disableHistory: t, initialPathVariables: n, initialRoute: r, notFoundPage: i, collectionUtils: o, routes: s, initialLocaleId: a, locales: l = [], preserveQueryParams: c = !1, enableImproveInpDuringHydration: u = !1, addHydrationMarkers: f = !1 }) { OI({ disabled: t, routeId: r, initialPathVariables: n, initialLocaleId: a }); let d = ew(), p = QI("route-change"), g = b.useRef(r), v = b.useRef(n), S = b.useRef(a), m = S.current, h = b.useMemo(() => { var U; return (U = l.find(({ id: X }) => m ? X === m : X === L1)) !== null && U !== void 0 ? U : null }, [m, l]), [y, x] = GI(), k = b.useMemo(() => ({ activeLocale: h, locales: l, setLocale: async U => { let X; Ao(U) ? X = U : fa(U) && (X = U.id); let z = l.find(({ id: te }) => te === L1), J = l.find(({ id: te }) => te === X); if (!J) return; let ie = g.current, se = s[ie]; if (se) try { let te = await BI({ currentLocale: h, nextLocale: J, route: se, routeId: ie, defaultLocale: z, pathVariables: v.current, collectionUtils: o, preserveQueryParams: c }); if (!te) return; v.current = te.pathVariables, S.current = J.id, d(g.current, ie, () => Ai(x)), p() } catch { } } }), [h, o, x, l, p, c, s, d]), w = ZI(y), T = b.useCallback((U, X, z, J, ie = !1, se = !1) => { g.current = U, v.current = J, S.current = X, w(() => { M1(z, ie, se) }), Ai(x), p() }, [x, p, w]); DI(g, T); let E = b.useCallback((U, X, z, J) => { var ie, se; let te = s[U]; if (z) { let fe = new Set, Pt = (ie = te?.path) !== null && ie !== void 0 ? ie : "/"; for (let ee of Pt.matchAll(_i)) { let Zt = ee[1]; if (Zt === void 0) throw new Error("A matching path variable should not be undefined"); fe.add(Zt) } z = Object.fromEntries(Object.entries(z).filter(([ee]) => fe.has(ee))) } let re = tm(te, X); if (zI({ routeId: g.current, pathVariables: v.current }, { routeId: U, pathVariables: z })) { if (((se = window.history.state) === null || se === void 0 ? void 0 : se.hash) !== X && !t) { let fe = s[U]; fe && R1(U, fe, { currentRoutePath: fe.path, currentPathVariables: v.current, pathVariables: z, hash: X, localeId: S.current, preserveQueryParams: c }) } M1(re, J, !1); return } if (!te) return; if (!t) { let fe = s[g.current]; R1(U, te, { currentRoutePath: fe?.path, currentPathVariables: v.current, hash: X, pathVariables: z, localeId: S.current, preserveQueryParams: c }) } let Qt = () => T(U, S.current, re, z, J, !1); d(g.current, U, Qt) }, [s, t, T, d, c]), I = iw(s), F = g.current, B = v.current, V = b.useMemo(() => ({ navigate: E, getRoute: I, currentRouteId: F, currentPathVariables: B, routes: s, collectionUtils: o, preserveQueryParams: c }), [E, I, F, B, s, o, c]), K = s[g.current]; if (!K) throw new Error(`Router cannot find route for ${g.current}`); let Z = !h || !K.includedLocales || K.includedLocales.includes(h.id), j = K.path && B ? YS(K.path, B) : K.path, ne = String(m) + j; return C(HI, { api: V, children: C(ow.Provider, { value: k, children: ae(YI, { children: [C(oI, { notFoundPage: i, defaultPageStyle: e, forceUpdateKey: y, children: C(b.Fragment, { children: Z ? jp(K.page, e) : i && jp(i, e) }, ne) }), C(NI, { addHydrationMarkers: f, turnOffEventHandlerHack: u })] }) }) }) } function eL(e, t) { let n = t ? { behavior: "smooth", block: "start", inline: "nearest" } : void 0; e.scrollIntoView(n) } var Bc, Tp, O1; function tL(e) { if (O1 !== e) { Bc = {}; for (let [t, { path: n }] of Object.entries(e)) n && (Bc[n] = { path: n, depth: nL(n), routeId: t }); Tp = Object.values(Bc), Tp.sort(({ depth: t }, { depth: n }) => n - t), O1 = e } return [Bc, Tp] } function sw(e, t, n = !0, r = []) { let [i, o] = tL(e), s, a, l = t; if (r.length > 0) { let d = l.split("/").find(Boolean); if (d && (s = r.find(({ slug: p }) => p === d), s && (a = s.id, l = l.substring(s.slug.length + 1))), !a) { let p = r.find(({ slug: g }) => g === ""); p && (a = p.id) } } let c = i[l]; if (c) { let d = D1(l, c.path); if (d.isMatch) return { routeId: c.routeId, localeId: a, pathVariables: d.pathVariables } } for (let { path: d, routeId: p } of o) { let g = D1(l, d); if (g.isMatch) return { routeId: p, localeId: a, pathVariables: g.pathVariables } } if (!n) throw new Error("No exact match found for path"); let u = i["/"]; if (u) return { routeId: u.routeId, localeId: a }; let f = Object.keys(e)[0]; if (!f) throw new Error("Router should not have undefined routes"); return { routeId: f, localeId: a } } function nL(e) { let t = e.replace(/^\/|\/$/gu, ""); return t === "" ? 0 : t.split("/").length } function D1(e, t) { let n = [], i = rL(t).replace(_i, (c, u) => (n.push(u), "([^/]+)")), o = new RegExp(i + "$"), s = e.match(o); if (!s) return { isMatch: !1 }; if (s.length === 1) return { isMatch: !0 }; let a = {}, l = s.slice(1); for (let c = 0; c < n.length; ++c) { let u = n[c]; if (u === void 0) continue; let f = l[c], d = a[u]; if (d) { if (d !== f) return { isMatch: !1 }; continue } if (f === void 0) throw new Error("Path variable values cannot be undefined"); a[u] = f } return { isMatch: !0, pathVariables: a } } function rL(e) { return e.replace(/[|\\{}()[\]^$+*?.]/gu, "\\$&").replace(/-/gu, "\\x2d") } var iL = "page"; function A1(e) { return fa(e) && iL in e && e.page !== void 0 } var oL = (() => b.createContext(void 0))(); function hu() { var e; let t = Ta(), n = O(oL), r = n ?? t.currentRouteId; if (!r) return; let i = (e = t.getRoute) === null || e === void 0 ? void 0 : e.call(t, r); if (i) return { ...i, id: r, pathVariables: n ? void 0 : t.currentPathVariables } } function gz() { var e; return (e = hu()) === null || e === void 0 ? void 0 : e.pathVariables } var rm = (() => typeof window < "u" && !fI(navigator.userAgent))(); function sL(e, t = !0) { let { getRoute: n } = Ta(); H(() => { if (!(!n || !t || !rm)) for (let r of e) aw(n(r)) }, [e, n, t]) } async function aw(e) { if (!rm || !e) return; let t = e.page; if (!(!t || !qS(t))) { await dI(); try { await t.preload() } catch { } } } var V1 = new Set; function da(e, ...t) { V1.has(e) || (V1.add(e), console.warn(e, ...t)) } function aL(e, t, n) { let r = n ? `, use ${n} instead` : "", i = `Deprecation warning: ${e} will be removed in version ${t}${r}.`; da(i) } var lw = class { constructor() { R(this, "observers", new Set), R(this, "transactions", {}) } add(e) { this.observers.add(e); let t = !1; return () => { t || (t = !0, this.remove(e)) } } remove(e) { this.observers.delete(e) } notify(e, t) { if (t) { let n = this.transactions[t] || e; n.value = e.value, this.transactions[t] = n } else this.callObservers(e) } finishTransaction(e) { let t = this.transactions[e]; return delete this.transactions[e], this.callObservers(t, e) } callObservers(e, t) { let n = []; return new Set(this.observers).forEach(r => { typeof r == "function" ? r(e, t) : (r.update(e, t), n.push(r.finish)) }), n } }, Ke = (() => { function e(t) { return aL("Animatable()", "2.0.0", "the new animation API (https://www.framer.com/api/animation/)"), Tn(t) ? t : new cL(t) } return e.transaction = t => { let n = Math.random(), r = new Set; t((s, a) => { s.set(a, n), r.add(s) }, n); let o = []; r.forEach(s => { o.push(...s.finishTransaction(n)) }), o.forEach(s => { s(n) }) }, e.getNumber = (t, n = 0) => e.get(t, n), e.get = (t, n) => t == null ? n : Tn(t) ? t.get() : t, e.objectToValues = t => { if (!t) return t; let n = {}; for (let r in t) { let i = t[r]; Tn(i) ? n[r] = i.get() : n[r] = i } return n }, e })(), B1 = "onUpdate", $1 = "finishTransaction"; function Tn(e) { return e !== null && typeof e == "object" && B1 in e && e[B1] instanceof Function && $1 in e && e[$1] instanceof Function } function lL(e, t) { return { interpolate(n, r) { let i = n.get(), o = r.get(), s = Ke(i); return a => { let l = t.interpolate(i, o)(a); return s.set(l), s } }, difference(n, r) { let i = n.get(); return t.difference(i, r.get()) } } } var cL = class { constructor(e) { this.value = e, R(this, "observers", new lw) } static interpolationFor(e, t) { if (Tn(e)) return lL(e, t) } get() { return this.value } set(e, t) { let n = this.value; Tn(e) && (e = e.get()), this.value = e; let r = { value: e, oldValue: n }; this.observers.notify(r, t) } finishTransaction(e) { return this.observers.finishTransaction(e) } onUpdate(e) { return this.observers.add(e) } }; function $c(e, t) { let r = 10 ** Math.round(Math.abs(t)); return Math.round(e * r) / r } function z1(e, t) { return t === 0 ? Math.round(e) : (t -= t | 0, t < 0 && (t = 1 - t), Math.round(e - t) + t) } function yt(e, t) { return { x: e, y: t } } (e => { e.add = (...i) => i.reduce((o, s) => ({ x: o.x + s.x, y: o.y + s.y }), { x: 0, y: 0 }), e.subtract = (i, o) => ({ x: i.x - o.x, y: i.y - o.y }), e.multiply = (i, o) => ({ x: i.x * o, y: i.y * o }), e.divide = (i, o) => ({ x: i.x / o, y: i.y / o }), e.absolute = i => ({ x: Math.abs(i.x), y: Math.abs(i.y) }), e.reverse = i => ({ x: i.x * -1, y: i.y * -1 }), e.pixelAligned = (i, o = { x: 0, y: 0 }) => ({ x: z1(i.x, o.x), y: z1(i.y, o.y) }), e.distance = (i, o) => { let s = Math.abs(i.x - o.x), a = Math.abs(i.y - o.y); return Math.sqrt(s * s + a * a) }, e.angle = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI - 90, e.angleFromX = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI, e.isEqual = (i, o) => i.x === o.x && i.y === o.y, e.rotationNormalizer = () => { let i; return o => { typeof i != "number" && (i = o); let s = i - o, a = Math.abs(s) + 180, l = Math.floor(a / 360); return s < 180 && (o -= l * 360), s > 180 && (o += l * 360), i = o, o } }; function t(i, o) { return { x: (i.x + o.x) / 2, y: (i.y + o.y) / 2 } } e.center = t; function n(i) { let o = 0, s = 0; i.forEach(c => { o += c.x, s += c.y }); let a = o / i.length, l = s / i.length; return { x: a, y: l } } e.centroid = n; function r(i) { let o = e.centroid(i), s = new Map; for (let a = 0; a < i.length; a++) { let l = i[a]; s.set(l, Math.atan2(l.x - o.x, l.y - o.y)) } return i.sort((a, l) => s.get(a) - s.get(l)) } e.sortClockwise = r })(yt || (yt = {})); var Up = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }; function Wr(e, t, n, r = !1) { let [i, o] = t, [s, a] = n, l = o - i; if (l === 0) return (a + s) / 2; let c = a - s; if (c === 0) return s; let u = s + (e - i) / l * c; if (r === !0) if (s < a) { if (u < s) return s; if (u > a) return a } else { if (u > s) return s; if (u < a) return a } return u } function Vo(e) { return !isNaN(e) && isFinite(e) } function Ur(e) { let t = Xp(e); return t !== void 0 ? e.includes("%") ? t / 100 : t : 0 } function Xp(e) { let t = /\d?\.?\d+/u.exec(e); return t ? Number(t[0]) : void 0 } var uL = (() => QF().Hsluv)(), Vt = new uL; function fL(e, t, n) { return Vt.rgb_r = e / 255, Vt.rgb_g = t / 255, Vt.rgb_b = n / 255, Vt.rgbToHsluv(), { h: Vt.hsluv_h, s: Vt.hsluv_s, l: Vt.hsluv_l } } function dL(e, t, n, r = 1) { return Vt.hsluv_h = e, Vt.hsluv_s = t, Vt.hsluv_l = n, Vt.hsluvToRgb(), { r: Vt.rgb_r * 255, g: Vt.rgb_g * 255, b: Vt.rgb_b * 255, a: r } } function zc(e, t, n, r) { let i = Math.round(e), o = Math.round(t * 100), s = Math.round(n * 100); return r === void 0 || r === 1 ? "hsv(" + i + ", " + o + "%, " + s + "%)" : "hsva(" + i + ", " + o + "%, " + s + "%, " + r + ")" } function hL(e, t, n) { return { r: Vo(e) ? Et(e, 255) * 255 : 0, g: Vo(t) ? Et(t, 255) * 255 : 0, b: Vo(n) ? Et(n, 255) * 255 : 0 } } function N1(e, t, n, r) { let i = [Rp(Math.round(e).toString(16)), Rp(Math.round(t).toString(16)), Rp(Math.round(n).toString(16))]; return r && i[0].charAt(0) === i[0].charAt(1) && i[1].charAt(0) === i[1].charAt(1) && i[2].charAt(0) === i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("") } function im(e, t, n) { let r, i, o = Et(e, 255), s = Et(t, 255), a = Et(n, 255), l = Math.max(o, s, a), c = Math.min(o, s, a), u = i = r = (l + c) / 2; if (l === c) u = i = 0; else { let f = l - c; switch (i = r > .5 ? f / (2 - l - c) : f / (l + c), l) { case o: u = (s - a) / f + (s < a ? 6 : 0); break; case s: u = (a - o) / f + 2; break; case a: u = (o - s) / f + 4; break }u /= 6 } return { h: u * 360, s: i, l: r } } function Ep(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function pL(e, t, n) { let r, i, o; if (e = Et(e, 360), t = Et(t * 100, 100), n = Et(n * 100, 100), t === 0) r = i = o = n; else { let s = n < .5 ? n * (1 + t) : n + t - n * t, a = 2 * n - s; r = Ep(a, s, e + 1 / 3), i = Ep(a, s, e), o = Ep(a, s, e - 1 / 3) } return { r: r * 255, g: i * 255, b: o * 255 } } function H1(e, t, n) { e = Et(e, 255), t = Et(t, 255), n = Et(n, 255); let r = Math.max(e, t, n), i = Math.min(e, t, n), o = r - i, s, a = r === 0 ? 0 : o / r, l = r; if (r === i) s = 0; else { switch (r) { case e: s = (t - n) / o + (t < n ? 6 : 0); break; case t: s = (n - e) / o + 2; break; case n: s = (e - t) / o + 4; break }s /= 6 } return { h: s, s: a, v: l } } function mL(e, t, n) { e = Et(e, 360) * 6, t = Et(t * 100, 100), n = Et(n * 100, 100); let r = Math.floor(e), i = e - r, o = n * (1 - t), s = n * (1 - i * t), a = n * (1 - (1 - i) * t), l = r % 6, c = [n, s, o, o, a, n][l], u = [a, n, n, s, o, o][l], f = [o, o, a, n, n, s][l]; return { r: c * 255, g: u * 255, b: f * 255 } } function Et(e, t) { let n, r; if (typeof t == "string" ? n = parseFloat(t) : n = t, typeof e == "string") { vL(e) && (e = "100%"); let i = gL(e); r = Math.min(n, Math.max(0, parseFloat(e))), i && (r = Math.floor(r * n) / 100) } else r = e; return Math.abs(r - n) < 1e-6 ? 1 : r % n / n } function vL(e) { return typeof e == "string" && e.includes(".") && parseFloat(e) === 1 } function gL(e) { return typeof e == "string" && e.includes("%") } function Rp(e) { return e.length === 1 ? "0" + e : "" + e } var jn = (() => { let e = "[-\\+]?\\d+%?", n = "(?:" + "[-\\+]?\\d*\\.\\d+%?" + ")|(?:" + e + ")", r = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?", i = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?"; return { rgb: new RegExp("rgb" + r), rgba: new RegExp("rgba" + i), hsl: new RegExp("hsl" + r), hsla: new RegExp("hsla" + i), hsv: new RegExp("hsv" + r), hsva: new RegExp("hsva" + i), hex3: /^([\da-f])([\da-f])([\da-f])$/iu, hex6: /^([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu, hex4: /^#?([\da-f])([\da-f])([\da-f])([\da-f])$/iu, hex8: /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu } })(); function om(e) { if (e.includes("gradient(") || e.includes("var(")) return !1; let t = /^[\s,#]+/u, n = e.replace(t, "").trimEnd().toLowerCase(), r = Up[n]; if (r && (n = r), n === "transparent") return { r: 0, g: 0, b: 0, a: 0, format: "name" }; let i; return (i = jn.rgb.exec(n)) ? { r: parseInt(i[1] ?? ""), g: parseInt(i[2] ?? ""), b: parseInt(i[3] ?? ""), a: 1, format: "rgb" } : (i = jn.rgba.exec(n)) ? { r: parseInt(i[1] ?? ""), g: parseInt(i[2] ?? ""), b: parseInt(i[3] ?? ""), a: parseFloat(i[4] ?? ""), format: "rgb" } : (i = jn.hsl.exec(n)) ? { h: parseInt(i[1] ?? ""), s: Ur(i[2] ?? ""), l: Ur(i[3] ?? ""), a: 1, format: "hsl" } : (i = jn.hsla.exec(n)) ? { h: parseInt(i[1] ?? ""), s: Ur(i[2] ?? ""), l: Ur(i[3] ?? ""), a: parseFloat(i[4] ?? ""), format: "hsl" } : (i = jn.hsv.exec(n)) ? { h: parseInt(i[1] ?? ""), s: Ur(i[2] ?? ""), v: Ur(i[3] ?? ""), a: 1, format: "hsv" } : (i = jn.hsva.exec(n)) ? { h: parseInt(i[1] ?? ""), s: Ur(i[2] ?? ""), v: Ur(i[3] ?? ""), a: parseFloat(i[4] ?? ""), format: "hsv" } : (i = jn.hex8.exec(n)) ? { r: Kt(i[1] ?? ""), g: Kt(i[2] ?? ""), b: Kt(i[3] ?? ""), a: j1(i[4] ?? ""), format: r ? "name" : "hex" } : (i = jn.hex6.exec(n)) ? { r: Kt(i[1] ?? ""), g: Kt(i[2] ?? ""), b: Kt(i[3] ?? ""), a: 1, format: r ? "name" : "hex" } : (i = jn.hex4.exec(n)) ? { r: Kt(`${i[1]}${i[1]}`), g: Kt(`${i[2]}${i[2]}`), b: Kt(`${i[3]}${i[3]}`), a: j1(i[4] + "" + i[4]), format: r ? "name" : "hex" } : (i = jn.hex3.exec(n)) ? { r: Kt(`${i[1]}${i[1]}`), g: Kt(`${i[2]}${i[2]}`), b: Kt(`${i[3]}${i[3]}`), a: 1, format: r ? "name" : "hex" } : !1 } function Kt(e) { return parseInt(e, 16) } function j1(e) { return Kt(e) / 255 } var W1 = new Map, W = (() => { function e(o, s, a, l) { if (typeof o == "string") { let u = W1.get(o); return u || (u = t(o), u === void 0 ? { ...e("black"), isValid: !1 } : (W1.set(o, u), u)) } let c = t(o, s, a, l); return c !== void 0 ? c : { ...e("black"), isValid: !1 } } function t(o, s, a, l) { if (o === "") return; let c = yL(o, s, a, l); if (c) { let u = { r: c.r, g: c.g, b: c.b, a: c.a, h: c.h, s: c.s, l: c.l, initialValue: typeof o == "string" && c.format !== "hsv" ? o : void 0, roundA: Math.round(100 * c.a) / 100, format: c.format, mix: e.mix, toValue: () => e.toRgbString(u) }; return u } else return } let n = { isRGB(o) { return o === "rgb" || o === "rgba" }, isHSL(o) { return o === "hsl" || o === "hsla" } }; e.inspect = (o, s) => o.format === "hsl" ? `<${o.constructor.name} h:${o.h} s:${o.s} l:${o.l} a:${o.a}>` : o.format === "hex" || o.format === "name" ? `<${o.constructor.name} "${s}">` : `<${o.constructor.name} r:${o.r} g:${o.g} b:${o.b} a:${o.a}>`, e.isColor = o => typeof o == "string" ? e.isColorString(o) : e.isColorObject(o), e.isColorString = o => typeof o == "string" ? om(o) !== !1 : !1, e.isColorObject = o => o && typeof o != "string" && typeof o.r == "number" && typeof o.g == "number" && typeof o.b == "number" && typeof o.h == "number" && typeof o.s == "number" && typeof o.l == "number" && typeof o.a == "number" && typeof o.roundA == "number" && typeof o.format == "string", e.toString = o => e.toRgbString(o), e.toHex = (o, s = !1) => N1(o.r, o.g, o.b, s), e.toHexString = (o, s = !1) => `#${e.toHex(o, s)}`, e.toRgbString = o => o.a === 1 ? "rgb(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ")" : "rgba(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ", " + o.roundA + ")", e.toHusl = o => ({ ...fL(o.r, o.g, o.b), a: o.roundA }), e.toHslString = o => { let s = e.toHsl(o), a = Math.round(s.h), l = Math.round(s.s * 100), c = Math.round(s.l * 100); return o.a === 1 ? "hsl(" + a + ", " + l + "%, " + c + "%)" : "hsla(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")" }, e.toHsv = o => { let s = H1(o.r, o.g, o.b); return { h: s.h * 360, s: s.s, v: s.v, a: o.a } }, e.toHsvString = o => { let s = H1(o.r, o.g, o.b), a = Math.round(s.h * 360), l = Math.round(s.s * 100), c = Math.round(s.v * 100); return o.a === 1 ? "hsv(" + a + ", " + l + "%, " + c + "%)" : "hsva(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")" }, e.toName = o => { if (o.a === 0) return "transparent"; if (o.a < 1) return !1; let s = N1(o.r, o.g, o.b, !0); for (let a of Object.keys(Up)) if (Up[a] === s) return a; return !1 }, e.toHsl = o => ({ h: Math.round(o.h), s: o.s, l: o.l, a: o.a }), e.toRgb = o => ({ r: Math.round(o.r), g: Math.round(o.g), b: Math.round(o.b), a: o.a }), e.brighten = (o, s = 10) => { let a = e.toRgb(o); return a.r = Math.max(0, Math.min(255, a.r - Math.round(255 * -(s / 100)))), a.g = Math.max(0, Math.min(255, a.g - Math.round(255 * -(s / 100)))), a.b = Math.max(0, Math.min(255, a.b - Math.round(255 * -(s / 100)))), e(a) }, e.lighten = (o, s = 10) => { let a = e.toHsl(o); return a.l += s / 100, a.l = Math.min(1, Math.max(0, a.l)), e(a) }, e.darken = (o, s = 10) => { let a = e.toHsl(o); return a.l -= s / 100, a.l = Math.min(1, Math.max(0, a.l)), e(a) }, e.saturate = (o, s = 10) => { let a = e.toHsl(o); return a.s += s / 100, a.s = Math.min(1, Math.max(0, a.s)), e(a) }, e.desaturate = (o, s = 10) => { let a = e.toHsl(o); return a.s -= s / 100, a.s = Math.min(1, Math.max(0, a.s)), e(a) }, e.grayscale = o => e.desaturate(o, 100), e.hueRotate = (o, s) => { let a = e.toHsl(o); return a.h += s, a.h = a.h > 360 ? a.h - 360 : a.h, e(a) }, e.alpha = (o, s = 1) => e({ r: o.r, g: o.g, b: o.b, a: s }), e.transparent = o => e.alpha(o, 0), e.multiplyAlpha = (o, s = 1) => e({ r: o.r, g: o.g, b: o.b, a: o.a * s }), e.interpolate = (o, s, a = "rgb") => { if (!e.isColorObject(o) || !e.isColorObject(s)) throw new TypeError("Both arguments for Color.interpolate must be Color objects"); return l => e.mixAsColor(o, s, l, !1, a) }, e.mix = (o, s, { model: a = "rgb" } = {}) => { let l = typeof o == "string" ? e(o) : o, c = e.interpolate(l, s, a); return u => e.toRgbString(c(u)) }, e.mixAsColor = (o, s, a = .5, l = !1, c = "rgb") => { let u = null; if (n.isRGB(c)) u = e({ r: Wr(a, [0, 1], [o.r, s.r], l), g: Wr(a, [0, 1], [o.g, s.g], l), b: Wr(a, [0, 1], [o.b, s.b], l), a: Wr(a, [0, 1], [o.a, s.a], l) }); else { let f, d; n.isHSL(c) ? (f = e.toHsl(o), d = e.toHsl(s)) : (f = e.toHusl(o), d = e.toHusl(s)), f.s === 0 ? f.h = d.h : d.s === 0 && (d.h = f.h); let p = f.h, g = d.h, v = g - p; v > 180 ? v = g - 360 - p : v < -180 && (v = g + 360 - p); let S = { h: Wr(a, [0, 1], [p, p + v], l), s: Wr(a, [0, 1], [f.s, d.s], l), l: Wr(a, [0, 1], [f.l, d.l], l), a: Wr(a, [0, 1], [o.a, s.a], l) }; n.isHSL(c) ? u = e(S) : u = e(dL(S.h, S.s, S.l, S.a)) } return u }, e.random = (o = 1) => { function s() { return Math.floor(Math.random() * 255) } return e("rgba(" + s() + ", " + s() + ", " + s() + ", " + o + ")") }, e.grey = (o = .5, s = 1) => (o = Math.floor(o * 255), e("rgba(" + o + ", " + o + ", " + o + ", " + s + ")")), e.gray = e.grey, e.rgbToHsl = (o, s, a) => im(o, s, a), e.isValidColorProperty = (o, s) => !!((o.toLowerCase().slice(-5) === "color" || o === "fill" || o === "stroke") && typeof s == "string" && e.isColorString(s)), e.difference = (o, s) => { let a = (o.r + s.r) / 2, l = o.r - s.r, c = o.g - s.g, u = o.b - s.b, f = Math.pow(l, 2), d = Math.pow(c, 2), p = Math.pow(u, 2); return Math.sqrt(2 * f + 4 * d + 3 * p + a * (f - p) / 256) }, e.equal = (o, s, a = .1) => !(Math.abs(o.r - s.r) >= a || Math.abs(o.g - s.g) >= a || Math.abs(o.b - s.b) >= a || Math.abs(o.a - s.a) * 256 >= a); let r = Ki([0, 255], [0, 1]); function i(o) { o = r(o); let s = Math.abs(o); return s < .04045 ? o / 12.92 : (Math.sign(o) || 1) * Math.pow((s + .055) / 1.055, 2.4) } return e.luminance = o => { let { r: s, g: a, b: l } = e.toRgb(o); return .2126 * i(s) + .7152 * i(a) + .0722 * i(l) }, e.contrast = (o, s) => { let a = e.luminance(o), l = e.luminance(s); return (Math.max(a, l) + .05) / (Math.min(a, l) + .05) }, e })(); function yL(e, t, n, r = 1) { let i; return typeof e == "number" && !Number.isNaN(e) && typeof t == "number" && !Number.isNaN(t) && typeof n == "number" && !Number.isNaN(n) ? i = Yp({ r: e, g: t, b: n, a: r }) : typeof e == "string" ? i = bL(e) : typeof e == "object" && (e.hasOwnProperty("r") && e.hasOwnProperty("g") && e.hasOwnProperty("b") ? i = Yp(e) : i = cw(e)), i } function bL(e) { let t = om(e); if (t) return t.format === "hsl" ? cw(t) : t.format === "hsv" ? xL(t) : Yp(t) } function xL(e) { let t = mL(e.h, e.s, e.v); return { ...im(t.r, t.g, t.b), ...t, format: "rgb", a: e.a !== void 0 ? uw(e.a) : 1 } } function Yp(e) { let t = hL(e.r, e.g, e.b); return { ...im(t.r, t.g, t.b), ...t, format: "rgb", a: e.a !== void 0 ? uw(e.a) : 1 } } function cw(e) { let t, n, r, i = { r: 0, g: 0, b: 0 }, o = { h: 0, s: 0, l: 0 }; return t = Vo(e.h) ? e.h : 0, t = (t + 360) % 360, n = Vo(e.s) ? e.s : 1, typeof e.s == "string" && (n = Xp(e.s)), r = Vo(e.l) ? e.l : .5, typeof e.l == "string" && (r = Xp(e.l)), i = pL(t, n, r), o = { h: t, s: n, l: r }, { ...i, ...o, a: e.a === void 0 ? 1 : e.a, format: "hsl" } } function uw(e) { return e = parseFloat(e), e < 0 && (e = 0), (isNaN(e) || e > 1) && (e = 1), e } var U1 = e => e instanceof dl; var SL = (() => ZF().EventEmitter)(), wL = class { constructor() { R(this, "_emitter", new SL) } eventNames() { return this._emitter.eventNames() } eventListeners() { let e = {}; for (let t of this._emitter.eventNames()) e[t] = this._emitter.listeners(t); return e } on(e, t) { this.addEventListener(e, t, !1, !1, this) } off(e, t) { this.removeEventListeners(e, t) } once(e, t) { this.addEventListener(e, t, !0, !1, this) } unique(e, t) { this.addEventListener(e, t, !1, !0, this) } addEventListener(e, t, n, r, i) { if (r) { for (let o of this._emitter.eventNames()) if (t === this._emitter.listeners(o)) return } n === !0 ? this._emitter.once(e, t, i) : this._emitter.addListener(e, t, i) } removeEventListeners(e, t) { e ? this._emitter.removeListener(e, t) : this.removeAllEventListeners() } removeAllEventListeners() { this._emitter.removeAllListeners() } countEventListeners(e, t) { if (e) return this._emitter.listeners(e).length; { let n = 0; for (let r of this._emitter.eventNames()) n += this._emitter.listeners(r).length; return n } } emit(e, ...t) { this._emitter.emit(e, ...t) } }, kL = { addEventListener: () => { }, removeEventListener: () => { }, dispatchEvent: () => !1, ResizeObserver: void 0, onpointerdown: !1, onpointermove: !1, onpointerup: !1, ontouchstart: !1, ontouchmove: !1, ontouchend: !1, onmousedown: !1, onmousemove: !1, onmouseup: !1, devicePixelRatio: 1, scrollX: 0, scrollY: 0, location: { href: "" }, setTimeout: () => 0, clearTimeout: () => { }, setInterval: () => 0, clearInterval: () => { }, requestAnimationFrame: () => 0, cancelAnimationFrame: () => { }, getSelection: () => null, matchMedia: e => ({ matches: !1, media: e, onchange: () => { }, addEventListener: () => { }, removeEventListener: () => { }, addListener: () => { }, removeListener: () => { }, dispatchEvent: () => !1 }), innerHeight: 0, innerWidth: 0, SVGSVGElement: {}, open: function (e, t, n) { } }, Ve = typeof window > "u" ? kL : window, CL = e => { setTimeout(e, 1 / 60) }, TL = (() => Ve.requestAnimationFrame || CL)(), X1 = e => TL(e), ia = (() => 1 / 60)(), EL = class extends wL { constructor(e = !1) { super(), R(this, "_started", !1), R(this, "_frame", 0), R(this, "_frameTasks", []), R(this, "tick", () => { this._started && (X1(this.tick), this.emit("update", this._frame, ia), this.emit("render", this._frame, ia), this._processFrameTasks(), this._frame++) }), e && this.start() } addFrameTask(e) { this._frameTasks.push(e) } _processFrameTasks() { var e; let t = this._frameTasks, n = t.length; if (n !== 0) { for (let r = 0; r < n; r++)(e = t[r]) == null || e.call(t); t.length = 0 } } static set TimeStep(e) { ia = e } static get TimeStep() { return ia } start() { return this._started ? this : (this._frame = 0, this._started = !0, X1(this.tick), this) } stop() { return this._started = !1, this } get frame() { return this._frame } get time() { return this._frame * ia } }, fw = new EL, nu = { target: "PREVIEW", zoom: 1 }; var oe = { canvas: "CANVAS", export: "EXPORT", thumbnail: "THUMBNAIL", preview: "PREVIEW", current: () => nu.target, hasRestrictions: () => { let e = nu.target; return e === "CANVAS" || e === "EXPORT" } }; var Nc = e => ({ correct: (t, { delta: n, treeScale: r }) => { if (typeof t == "string" && (t = parseFloat(t)), t === 0) return "0px"; let i = t; return n && r && (i = Math.round(t / n[e].scale / r[e]), i = Math.max(i, 1)), i + "px" } }); wf({ borderTopWidth: Nc("y"), borderLeftWidth: Nc("x"), borderRightWidth: Nc("x"), borderBottomWidth: Nc("y") }); function de(e, ...t) {
    var n, r; if (e) return; let i = Error("Assertion Error" + (t.length > 0 ? ": " + t.join(" ") : "")); if (i.stack) try {
        let o = i.stack.split(`
`); (n = o[1]) != null && n.includes("assert") ? (o.splice(1, 1), i.stack = o.join(`
`)) : (r = o[0]) != null && r.includes("assert") && (o.splice(0, 1), i.stack = o.join(`
`))
    } catch { } throw i
} function We(e, t) { throw t || new Error(e ? `Unexpected value: ${e}` : "Application entered invalid state") } var Bo = b.createContext({ getLayoutId: e => null, persistLayoutIdCache: () => { }, top: !1, enabled: !0 }); function RL({ children: e }) { if (O(Bo).top) return C(Le, { children: e }); let n = D({ byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {}, count: { byId: {}, byName: {} } }), r = D({ byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {} }), i = D(new Set).current, o = pe(({ id: l, name: c, duplicatedFrom: u }) => { if (!l) return null; let f = c ? "byName" : "byId", d = n.current[f][l]; if (d) return d; let p = c || l; if (!u && !i.has(p) && (!n.current.byLayoutId[p] || n.current.byLayoutId[p] === p)) return n.current.count[f][p] === void 0 && (n.current.count[f][p] = 0, n.current.byLayoutId[p] = p, r.current[f][l] = p), i.add(p), p; let g; if (u?.length) for (let w = u.length - 1; w >= 0; w--) { let T = u[w]; de(!!T, "duplicatedId must be defined"); let E = n.current[f][T], I = n.current.byLastId[T]; if (I && !g) { let V = n.current.byLayoutId[I], K = !V || V === c; I && !i.has(I) && (!c || K) && (g = [I, T]) } let F = E ? n.current.byLayoutId[E] : void 0, B = !F || F === c; if (E && !i.has(E) && (!c || B)) return r.current[f][l] = E, r.current.byLastId[T] = E, i.add(E), E } let v = n.current.byLastId[l]; if (v && !i.has(v)) return i.add(v), r.current.byId[l] = v, v; if (g) { let [w, T] = g; return r.current[f][l] = w, r.current.byLastId[T] = w, i.add(w), w } let S = n.current.byPossibleId[l]; if (S && !i.has(S)) return i.add(S), r.current.byId[l] = S, S; let m = u?.[0], h = c || m || l, y = (n.current.count[f][h] ?? -1) + 1, { layoutId: x, value: k } = PL(h, y, i); if (n.current.count[f][h] = k, r.current[f][l] = x, u?.length && !c) { let w = u[u.length - 1]; if (w && (r.current.byLastId[w] = x), u.length > 1) for (let T = 0; T < u.length - 1; T++) { let E = u[T]; E !== void 0 && (r.current.byPossibleId[E] || (r.current.byPossibleId[E] = x)) } } return r.current.byLayoutId[x] = p, i.add(x), x }, []), s = pe(() => { n.current = { byId: { ...n.current.byId, ...r.current.byId }, byLastId: { ...n.current.byLastId, ...r.current.byLastId }, byPossibleId: { ...n.current.byPossibleId, ...r.current.byPossibleId }, byName: { ...n.current.byName, ...r.current.byName }, byLastName: { ...n.current.byLastName, ...r.current.byLastName }, byLayoutId: { ...n.current.byLayoutId, ...r.current.byLayoutId }, count: { ...n.current.count, byName: {} } }, r.current = { byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {} }, i.clear() }, []), a = D({ getLayoutId: o, persistLayoutIdCache: s, top: !0, enabled: !0 }).current; return C(Bo.Provider, { value: a, children: e }) } function PL(e, t, n) { let r = t, i = r ? `${e}-${r}` : e; for (; n.has(i);)r++, i = `${e}-${r}`; return { layoutId: i, value: r } } function _L({ enabled: e = !0, ...t }) { let n = O(Bo), r = he(() => ({ ...n, enabled: e }), [e]); return C(Bo.Provider, { ...t, value: r }) } function Rt(e) { let t = D(null); return t.current === null && (t.current = e()), t.current } var FL = { background: void 0, display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", lineHeight: "1.4em", textOverflow: "ellipsis", overflow: "hidden", minHeight: 0, width: "100%", height: "100%" }, IL = (() => ({ ...FL, border: "1px solid rgba(149, 149, 149, 0.15)", borderRadius: 6, fontSize: "12px", backgroundColor: "rgba(149, 149, 149, 0.1)", color: "#a5a5a5" }))(), dw = { overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis", maxWidth: "100%", flexShrink: 0, padding: "0 10px" }, LL = (() => ({ ...dw, fontWeight: 500 }))(), ML = (() => ({ ...dw, whiteSpace: "pre", maxHeight: "calc(50% - calc(20px * var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)))", WebkitMaskImage: "linear-gradient(to bottom, black 80%, transparent 100%)" }))(); function Pz(e) { let { error: t, file: n } = e, r = n ? `Error in ${OL(n)}` : "Error", i = t instanceof Error ? t.message : "" + t; return ae("div", { style: IL, children: [C("div", { className: "text", style: LL, children: r }), i && C("div", { className: "text", style: ML, children: i })] }) } function OL(e) { return e.startsWith("./") ? e.replace("./", "") : e } function Q(e) { return typeof e == "number" && isFinite(e) } function DL(e) { return !e || !Object.keys(e).length && e.constructor === Object } function la(e) { return typeof e != "string" && typeof e != "number" } function ca(e) { return e !== null && typeof e < "u" && typeof e != "boolean" && !DL(e) } function AL(e) { return e * (Math.PI / 180) } var st = (() => { function e(t, n) { return { a: t, b: n } } return e.offset = (t, n) => { let r = yt.angleFromX(t.a, t.b), i = AL(r), o = n * Math.sin(i), s = n * Math.cos(i); return e({ x: t.a.x + o, y: t.a.y - s }, { x: t.b.x + o, y: t.b.y - s }) }, e.intersection = (t, n, r) => { let i = t.a.x, o = t.a.y, s = t.b.x, a = t.b.y, l = n.a.x, c = n.a.y, u = n.b.x, f = n.b.y, d = (u - l) * (c - o) - (f - c) * (l - i), p = (u - l) * (a - o) - (f - c) * (s - i), g = (s - i) * (c - o) - (a - o) * (l - i); if (d === 0 && p === 0 || p === 0) return null; let v = d / p, S = g / p; return r && (v < 0 || v > 1 || S < 0 || S > 1) ? null : { x: i + v * (s - i), y: o + v * (a - o) } }, e.intersectionAngle = (t, n) => { let r = t.b.x - t.a.x, i = t.b.y - t.a.y, o = n.b.x - n.a.x, s = n.b.y - n.a.y; return Math.atan2(r * s - i * o, r * o + i * s) * (180 / Math.PI) }, e.isOrthogonal = t => t.a.x === t.b.x || t.a.y === t.b.y, e.perpendicular = (t, n) => { let r = t.a.x - t.b.x, i = t.a.y - t.b.y, o = yt(n.x - i, n.y + r); return e(o, n) }, e.projectPoint = (t, n) => { let r = e.perpendicular(t, n); return e.intersection(t, r) }, e.pointAtPercentDistance = (t, n) => { let r = e.distance(t), i = n * r / r; return { x: i * t.b.x + (1 - i) * t.a.x, y: i * t.b.y + (1 - i) * t.a.y } }, e.distance = t => yt.distance(t.a, t.b), e })(), $ = { equals: function (e, t) { return e === t ? !0 : !e || !t ? !1 : e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height }, atOrigin: e => ({ ...e, x: 0, y: 0 }), fromTwoPoints: (e, t) => ({ x: Math.min(e.x, t.x), y: Math.min(e.y, t.y), width: Math.abs(e.x - t.x), height: Math.abs(e.y - t.y) }), fromRect: e => ({ x: e.left, y: e.top, width: e.right - e.left, height: e.bottom - e.top }), multiply: (e, t) => ({ x: e.x * t, y: e.y * t, width: e.width * t, height: e.height * t }), divide: (e, t) => $.multiply(e, 1 / t), offset: (e, t) => { let n = typeof t.x == "number" ? t.x : 0, r = typeof t.y == "number" ? t.y : 0; return { ...e, x: e.x + n, y: e.y + r } }, inflate: (e, t) => { if (t === 0) return e; let n = 2 * t; return { x: e.x - t, y: e.y - t, width: e.width + n, height: e.height + n } }, pixelAligned: e => { let t = Math.round(e.x), n = Math.round(e.y), r = Math.round(e.x + e.width), i = Math.round(e.y + e.height), o = Math.max(r - t, 0), s = Math.max(i - n, 0); return { x: t, y: n, width: o, height: s } }, halfPixelAligned: e => { let t = Math.round(e.x * 2) / 2, n = Math.round(e.y * 2) / 2, r = Math.round((e.x + e.width) * 2) / 2, i = Math.round((e.y + e.height) * 2) / 2, o = Math.max(r - t, 1), s = Math.max(i - n, 1); return { x: t, y: n, width: o, height: s } }, round: (e, t = 0) => { let n = $c(e.x, t), r = $c(e.y, t), i = $c(e.width, t), o = $c(e.height, t); return { x: n, y: r, width: i, height: o } }, roundToOutside: e => { let t = Math.floor(e.x), n = Math.floor(e.y), r = Math.ceil(e.x + e.width), i = Math.ceil(e.y + e.height), o = Math.max(r - t, 0), s = Math.max(i - n, 0); return { x: t, y: n, width: o, height: s } }, minX: e => e.x, maxX: e => e.x + e.width, minY: e => e.y, maxY: e => e.y + e.height, positions: e => ({ minX: e.x, midX: e.x + e.width / 2, maxX: $.maxX(e), minY: e.y, midY: e.y + e.height / 2, maxY: $.maxY(e) }), center: e => ({ x: e.x + e.width / 2, y: e.y + e.height / 2 }), boundingRectFromPoints: e => { let t = 1 / 0, n = -1 / 0, r = 1 / 0, i = -1 / 0; for (let o = 0; o < e.length; o++) { let s = e[o]; t = Math.min(t, s.x), n = Math.max(n, s.x), r = Math.min(r, s.y), i = Math.max(i, s.y) } return { x: t, y: r, width: n - t, height: i - r } }, fromPoints: e => { let [t, n, r, i] = e, { x: o, y: s } = t, a = yt.distance(t, n), l = yt.distance(t, i); return { x: o, y: s, width: a, height: l } }, merge: (...e) => { let t = { x: Math.min(...e.map($.minX)), y: Math.min(...e.map($.minY)) }, n = { x: Math.max(...e.map($.maxX)), y: Math.max(...e.map($.maxY)) }; return $.fromTwoPoints(t, n) }, intersection: (e, t) => { let n = Math.max(e.x, t.x), r = Math.min(e.x + e.width, t.x + t.width), i = Math.max(e.y, t.y), o = Math.min(e.y + e.height, t.y + t.height); return { x: n, y: i, width: r - n, height: o - i } }, points: e => [{ x: $.minX(e), y: $.minY(e) }, { x: $.minX(e), y: $.maxY(e) }, { x: $.maxX(e), y: $.minY(e) }, { x: $.maxX(e), y: $.maxY(e) }], pointsAtOrigin: e => [{ x: 0, y: 0 }, { x: e.width, y: 0 }, { x: e.width, y: e.height }, { x: 0, y: e.height }], transform: (e, t) => { let { x: n, y: r } = t.transformPoint({ x: e.x, y: e.y }), { x: i, y: o } = t.transformPoint({ x: e.x + e.width, y: e.y }), { x: s, y: a } = t.transformPoint({ x: e.x + e.width, y: e.y + e.height }), { x: l, y: c } = t.transformPoint({ x: e.x, y: e.y + e.height }), u = Math.min(n, i, s, l), f = Math.max(n, i, s, l) - u, d = Math.min(r, o, a, c), p = Math.max(r, o, a, c) - d; return { x: u, y: d, width: f, height: p } }, containsPoint: (e, t) => !(t.x < $.minX(e) || t.x > $.maxX(e) || t.y < $.minY(e) || t.y > $.maxY(e) || isNaN(e.x) || isNaN(e.y)), containsRect: (e, t) => { for (let n of $.points(t)) if (!$.containsPoint(e, n)) return !1; return !0 }, toCSS: e => ({ display: "block", transform: `translate(${e.x}px, ${e.y}px)`, width: `${e.width}px`, height: `${e.height}px` }), inset: (e, t) => ({ x: e.x + t, y: e.y + t, width: Math.max(0, e.width - 2 * t), height: Math.max(0, e.height - 2 * t) }), intersects: (e, t) => !(t.x >= $.maxX(e) || $.maxX(t) <= e.x || t.y >= $.maxY(e) || $.maxY(t) <= e.y), overlapHorizontally: (e, t) => { let n = $.maxX(e), r = $.maxX(t); return n > t.x && r > e.x }, overlapVertically: (e, t) => { let n = $.maxY(e), r = $.maxY(t); return n > t.y && r > e.y }, doesNotIntersect: (e, t) => t.find(n => $.intersects(n, e)) === void 0, isEqual: (e, t) => $.equals(e, t), cornerPoints: e => { let t = e.x, n = e.x + e.width, r = e.y, i = e.y + e.height; return [{ x: t, y: r }, { x: n, y: r }, { x: n, y: i }, { x: t, y: i }] }, midPoints: e => { let t = e.x, n = e.x + e.width / 2, r = e.x + e.width, i = e.y, o = e.y + e.height / 2, s = e.y + e.height; return [{ x: n, y: i }, { x: r, y: o }, { x: n, y: s }, { x: t, y: o }] }, pointDistance: (e, t) => { let n = 0, r = 0; return t.x < e.x ? n = e.x - t.x : t.x > $.maxX(e) && (n = t.x - $.maxX(e)), t.y < e.y ? r = e.y - t.y : t.y > $.maxY(e) && (r = t.y - $.maxY(e)), yt.distance({ x: n, y: r }, { x: 0, y: 0 }) }, fromAny: (e, t = { x: 0, y: 0, width: 0, height: 0 }) => ({ x: e.x || t.x, y: e.y || t.y, width: e.width || t.width, height: e.height || t.height }), delta: (e, t) => { let n = { x: $.minX(e), y: $.minY(e) }, r = { x: $.minX(t), y: $.minY(t) }; return { x: n.x - r.x, y: n.y - r.y } }, withMinSize: (e, t) => { let { width: n, height: r } = t, i = e.width - n, o = e.height - r; return { width: Math.max(e.width, n), height: Math.max(e.height, r), x: e.width < n ? e.x + i / 2 : e.x, y: e.height < r ? e.y + o / 2 : e.y } }, anyPointsOutsideRect: (e, t) => { let n = $.minX(e), r = $.minY(e), i = $.maxX(e), o = $.maxY(e); for (let s of t) if (s.x < n || s.x > i || s.y < r || s.y > o) return !0; return !1 }, edges: e => { let [t, n, r, i] = $.cornerPoints(e); return [st(t, n), st(n, r), st(r, i), st(i, t)] }, rebaseRectOnto: (e, t, n, r) => { let i = { ...e }; switch (n) { case "bottom": case "top": switch (r) { case "start": i.x = t.x; break; case "center": i.x = t.x + t.width / 2 - e.width / 2; break; case "end": i.x = t.x + t.width - e.width; break; default: We(r) }break; case "left": i.x = t.x - e.width; break; case "right": i.x = t.x + t.width; break; default: We(n) }switch (n) { case "left": case "right": switch (r) { case "start": i.y = t.y; break; case "center": i.y = t.y + t.height / 2 - e.height / 2; break; case "end": i.y = t.y + t.height - e.height; break; default: We(r) }break; case "top": i.y = t.y - e.height; break; case "bottom": i.y = t.y + t.height; break; default: We(n) }return i } }; var hw = { quickfix: e => ((e.widthType === 2 || e.heightType === 2) && (e.aspectRatio = null), Q(e.aspectRatio) && (e.left && e.right && (e.widthType = 0), e.top && e.bottom && (e.heightType = 0), e.left && e.right && e.top && e.bottom && (e.bottom = !1), e.widthType !== 0 && e.heightType !== 0 && (e.heightType = 0)), e.left && e.right && ((e.fixedSize || e.widthType === 2 || Q(e.maxWidth)) && (e.right = !1), e.widthType = 0), e.top && e.bottom && ((e.fixedSize || e.heightType === 2 || Q(e.maxHeight)) && (e.bottom = !1), e.heightType = 0), e) }; function ru(e) { if (typeof e == "string") { let t = e.trim(); if (t === "auto") return 2; if (t.endsWith("fr")) return 3; if (t.endsWith("%")) return 1; if (t.endsWith("vw") || t.endsWith("vh")) return 4 } return 0 } var pw = { fromProperties: e => { let { left: t, right: n, top: r, bottom: i, width: o, height: s, centerX: a, centerY: l, aspectRatio: c, autoSize: u } = e, f = hw.quickfix({ left: Q(t) || Tn(t), right: Q(n) || Tn(n), top: Q(r) || Tn(r), bottom: Q(i) || Tn(i), widthType: ru(o), heightType: ru(s), aspectRatio: c || null, fixedSize: u === !0 }), d = null, p = null, g = 0, v = 0; if (f.widthType !== 0 && typeof o == "string") { let h = parseFloat(o); o.endsWith("fr") ? (g = 3, d = h) : o === "auto" ? g = 2 : (g = 1, d = h / 100) } else o !== void 0 && typeof o != "string" && (d = Ke.getNumber(o)); if (f.heightType !== 0 && typeof s == "string") { let h = parseFloat(s); s.endsWith("fr") ? (v = 3, p = h) : s === "auto" ? v = 2 : (v = 1, p = parseFloat(s) / 100) } else s !== void 0 && typeof s != "string" && (p = Ke.getNumber(s)); let S = .5, m = .5; return a && (S = parseFloat(a) / 100), l && (m = parseFloat(l) / 100), { left: f.left ? Ke.getNumber(t) : null, right: f.right ? Ke.getNumber(n) : null, top: f.top ? Ke.getNumber(r) : null, bottom: f.bottom ? Ke.getNumber(i) : null, widthType: g, heightType: v, width: d, height: p, aspectRatio: f.aspectRatio || null, centerAnchorX: S, centerAnchorY: m } }, toSize: (e, t, n, r) => { let i = null, o = null, s = t?.sizing ? Ke.getNumber(t?.sizing.width) : null, a = t?.sizing ? Ke.getNumber(t?.sizing.height) : null, l = Y1(e.left, e.right); if (s && Q(l)) i = s - l; else if (n && e.widthType === 2) i = n.width; else if (Q(e.width)) switch (e.widthType) { case 0: i = e.width; break; case 3: i = r ? r.freeSpaceInParent.width / r.freeSpaceUnitDivisor.width * e.width : null; break; case 1: case 4: s && (i = s * e.width); break; case 2: break; default: We(e.widthType) }let c = Y1(e.top, e.bottom); if (a && Q(c)) o = a - c; else if (n && e.heightType === 2) o = n.height; else if (Q(e.height)) switch (e.heightType) { case 0: o = e.height; break; case 3: o = r ? r.freeSpaceInParent.height / r.freeSpaceUnitDivisor.height * e.height : null; break; case 1: case 4: a && (o = a * e.height); break; case 2: break; default: We(e.heightType) }return NL(i, o, e, { height: a ?? 0, width: s ?? 0 }, t?.viewport) }, toRect: (e, t = null, n = null, r = !1, i = null) => { let o = e.left || 0, s = e.top || 0, { width: a, height: l } = pw.toSize(e, t, n, i), c = t?.positioning ?? null, u = c ? Ke.getNumber(c.width) : null, f = c ? Ke.getNumber(c.height) : null; e.left !== null ? o = e.left : u && e.right !== null ? o = u - e.right - a : u && (o = e.centerAnchorX * u - a / 2), e.top !== null ? s = e.top : f && e.bottom !== null ? s = f - e.bottom - l : f && (s = e.centerAnchorY * f - l / 2); let d = { x: o, y: s, width: a, height: l }; return r ? $.pixelAligned(d) : d } }, VL = 200, BL = 200; function iu(e, t, n, r) { if (typeof t == "string") { if (t.endsWith("%") && n) switch (e) { case "maxWidth": case "minWidth": return parseFloat(t) / 100 * n.width; case "maxHeight": case "minHeight": return parseFloat(t) / 100 * n.height; default: break }if (t.endsWith("vh") && r) switch (e) { case "maxWidth": case "minWidth": return parseFloat(t) / 100 * r.width; case "maxHeight": case "minHeight": return parseFloat(t) / 100 * r.height; default: break }return parseFloat(t) } return t } function $L(e, t, n, r) { return t.minHeight && (e = Math.max(iu("minHeight", t.minHeight, n, r), e)), t.maxHeight && (e = Math.min(iu("maxHeight", t.maxHeight, n, r), e)), e } function zL(e, t, n, r) { return t.minWidth && (e = Math.max(iu("minWidth", t.minWidth, n, r), e)), t.maxWidth && (e = Math.min(iu("maxWidth", t.maxWidth, n, r), e)), e } function NL(e, t, n, r, i) { let o = zL(Q(e) ? e : VL, n, r, i), s = $L(Q(t) ? t : BL, n, r, i); return Q(n.aspectRatio) && n.aspectRatio > 0 && (Q(n.left) && Q(n.right) ? s = o / n.aspectRatio : Q(n.top) && Q(n.bottom) ? o = s * n.aspectRatio : n.widthType !== 0 ? s = o / n.aspectRatio : o = s * n.aspectRatio), { width: o, height: s } } function Y1(e, t) { return !Q(e) || !Q(t) ? null : e + t } function HL(e) { return typeof e.right == "string" || typeof e.bottom == "string" || typeof e.left == "string" && (!e.center || e.center === "y") || typeof e.top == "string" && (!e.center || e.center === "x") } function Ea(e) { return !e._constraints || HL(e) ? !1 : e._constraints.enabled } function jL(e) { let { size: t } = e, { width: n, height: r } = e; return Q(t) && (n === void 0 && (n = t), r === void 0 && (r = t)), Q(n) && Q(r) ? { width: n, height: r } : null } function WL(e) { let t = jL(e); if (t === null) return null; let { left: n, top: r } = e; return Q(n) && Q(r) ? { x: n, y: r, ...t } : null } function ha(e, t, n = !0) { if (e.positionFixed || e.positionAbsolute) return null; let r = t === 1 || t === 2; if (!Ea(e) || r) return WL(e); let i = UL(e), o = XL(t), s = o ? { sizing: o, positioning: o, viewport: null } : null; return pw.toRect(i, s, null, n, null) } function UL(e) { let { left: t, right: n, top: r, bottom: i, center: o, _constraints: s, size: a } = e, { width: l, height: c } = e; l === void 0 && (l = a), c === void 0 && (c = a); let { aspectRatio: u, autoSize: f } = s, d = hw.quickfix({ left: Q(t), right: Q(n), top: Q(r), bottom: Q(i), widthType: ru(l), heightType: ru(c), aspectRatio: u || null, fixedSize: f === !0 }), p = null, g = null, v = 0, S = 0; if (d.widthType !== 0 && typeof l == "string") { let y = parseFloat(l); l.endsWith("fr") ? (v = 3, p = y) : l === "auto" ? v = 2 : (v = 1, p = y / 100) } else l !== void 0 && typeof l != "string" && (p = l); if (d.heightType !== 0 && typeof c == "string") { let y = parseFloat(c); c.endsWith("fr") ? (S = 3, g = y) : c === "auto" ? S = 2 : (S = 1, g = parseFloat(c) / 100) } else c !== void 0 && typeof c != "string" && (g = c); let m = .5, h = .5; return (o === !0 || o === "x") && (d.left = !1, typeof t == "string" && (m = parseFloat(t) / 100)), (o === !0 || o === "y") && (d.top = !1, typeof r == "string" && (h = parseFloat(r) / 100)), { left: d.left ? t : null, right: d.right ? n : null, top: d.top ? r : null, bottom: d.bottom ? i : null, widthType: v, heightType: S, width: p, height: g, aspectRatio: d.aspectRatio || null, centerAnchorX: m, centerAnchorY: h, minHeight: e.minHeight, maxHeight: e.maxHeight, minWidth: e.minWidth, maxWidth: e.maxWidth } } var mw = b.createContext({ parentSize: 0 }); function XL(e) { return e === 0 || e === 1 || e === 2 ? null : e } function Ra() { return b.useContext(mw).parentSize } function vw(e) { return typeof e == "object" } var YL = e => { let t = Ra(), { parentSize: n, children: r } = e, i = b.useMemo(() => ({ parentSize: n }), [GL(n), KL(n)]); return t === 1 ? r ? C(Le, { children: r }) : null : C(mw.Provider, { value: i, children: r }) }; function GL(e) { return vw(e) ? e.width : e } function KL(e) { return vw(e) ? e.height : e } function qL(e, t) { return C(YL, { parentSize: t, children: e }) } function QL(e) { let t = Ra(); return ha(e, t, !0) } var ZL = (e => (e.Boolean = "boolean", e.Number = "number", e.String = "string", e.RichText = "richtext", e.FusedNumber = "fusednumber", e.Enum = "enum", e.SegmentedEnum = "segmentedenum", e.Color = "color", e.Image = "image", e.ResponsiveImage = "responsiveimage", e.File = "file", e.ComponentInstance = "componentinstance", e.Array = "array", e.EventHandler = "eventhandler", e.Transition = "transition", e.BoxShadow = "boxshadow", e.Link = "link", e.Date = "date", e.Object = "object", e.Font = "font", e.PageScope = "pagescope", e.ScrollSectionRef = "scrollsectionref", e.CustomCursor = "customcursor", e.Border = "border", e.Cursor = "cursor", e.Padding = "padding", e.BorderRadius = "borderradius", e))(ZL || {}), Pp; function JL() { if (Pp !== void 0) return Pp; let e = document.createElement("div"); Object.assign(e.style, { position: "absolute", display: "flex", flexDirection: "column", rowGap: "1px" }), e.appendChild(document.createElement("div")), e.appendChild(document.createElement("div")), document.body.appendChild(e); let t = e.scrollHeight === 1; return e.parentNode && e.parentNode.removeChild(e), Pp = t, t } var Fi = "flexbox-gap-not-supported", G1 = !1; function Mz() { G1 || (G1 = !0, !JL() && document.body.classList.add(Fi)) } var eM = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6,
[data-framer-component-type="DeprecatedRichText"] li,
[data-framer-component-type="DeprecatedRichText"] ol,
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] span:not([data-text-fill]) {
    font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
    font-style: var(--framer-font-style, normal);
    font-weight: var(--framer-font-weight, 400);
    color: var(--framer-text-color, #000);
    font-size: var(--framer-font-size, 16px);
    letter-spacing: var(--framer-letter-spacing, 0);
    text-transform: var(--framer-text-transform, none);
    text-decoration: var(--framer-text-decoration, none);
    line-height: var(--framer-line-height, 1.2em);
    text-align: var(--framer-text-alignment, start);
}
`, tM = `
[data-framer-component-type="DeprecatedRichText"] p:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] div:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h1:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h2:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h3:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h4:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h5:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h6:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ol:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ul:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] .framer-image:not(:first-child) {
    margin-top: var(--framer-paragraph-spacing, 0);
}
`, nM = `
[data-framer-component-type="DeprecatedRichText"] span[data-text-fill] {
    display: inline-block;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
`, rM = `
[data-framer-component-type="DeprecatedRichText"] a,
[data-framer-component-type="DeprecatedRichText"] a span:not([data-text-fill]) {
    font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
    font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
    font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
    color: var(--framer-link-text-color, var(--framer-text-color, #000));
    font-size: var(--framer-link-font-size, var(--framer-font-size, 16px));
    text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
    text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
}
`, iM = `
[data-framer-component-type="DeprecatedRichText"] a:hover,
[data-framer-component-type="DeprecatedRichText"] a:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, oM = `
a[data-framer-page-link-current],
a[data-framer-page-link-current] span:not([data-text-fill]) {
    font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, sM = `
a[data-framer-page-link-current]:hover,
a[data-framer-page-link-current]:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
    color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
}
`, aM = `
[data-framer-component-type="DeprecatedRichText"] strong {
    font-weight: bolder;
}
`, lM = `
[data-framer-component-type="DeprecatedRichText"] em {
    font-style: italic;
}
`, cM = `
[data-framer-component-type="DeprecatedRichText"] .framer-image {
    display: block;
    max-width: 100%;
    height: auto;
}
`, uM = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6 {
    margin: 0;
    padding: 0;
}
`, fM = `
[data-framer-component-type="DeprecatedRichText"] .text-styles-preset-reset {
    --framer-font-family: Inter, Inter Placeholder, sans-serif;
    --framer-font-style: normal;
    --framer-font-weight: 500;
    --framer-text-color: #000;
    --framer-font-size: 16px;
    --framer-letter-spacing: 0;
    --framer-text-transform: none;
    --framer-text-decoration: none;
    --framer-line-height: 1.2em;
    --framer-text-alignment: start;
}
`, dM = `
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] ol {
    display: table;
    width: 100%;
    padding-left: 0;
    margin: 0;
}
`, hM = `
[data-framer-component-type="DeprecatedRichText"] li {
    display: table-row;
    counter-increment: list-item;
    list-style: none;
}
`, pM = `
[data-framer-component-type="DeprecatedRichText"] ol > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: counter(list-item) ".";
    white-space: nowrap;
}
`, mM = `
[data-framer-component-type="DeprecatedRichText"] ul > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: "\u2022";
}
`, vM = ['[data-framer-component-type="DeprecatedRichText"] { cursor: inherit; }', fM, uM, eM, tM, nM, rM, iM, oM, sM, aM, lM, cM, dM, hM, pM, mM], gM = [`
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        ol.framer-text,
        ul.framer-text {
            margin: 0;
            padding: 0;
        }
    `, `
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text,
        span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
            font-style: var(--framer-font-style, normal);
            font-weight: var(--framer-font-weight, 400);
            color: var(--framer-text-color, #000);
            font-size: calc(var(--framer-font-size, 16px) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-letter-spacing, 0);
            text-transform: var(--framer-text-transform, none);
            text-decoration: var(--framer-text-decoration, none);
            line-height: var(--framer-line-height, 1.2em);
            text-align: var(--framer-text-alignment, start);
            -webkit-text-stroke-width: var(--framer-text-stroke-width, initial);
            -webkit-text-stroke-color: var(--framer-text-stroke-color, initial);
        }
    `, `
        .framer-fit-text .framer-text {
            white-space: nowrap;
            white-space-collapse: preserve;
        }
    `, `
        strong.framer-text {
            font-family: var(--framer-font-family-bold);
            font-style: var(--framer-font-style-bold);
            font-weight: var(--framer-font-weight-bold, bolder);
        }
    `, `
        em.framer-text {
            font-family: var(--framer-font-family-italic);
            font-style: var(--framer-font-style-italic, italic);
            font-weight: var(--framer-font-weight-italic);
        }
    `, `
        em.framer-text > strong.framer-text {
            font-family: var(--framer-font-family-bold-italic);
            font-style: var(--framer-font-style-bold-italic, italic);
            font-weight: var(--framer-font-weight-bold-italic, bolder);
        }
    `, `
        p.framer-text:not(:first-child),
        div.framer-text:not(:first-child),
        h1.framer-text:not(:first-child),
        h2.framer-text:not(:first-child),
        h3.framer-text:not(:first-child),
        h4.framer-text:not(:first-child),
        h5.framer-text:not(:first-child),
        h6.framer-text:not(:first-child),
        ol.framer-text:not(:first-child),
        ul.framer-text:not(:first-child),
        .framer-image.framer-text:not(:first-child) {
            margin-top: var(--framer-paragraph-spacing, 0);
        }
    `, `
        li.framer-text > ul.framer-text:nth-child(2),
        li.framer-text > ol.framer-text:nth-child(2) {
            margin-top: 0;
        }
    `, `
        .framer-text[data-text-fill] {
            display: inline-block;
            background-clip: text;
            -webkit-background-clip: text;
            /* make this a transparent color if you want to visualise the clipping  */
            -webkit-text-fill-color: transparent;
            padding: max(0em, calc(calc(1.3em - var(--framer-line-height, 1.3em)) / 2));
            margin: min(0em, calc(calc(1.3em - var(--framer-line-height, 1.3em)) / -2));
        }
    `, `
        code.framer-text,
        code.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-code-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-font-size, 16px) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-letter-spacing, 0);
            line-height: var(--framer-line-height, 1.2em);
        }
    `, `
        a.framer-text,
        a.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-link-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
            text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
            /* Cursor inherit to overwrite the user agent stylesheet on rich text links. */
            cursor: var(--framer-custom-cursors, pointer);
        }
    `, `
        code.framer-text a.framer-text,
        code.framer-text a.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text:hover,
        a.framer-text:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
        }
    `, `
        code.framer-text a.framer-text:hover,
        code.framer-text a.framer-text:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current],
        a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current]:hover,
        a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current]:hover,
        code.framer-text a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `, `
        .framer-image.framer-text {
            display: block;
            max-width: 100%;
            height: auto;
        }
    `, `
        .text-styles-preset-reset.framer-text {
            --framer-font-family: Inter, Inter Placeholder, sans-serif;
            --framer-font-style: normal;
            --framer-font-weight: 500;
            --framer-text-color: #000;
            --framer-font-size: 16px;
            --framer-letter-spacing: 0;
            --framer-text-transform: none;
            --framer-text-decoration: none;
            --framer-line-height: 1.2em;
            --framer-text-alignment: start;
        }
    `, `
        ol.framer-text {
            --list-style-type: decimal;
        }
    `, `
        ul.framer-text,
        ol.framer-text {
            display: table;
            width: 100%;
        }
    `, `
        li.framer-text {
            display: table-row;
            counter-increment: list-item;
            list-style: none;
        }
    `, `
        ol.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: counter(list-item, var(--list-style-type)) ".";
            white-space: nowrap;
        }
    `, `
        ul.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: "\u2022";
        }
    `, `
        .framer-text-module[style*="aspect-ratio"] > :first-child {
            width: 100%;
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] {
                position: relative;
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"]::before {
                content: "";
                display: block;
                padding-bottom: calc(100% / calc(var(--aspect-ratio)));
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] > :first-child {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
            }
        }
    `], yM = new Set, _p; function gw(e, t, n = yM) { if (!(!e || n.has(e) || typeof document > "u")) { if (n.add(e), !t) { if (!_p) { let r = document.createElement("style"); if (r.setAttribute("type", "text/css"), r.setAttribute("data-framer-css", "true"), !document.head) { console.warn("not injecting CSS: the document is missing a <head> element"); return } if (document.head.appendChild(r), r.sheet) _p = r.sheet; else { console.warn("not injecting CSS: injected <style> element does not have a sheet", r); return } } t = _p } try { t.insertRule(e, t.cssRules.length) } catch { } } } var bM = ["[data-framer-component-type] { position: absolute; }"], xM = `
[data-framer-component-type="Text"] > * {
    text-align: var(--framer-text-alignment, start);
}`, SM = `
[data-framer-component-type="Text"] span span,
[data-framer-component-type="Text"] p span,
[data-framer-component-type="Text"] h1 span,
[data-framer-component-type="Text"] h2 span,
[data-framer-component-type="Text"] h3 span,
[data-framer-component-type="Text"] h4 span,
[data-framer-component-type="Text"] h5 span,
[data-framer-component-type="Text"] h6 span {
    display: block;
}`, wM = `
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span {
    display: unset;
}`, kM = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    font-family: var(--font-family);
    font-style: var(--font-style);
    font-weight: min(calc(var(--framer-font-weight-increase, 0) + var(--font-weight, 400)), 900);
    color: var(--text-color);
    letter-spacing: var(--letter-spacing);
    font-size: var(--font-size);
    text-transform: var(--text-transform);
    text-decoration: var(--text-decoration);
    line-height: var(--line-height);
}`, CM = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    --font-family: var(--framer-font-family);
    --font-style: var(--framer-font-style);
    --font-weight: var(--framer-font-weight);
    --text-color: var(--framer-text-color);
    --letter-spacing: var(--framer-letter-spacing);
    --font-size: var(--framer-font-size);
    --text-transform: var(--framer-text-transform);
    --text-decoration: var(--framer-text-decoration);
    --line-height: var(--framer-line-height);
}`, TM = `
[data-framer-component-type="Text"] a,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] a span span span,
[data-framer-component-type="Text"] a p span span,
[data-framer-component-type="Text"] a h1 span span,
[data-framer-component-type="Text"] a h2 span span,
[data-framer-component-type="Text"] a h3 span span,
[data-framer-component-type="Text"] a h4 span span,
[data-framer-component-type="Text"] a h5 span span,
[data-framer-component-type="Text"] a h6 span span {
    --font-family: var(--framer-link-font-family, var(--framer-font-family));
    --font-style: var(--framer-link-font-style, var(--framer-font-style));
    --font-weight: var(--framer-link-font-weight, var(--framer-font-weight));
    --text-color: var(--framer-link-text-color, var(--framer-text-color));
    --font-size: var(--framer-link-font-size, var(--framer-font-size));
    --text-transform: var(--framer-link-text-transform, var(--framer-text-transform));
    --text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration));
}`, EM = `
[data-framer-component-type="Text"] a:hover,
[data-framer-component-type="Text"] a div span:hover,
[data-framer-component-type="Text"] a span span span:hover,
[data-framer-component-type="Text"] a p span span:hover,
[data-framer-component-type="Text"] a h1 span span:hover,
[data-framer-component-type="Text"] a h2 span span:hover,
[data-framer-component-type="Text"] a h3 span span:hover,
[data-framer-component-type="Text"] a h4 span span:hover,
[data-framer-component-type="Text"] a h5 span span:hover,
[data-framer-component-type="Text"] a h6 span span:hover {
    --font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`, RM = `
[data-framer-component-type="Text"].isCurrent a,
[data-framer-component-type="Text"].isCurrent a div span,
[data-framer-component-type="Text"].isCurrent a span span span,
[data-framer-component-type="Text"].isCurrent a p span span,
[data-framer-component-type="Text"].isCurrent a h1 span span,
[data-framer-component-type="Text"].isCurrent a h2 span span,
[data-framer-component-type="Text"].isCurrent a h3 span span,
[data-framer-component-type="Text"].isCurrent a h4 span span,
[data-framer-component-type="Text"].isCurrent a h5 span span,
[data-framer-component-type="Text"].isCurrent a h6 span span {
    --font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`, PM = ['[data-framer-component-type="Text"] { cursor: inherit; }', "[data-framer-component-text-autosized] * { white-space: pre; }", xM, SM, wM, kM, CM, TM, EM, RM], _M = `
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > [data-framer-component-type] {
    position: relative;
}`, FM = (() => [`[data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: var(--stack-native-row-gap);
        column-gap: var(--stack-native-column-gap);
    }`, `.${Fi} [data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: unset;
        column-gap: unset;
    }`])(), IM = (() => `
.${Fi} [data-framer-legacy-stack-gap-enabled="true"] > *, [data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"] {
    margin-top: calc(var(--stack-gap-y) / 2);
    margin-bottom: calc(var(--stack-gap-y) / 2);
    margin-right: calc(var(--stack-gap-x) / 2);
    margin-left: calc(var(--stack-gap-x) / 2);
}
`)(), LM = (() => `
.${Fi}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child,
.${Fi}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child {
    margin-top: 0;
    margin-left: 0;
}`)(), MM = (() => `
.${Fi}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child,
.${Fi}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child {
    margin-right: 0;
    margin-bottom: 0;
}`)(), OM = (() => [_M, IM, ...FM, LM, MM])(), DM = [`
NavigationContainer
[data-framer-component-type="NavigationContainer"] > *,
[data-framer-component-type="NavigationContainer"] > [data-framer-component-type] {
    position: relative;
}`], AM = ['[data-framer-component-type="Scroll"]::-webkit-scrollbar { display: none; }', '[data-framer-component-type="ScrollContentWrapper"] > * { position: relative; }'], VM = ['[data-framer-component-type="NativeScroll"] { -webkit-overflow-scrolling: touch; }', '[data-framer-component-type="NativeScroll"] > * { position: relative; }', '[data-framer-component-type="NativeScroll"].direction-both { overflow-x: scroll; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-vertical { overflow-x: hidden; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-horizontal { overflow-x: scroll; overflow-y: hidden; }', '[data-framer-component-type="NativeScroll"].direction-vertical > * { width: 100% !important; }', '[data-framer-component-type="NativeScroll"].direction-horizontal > * { height: 100% !important; }', '[data-framer-component-type="NativeScroll"].scrollbar-hidden::-webkit-scrollbar { display: none; }'], BM = ['[data-framer-component-type="DeviceComponent"].no-device > * { width: 100% !important; height: 100% !important; }'], $M = ['[data-framer-component-type="PageContentWrapper"] > *, [data-framer-component-type="PageContentWrapper"] > [data-framer-component-type] { position: relative; }'], zM = ['[data-is-present="false"], [data-is-present="false"] * { pointer-events: none !important; }'], NM = ['[data-framer-cursor="pointer"] { cursor: pointer; }', '[data-framer-cursor="grab"] { cursor: grab; }', '[data-framer-cursor="grab"]:active { cursor: grabbing; }'], HM = ['[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }', "[data-framer-generated] * { pointer-events: unset }"], jM = [`[data-reset="button"] {
        border-width: 0;
        padding: 0;
        background: none;
}`], WM = ['[data-hide-scrollbars="true"]::-webkit-scrollbar { width: 0px; height: 0px; }', '[data-hide-scrollbars="true"]::-webkit-scrollbar-thumb { background: transparent; }'], UM = e => e ? HM : [], XM = [".svgContainer svg { display: block; }"], yw = e => [...bM, ...PM, ...gM, ...vM, ...OM, ...DM, ...AM, ...VM, ...$M, ...BM, ...zM, ...NM, ...UM(e), ...XM, ...jM, ...WM], YM = yw(!1), GM = yw(!0), K1 = !1; function Pa() { if (K1) return; K1 = !0; let e = oe.current() === oe.preview ? GM : YM; for (let t of e) gw(t, void 0, void 0) } function $o(e) { return typeof e == "function" } function bw(e) { return typeof e == "boolean" } function Ce(e) { return typeof e == "string" } function En(e) { return Number.isFinite(e) } function sm(e) { return Array.isArray(e) } function ke(e) { return e !== null && typeof e == "object" && !sm(e) } function at(e) { return typeof e > "u" } function Ae(e) { return e === null } function zo(e) { return at(e) || Ae(e) } function xw(e) { return e instanceof Date && !isNaN(e.getTime()) } function KM(e) { return ke(e) || $o(e) } var q1 = "optional"; function qM(e) { return !!e && q1 in e && e[q1] === !0 } function QM(e) { try { switch (e.type) { case "string": case "color": case "date": case "link": case "boxshadow": case "padding": case "borderradius": return Ce(e.defaultValue) ? e.defaultValue : void 0; case "boolean": return bw(e.defaultValue) ? e.defaultValue : void 0; case "enum": return at(e.defaultValue) ? void 0 : e.options.includes(e.defaultValue) ? e.defaultValue : void 0; case "fusednumber": case "number": return En(e.defaultValue) ? e.defaultValue : void 0; case "transition": return ke(e.defaultValue) ? e.defaultValue : void 0; case "border": return ke(e.defaultValue) ? e.defaultValue : void 0; case "font": return ke(e.defaultValue) ? e.defaultValue : void 0; case "object": { let t = ke(e.defaultValue) ? e.defaultValue : {}; return ke(e.controls) && Sw(t, e.controls), t } case "array": return sm(e.defaultValue) ? e.defaultValue : void 0; case "file": case "image": case "richtext": case "pagescope": case "eventhandler": case "segmentedenum": case "responsiveimage": case "componentinstance": case "scrollsectionref": case "customcursor": case "cursor": return; default: return } } catch { return } } function Sw(e, t) { for (let n in t) { let r = t[n]; if (!r) continue; let i = e[n]; if (!at(i) || qM(r)) continue; let o = QM(r); at(o) || (e[n] = o) } } function ZM(e) { if (ke(e.defaultProps)) return e.defaultProps; let t = {}; return e.defaultProps = t, t } function JM(e, t) { if (!KM(e)) return; let n = ZM(e); Sw(n, t) } function Oz(e, t) { Object.assign(e, { propertyControls: t }), JM(e, t) } function ww(e) { return e.propertyControls } var Be = e => e; function eO(e) { let t = Object.create(Object.prototype); return n => (t[n] === void 0 && (t[n] = e(n)), t[n]) } var tO = /^(?:children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|[dkrxyz]|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y1|y2|yChannelSelector|zoomAndPan|for|class|autofocus|(?:[Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*)$/, nO = eO(e => tO.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91), kw = b.createContext(void 0), Nz = (() => kw.Provider)(), rO = () => b.useContext(kw) ?? {}, iO = Dn(em(), 1), Un = typeof navigator < "u" ? navigator : void 0, mr = () => typeof document == "object"; var oO = () => Un && /Chrome/.test(Un.userAgent) && /Google Inc/.test(Un.vendor) && !lO(), sO = () => Un && /Safari/.test(Un.userAgent) && /Apple Computer/.test(Un.vendor); var aO = () => Un && /FramerX/.test(Un.userAgent), lO = () => Un && /Edg\//.test(Un.userAgent); var Cw = () => iO.default.env.NODE_ENV === "test"; var Q1 = e => () => { da(e) }, cO = () => () => { }, uO = { useImageSource(e) { return e.src ?? "" }, useImageElement(e, t, n) { let r = new Image; return r.src = Je.useImageSource(e, t, n), e.srcSet && (r.srcset = e.srcSet), r }, canRenderOptimizedCanvasImage() { return !1 } }, fO = !1, dO = { get(e, t, n) { return Reflect.has(e, t) ? Reflect.get(e, t, n) : ["getLogger"].includes(String(t)) ? cO() : Q1(fO ? `${String(t)} is not available in this version of Framer.` : `${String(t)} is only available inside of Framer. https://www.framer.com/`) } }, Je = new Proxy(uO, dO); function hO(e, t, n = 1) { let { width: r, height: i } = t, o = e.pixelWidth ?? e.intrinsicWidth ?? 0, s = e.pixelHeight ?? e.intrinsicHeight ?? 0; if (r < 1 || i < 1 || o < 1 || s < 1) return; r *= n, i *= n; let a = r / i, l = o / s; switch (e.fit) { case "fill": return l > a ? s / i : o / r; case "fit": case "stretch": return Math.max(o / r, s / i) } } function Z1(e, t) { return t && Math.max(1, e) > t ? "pixelated" : "auto" } var J1 = { position: "absolute", borderRadius: "inherit", top: 0, right: 0, bottom: 0, left: 0 }, pO = { backgroundSize: "16px 16px", backgroundImage: "repeating-linear-gradient(45deg, rgba(180, 180, 180, 0.8) 0, rgba(180, 180, 180, 0.8) 1px, rgba(255, 255, 255, 0.2) 0, rgba(255, 255, 255, 0.2) 50%)", border: "1px solid #c4c4c4" }; function mO(e) { switch (e) { case "fit": return "contain"; case "stretch": return "fill"; default: return "cover" } } function Tw(e, t) { let n = e ?? "center", r = t ?? "center"; return n === "center" && r === "center" ? "center" : n + " " + r } function vO(e, t) { if (!t) return "auto"; let n = oe.current() === oe.canvas ? Ve.devicePixelRatio : 1, r = hO(e, t, n); return oe.current() === oe.canvas ? Z1(1, r) : Z1(nu.zoom, r) } function am(e, t) { return { display: "block", width: "100%", height: "100%", borderRadius: "inherit", objectPosition: Tw(e.positionX, e.positionY), objectFit: mO(e.fit), imageRendering: vO(e, t) } } function gO({ image: e, containerSize: t, nodeId: n, alt: r }) { let i = Je.useImageSource(e, t, n), o = am(e, t), [s, a] = b.useState(), l = b.useRef(null), c = rO(); return b.useEffect(() => { if (!c.imgSizesWorkaroundEnabled) return; let u = l.current; if (!u || Cw() || !e.sizes || !u.closest("[data-framer-name]")) return; let d = u.clientWidth, p = Number(e.sizes.replace("px", "")); !isNaN(p) && d < p || a(d + "px") }, [e.sizes]), C("img", { ref: l, decoding: "async", loading: e.loading, sizes: s ?? e.sizes, srcSet: e.srcSet, src: i, alt: r ?? e.alt, style: o }) } function yO({ image: e, containerSize: t, nodeId: n }) { let r = b.useRef(null), i = Je.useImageElement(e, t, n), o = am(e, t); return b.useLayoutEffect(() => { let s = r.current; if (s !== null) return s.appendChild(i), () => { s.removeChild(i) } }, [i]), Object.assign(i.style, o), C("div", { ref: r, style: { display: "contents", borderRadius: "inherit" } }) } function bO({ nodeId: e, image: t, containerSize: n }) { let r = b.useRef(null), i = Je.useImageSource(t, n, e); return b.useLayoutEffect(() => { let o = r.current; if (o === null) return; let s = am(t, n); Je.renderOptimizedCanvasImage(o, i, s, e) }, [e, t, i, n]), C("div", { ref: r, style: { display: "contents", borderRadius: "inherit" } }) } function Ew({ layoutId: e, image: t, ...n }) { e && (e = e + "-background"); let r = { ...J1, ...pO }, i = null; if (Ce(t.src)) if (t.fit === "tile" && t.pixelWidth && t.pixelHeight) { let o = En(t.backgroundSize) ? t.backgroundSize : 1, s = { width: Math.round(o * t.pixelWidth), height: Math.round(o * t.pixelHeight) }, a = Je.useImageSource(t, s); r.backgroundImage = `url(${a})`, r.backgroundRepeat = "repeat", r.backgroundPosition = Tw(t.positionX, t.positionY), t.pixelWidth && (r.backgroundSize = `${(o * (t.pixelWidth / 2)).toFixed(2)}px auto`), r.border = 0, i = null } else oe.current() !== oe.canvas ? i = C(gO, { image: t, ...n }) : Je.canRenderOptimizedCanvasImage(Je.useImageSource(t)) ? i = C(bO, { image: t, ...n }) : i = C(yO, { image: t, ...n }); return C(Nt.div, { layoutId: e, style: i ? J1 : r, "data-framer-background-image-wrapper": !0, children: i }) } var xO = "src", Ei = { isImageObject: function (e) { return !e || typeof e == "string" ? !1 : xO in e } }; function SO(e, t) { let { _forwardedOverrideId: n, _forwardedOverrides: r, id: i } = t, o = n ?? i, s = r && o ? r[o] : void 0; return s && typeof s == "string" && (e = { ...e, src: s }), e } function wO(e) { let { background: t, image: n } = e; if (n !== void 0 && t && !Ei.isImageObject(t)) return; let r = null; if (Ce(n) ? r = { alt: "", src: n } : r = Ke.get(t, null), !!Ei.isImageObject(r)) return SO(r, e) } function kO(e, t, n = !0) { let { borderWidth: r, borderStyle: i, borderColor: o } = e; if (!r) return; let s, a, l, c; if (typeof r == "number" ? s = a = l = c = r : (s = r.top || 0, a = r.bottom || 0, l = r.left || 0, c = r.right || 0), !(s === 0 && a === 0 && l === 0 && c === 0)) { if (n && s === a && s === l && s === c) { t.border = `${s}px ${i} ${o}`; return } t.borderStyle = e.borderStyle, t.borderColor = e.borderColor, t.borderTopWidth = `${s}px`, t.borderBottomWidth = `${a}px`, t.borderLeftWidth = `${l}px`, t.borderRightWidth = `${c}px` } } function CO(e) { let t = e.layoutId ? `${e.layoutId}-border` : void 0; if (!e.borderWidth) return null; let n = { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, borderRadius: "inherit", pointerEvents: "none" }; return e.border ? (n.border = e.border, C(Nt.div, { style: n })) : (kO(e, n, !1), C(Nt.div, { "data-frame-border": !0, style: n, layoutId: t })) } function pu(e) { return e && e !== "search" && e !== "slot" && e !== "template" ? Nt[e] : Nt.div } var TO = oO(); function Rw(e) { let t = {}; return !TO || oe.current() !== oe.canvas || ((e === !0 || e === "x") && (t["data-framer-layout-hint-center-x"] = !0), (e === !0 || e === "y") && (t["data-framer-layout-hint-center-y"] = !0)), t } function lm(e) { return e.replace(/^id_/, "").replace(/\\/g, "") } function EO(e, t) { if (!t && (t = e.children, !t)) return { props: e, children: t }; let n = e._forwardedOverrides; return n ? (t = b.Children.map(t, r => b.isValidElement(r) ? b.cloneElement(r, { _forwardedOverrides: n }) : r), { props: e, children: t }) : { props: e, children: t } } function mu(e) { return (t, n) => e === !0 ? `translate(-50%, -50%) ${n}` : e === "x" ? `translateX(-50%) ${n}` : e === "y" ? `translateY(-50%) ${n}` : n || "none" } function _a(e, { specificLayoutId: t, postfix: n } = {}) { let { name: r, layoutIdKey: i, duplicatedFrom: o, __fromCodeComponentNode: s = !1, drag: a } = e, { getLayoutId: l, enabled: c } = O(Bo); return he(() => { if (!c) return e.layoutId; let u = t || e.layoutId; if (!u && (a || !i || s)) return; let f = u || l({ id: i, name: r, duplicatedFrom: o }); if (f) return n ? `${f}-${n}` : f }, [c]) } var Pw = typeof document < "u" ? Pn : H, jo = b.createContext(!1); function vu() { let [e, t] = b.useState(0); return b.useCallback(() => t(n => n + 1), []) } var RO = (() => JF().ResizeObserver)(); var PO = class { constructor() { R(this, "sharedResizeObserver"), R(this, "callbacks", new WeakMap); let e = Ve.ResizeObserver ?? RO; this.sharedResizeObserver = new e(this.updateResizedElements.bind(this)) } updateResizedElements(e) { for (let t of e) { let n = this.callbacks.get(t.target); n && n(t.contentRect) } } observeElementWithCallback(e, t) { this.sharedResizeObserver.observe(e), this.callbacks.set(e, t) } unobserve(e) { this.sharedResizeObserver.unobserve(e), this.callbacks.delete(e) } }, Hc = (() => mr() ? new PO : void 0)(); function _O(e) { let t = vu(); H(() => { let n = e?.current; if (n) return Hc?.observeElementWithCallback(e.current, t), () => { Hc?.unobserve(n) } }, [e, t]) } var FO = "data-framer-size-compatibility-wrapper"; function IO(e) { return [...e.firstElementChild && e.firstElementChild.hasAttribute(FO) ? e.firstElementChild.children : e.children].filter(_w).map(Fw) } function _w(e) { return e instanceof HTMLBaseElement || e instanceof HTMLHeadElement || e instanceof HTMLLinkElement || e instanceof HTMLMetaElement || e instanceof HTMLScriptElement || e instanceof HTMLStyleElement || e instanceof HTMLTitleElement ? !1 : e instanceof HTMLElement || e instanceof SVGElement } function Fw(e) { if (!(e instanceof HTMLElement) || e.children.length === 0 || e.style.display !== "contents") return e; let t = [...e.children].find(_w); return t ? Fw(t) : e } function gu(e, t, n = () => [], r = {}) { let { id: i, visible: o, _needsMeasure: s } = e, { skipHook: a = !1 } = r, l = !!O(jo), c = oe.current() === oe.canvas; Pw(() => { !c || l || a || t.current && i && o && s && Je.queueMeasureRequest(lm(i), t.current, n(t.current)) }) } function LO(e) { let t = e.closest("[data-framer-component-container]"); t && Je.queueMeasureRequest(lm(t.id), t, IO(t)) } var Ii = Object.keys; function pa(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function eS(e) { return pa(e, "equals") ? typeof e.equals == "function" : !1 } function cm(e, t) { return e === t ? !0 : e !== e && t !== t } function MO(e, t) { let n = e.length; if (n !== t.length) return !1; for (let r = n; r-- !== 0;)if (!cm(e[r], t[r])) return !1; return !0 } function OO(e, t) { let n = e.length; if (n !== t.length) return !1; for (let r = n; r-- !== 0;)if (!yu(e[r], t[r], !0)) return !1; return !0 } function DO(e, t) { if (e.size !== t.size) return !1; for (let [n, r] of e.entries()) if (!cm(r, t.get(n))) return !1; return !0 } function AO(e, t) { if (e.size !== t.size) return !1; for (let [n, r] of e.entries()) if (!yu(r, t.get(n), !0)) return !1; return !0 } function VO(e, t) { if (e.size !== t.size) return !1; for (let n of e.keys()) if (!t.has(n)) return !1; return !0 } function BO(e, t) { let n = Ii(e); if (n.length !== Ii(t).length) return !1; for (let r of n) { if (!pa(t, r)) return !1; if (!(r === "_owner" && pa(e, "$$typeof") && e.$$typeof) && !cm(e[r], t[r])) return !1 } return !0 } function $O(e, t) { let n = Ii(e); if (n.length !== Ii(t).length) return !1; for (let r of n) { if (!pa(t, r)) return !1; if (!(r === "_owner" && pa(e, "$$typeof") && e.$$typeof) && !yu(e[r], t[r], !0)) return !1 } return !0 } function yu(e, t, n) { if (e === t) return !0; if (!e || !t) return e !== e && t !== t; let r = typeof e; if (r !== typeof t || r !== "object") return !1; let o = Array.isArray(e), s = Array.isArray(t); if (o && s) return n ? OO(e, t) : MO(e, t); if (o !== s) return !1; let a = e instanceof Map, l = t instanceof Map; if (a && l) return n ? AO(e, t) : DO(e, t); if (a !== l) return !1; let c = e instanceof Set, u = t instanceof Set; if (c && u) return VO(e, t); if (c !== u) return !1; let f = e instanceof Date, d = t instanceof Date; if (f && d) return e.getTime() === t.getTime(); if (f !== d) return !1; let p = e instanceof RegExp, g = t instanceof RegExp; return p && g ? e.toString() === t.toString() : p !== g ? !1 : eS(e) && eS(t) ? e.equals(t) : n ? $O(e, t) : BO(e, t) } function $e(e, t, n = !0) { try { return yu(e, t, n) } catch (r) { if (r instanceof Error && /stack|recursion/iu.exec(r.message)) return console.warn("Warning: isEqual does not handle circular references.", r.name, r.message), !1; throw r } } var Iw = "0.000001px", Fp = (() => ` translateZ(${Iw})`)(), Lw = (() => aO() || sO() || Cw())(); function zO(e) { e.willChange = "transform"; let t = oe.current() === oe.canvas; Lw && t && (e.translateZ = Iw) } function um(e) { e.willChange = "transform", NO(e, !0) } function NO(e, t) { let n = oe.current() === oe.canvas; if (!Lw || !n) return; let r = Ce(e.transform) && e.transform || ""; t ? r.includes(Fp) || (e.transform = r + Fp) : e.transform = r.replace(Fp, "") } function Mw(e, t, n, r = !0) { if (!e) return; let i = Be(e.style), o = n || i[t], s = () => { i[t] = o }; i[t] = null, r ? Promise.resolve().then(s) : setTimeout(s, 0) } var qc = (() => { class e extends ve { constructor() { super(...arguments), R(this, "layerElement", null), R(this, "setLayerElement", n => { this.layerElement = n }) } static applyWillChange(n, r, i) { n.willChangeTransform && (i ? zO(r) : um(r)) } shouldComponentUpdate(n, r) { return n._needsMeasure || this.state !== r || !$e(this.props, n) } componentDidUpdate(n) { Be(this.props).clip && Be(this.props).radius === 0 && Be(n).radius !== 0 && Mw(this.layerElement, "overflow", "hidden", !1) } } return R(e, "defaultProps", {}), e })(); function HO(e, t) { if (e.size < t) return; let r = Math.round(Math.random()); for (let i of e.keys()) (++r & 1) !== 1 && e.delete(i) } function jO(e, t, n, r) { let i = t.get(n); if (i) return i; HO(t, e); let o = r(n); return t.set(n, o), o } var Ow = e => { let t = 0, n, r; if (e.length === 0) return t; for (n = 0; n < e.length; n++)r = e.charCodeAt(n), t = (t << 5) - t + r, t |= 0; return t }, fm = { hueRotate: (e, t) => W.toHslString(W.hueRotate(W(e), t)), setAlpha: (e, t) => W.toRgbString(W.alpha(W(e), t)), getAlpha: e => { let t = om(e); return t ? t.a : 1 }, multiplyAlpha: (e, t) => W.toRgbString(W.multiplyAlpha(W(e), t)), toHex: e => W.toHexString(W(e)).toUpperCase(), toRgb: e => W.toRgb(W(e)), toRgbString: e => W.toRgbString(W(e)), toHSV: e => W.toHsv(W(e)), toHSL: e => W.toHsl(W(e)), toHslString: e => W.toHslString(W(e)), toHsvString: e => W.toHsvString(W(e)), hsvToHSLString: e => W.toHslString(W(zc(e.h, e.s, e.v, e.a))), hsvToHex: e => W.toHexString(W(zc(e.h, e.s, e.v, e.a))).toUpperCase(), hsvToRgbString: e => W.toRgbString(W(zc(e.h, e.s, e.v, e.a))), hsvToString: e => zc(e.h, e.s, e.v), rgbaToString: e => W.toRgbString(W(e)), rgbToHexString: e => W.toHexString(W(e)), hslToString: e => W.toHslString(W(e)), hslToRgbString: e => W.toRgbString(W(e)), toColorPickerSquare: e => W.toRgbString(W({ h: e, s: 1, l: .5, a: 1 })), isValid: e => W(e).isValid !== !1, equals: (e, t) => (typeof e == "string" && (e = W(e)), typeof t == "string" && (t = W(t)), W.equal(e, t)), toHexOrRgbaString: e => { let t = W(e); return t.a !== 1 ? W.toRgbString(t) : W.toHexString(t) } }, WO = /var\(.+\)/, UO = new Map; function XO(e, t) { let n = [e, t]; return WO.test(e) ? e : jO(1e3, UO, n, () => fm.multiplyAlpha(e, t)) } function Fa(e, t = 1) { let n; return "stops" in e ? n = e.stops : n = [{ value: e.start, position: 0 }, { value: e.end, position: 1 }], t === 1 ? n : n.map(r => ({ ...r, value: XO(r.value, t) })) } function Dw(e, t) { let n = 0; return Fa(e, t).forEach(r => { n ^= Ow(r.value) ^ r.position }), n } var YO = ["stops"]; function Aw(e) { return e && YO.every(t => t in e) } var GO = ["start", "end"]; function Vw(e) { return e && GO.every(t => t in e) } var KO = ["angle", "alpha"], ma = { isLinearGradient: e => e && KO.every(t => t in e) && (Vw(e) || Aw(e)), hash: e => e.angle ^ Dw(e, e.alpha), toCSS: (e, t) => { let n = Fa(e, e.alpha), r = t !== void 0 ? t : e.angle, i = n.map(o => `${o.value} ${o.position * 100}%`); return `linear-gradient(${r}deg, ${i.join(", ")})` } }, qO = ["widthFactor", "heightFactor", "centerAnchorX", "centerAnchorY", "alpha"], va = { isRadialGradient: e => e && qO.every(t => t in e) && (Vw(e) || Aw(e)), hash: e => e.centerAnchorX ^ e.centerAnchorY ^ e.widthFactor ^ e.heightFactor ^ Dw(e, e.alpha), toCSS: e => { let { alpha: t, widthFactor: n, heightFactor: r, centerAnchorX: i, centerAnchorY: o } = e, s = Fa(e, t), a = s.map((l, c) => { let u = s[c + 1], f = l.position === 1 && u?.position === 1 ? l.position - 1e-4 : l.position; return `${l.value} ${f * 100}%` }); return `radial-gradient(${n * 100}% ${r * 100}% at ${i * 100}% ${o * 100}%, ${a.join(", ")})` } }; function QO({ background: e, backgroundColor: t }, n) { t ? typeof t == "string" || U1(t) ? n.backgroundColor = t : W.isColorObject(e) && (n.backgroundColor = e.initialValue || W.toRgbString(e)) : e && (e = Ke.get(e, null), typeof e == "string" || U1(e) ? n.background = e : ma.isLinearGradient(e) ? n.background = ma.toCSS(e) : va.isRadialGradient(e) ? n.background = va.toCSS(e) : W.isColorObject(e) && (n.backgroundColor = e.initialValue || W.toRgbString(e))) } function ue(e, t, n, r) { if (r === void 0 && (r = t), e[t] !== void 0) { n[r] = e[t]; return } } function ZO(e) { return e ? e.left !== void 0 && e.right !== void 0 : !1 } function JO(e) { return e ? e.top !== void 0 && e.bottom !== void 0 : !1 } function eD(e) { if (!e) return {}; let t = {}; return e.preserve3d === !0 ? t.transformStyle = "preserve-3d" : e.preserve3d === !1 && (t.transformStyle = "flat"), e.backfaceVisible === !0 ? t.backfaceVisibility = "visible" : e.backfaceVisible === !1 && (t.backfaceVisibility = "hidden"), t.backfaceVisibility && (t.WebkitBackfaceVisibility = t.backfaceVisibility), e.perspective !== void 0 && (t.perspective = t.WebkitPerspective = e.perspective), e.__fromCanvasComponent || (e.center === !0 ? (t.left = "50%", t.top = "50%") : e.center === "x" ? t.left = "50%" : e.center === "y" && (t.top = "50%")), ue(e, "size", t), ue(e, "width", t), ue(e, "height", t), ue(e, "minWidth", t), ue(e, "minHeight", t), ue(e, "top", t), ue(e, "right", t), ue(e, "bottom", t), ue(e, "left", t), ue(e, "position", t), ue(e, "overflow", t), ue(e, "opacity", t), (!e._border || !e._border.borderWidth) && ue(e, "border", t), ue(e, "borderRadius", t), ue(e, "radius", t, "borderRadius"), ue(e, "color", t), ue(e, "shadow", t, "boxShadow"), ue(e, "x", t), ue(e, "y", t), ue(e, "z", t), ue(e, "rotate", t), ue(e, "rotateX", t), ue(e, "rotateY", t), ue(e, "rotateZ", t), ue(e, "scale", t), ue(e, "scaleX", t), ue(e, "scaleY", t), ue(e, "skew", t), ue(e, "skewX", t), ue(e, "skewY", t), ue(e, "originX", t), ue(e, "originY", t), ue(e, "originZ", t), QO(e, t), t } function tD(e) { for (let t in e) if (t === "drag" || t.startsWith("while") || typeof Be(e)[t] == "function" && t.startsWith("on") && !t.includes("Animation")) return !0; return !1 } var tS = ["onClick", "onDoubleClick", "onMouse", "onMouseDown", "onMouseUp", "onTapDown", "onTap", "onTapUp", "onPointer", "onPointerDown", "onPointerUp", "onTouch", "onTouchDown", "onTouchUp"], nD = (() => new Set([...tS, ...tS.map(e => `${e}Capture`)]))(); function rD(e) { if (e.drag) return "grab"; for (let t in e) if (nD.has(t)) return "pointer" } var Ip = "overflow"; function iD(e) { return nS(e) ? !0 : e.style ? !!nS(e.style) : !1 } function nS(e) { return Ip in e && (e[Ip] === "scroll" || e[Ip] === "auto") } function Bw(e) { let { left: t, top: n, bottom: r, right: i, width: o, height: s, center: a, _constraints: l, size: c, widthType: u, heightType: f, positionFixed: d, positionAbsolute: p } = e, g = ft(e.minWidth), v = ft(e.minHeight), S = ft(e.maxWidth), m = ft(e.maxHeight); return { top: ft(n), left: ft(t), bottom: ft(r), right: ft(i), width: ft(o), height: ft(s), size: ft(c), center: a, _constraints: l, widthType: u, heightType: f, positionFixed: d, positionAbsolute: p, minWidth: g, minHeight: v, maxWidth: S, maxHeight: m } } var rS = { x: 0, y: 0, width: 200, height: 200 }; function oD(e) { b.useInsertionEffect(() => { Pa() }, []); let t = !!O(jo), { style: n, _initialStyle: r, __fromCanvasComponent: i, size: o } = e, s = Bw(e), a = QL(s), l = { display: "block", flex: n?.flex ?? "0 0 auto", userSelect: oe.current() !== oe.preview ? "none" : void 0 }; e.__fromCanvasComponent || (l.backgroundColor = e.background === void 0 ? "rgba(0, 170, 255, 0.3)" : void 0); let c = !tD(e) && !e.__fromCanvasComponent && !iD(e), u = e.style ? !("pointerEvents" in e.style) : !0; c && u && (l.pointerEvents = "none"); let d = b.Children.count(e.children) > 0 && b.Children.toArray(e.children).every(m => typeof m == "string" || typeof m == "number") && { display: "flex", alignItems: "center", justifyContent: "center", textAlign: "center" }, p = eD(e); o === void 0 && !i && (ZO(p) || (l.width = rS.width), JO(p) || (l.height = rS.height)), s.minWidth !== void 0 && (l.minWidth = s.minWidth), s.minHeight !== void 0 && (l.minHeight = s.minHeight); let g = {}; Ea(s) && a && !$w(e) && (g = { left: a.x, top: a.y, width: a.width, height: a.height, right: void 0, bottom: void 0 }), Object.assign(l, d, r, p, g, n), Object.assign(l, { overflowX: l.overflowX ?? l.overflow, overflowY: l.overflowY ?? l.overflow, overflow: void 0 }), qc.applyWillChange(e, l, !0); let v = l; l.transform || (v = { x: 0, y: 0, ...l }); let S = oe.current() === oe.canvas; return e.positionSticky ? (!S || t) && (v.position = "sticky", v.willChange = "transform", v.zIndex = 1, v.top = e.positionStickyTop, v.right = e.positionStickyRight, v.bottom = e.positionStickyBottom, v.left = e.positionStickyLeft) : S && (e.positionFixed || e.positionAbsolute) && (v.position = "absolute"), "rotate" in v && v.rotate === void 0 && delete v.rotate, [v, a] } var sD = new Set(["width", "height", "opacity", "overflow", "radius", "background", "color", "x", "y", "z", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "skew", "skewX", "skewY", "originX", "originY", "originZ"]); function aD(e) { let t = {}; for (let n in e) (Hi(n) || nO(n)) && !sD.has(n) ? t[n] = Be(e)[n] : (n === "positionTransition" || n === "layoutTransition") && (t.layout = !0, typeof Be(e)[n] != "boolean" && !e.transition && (t.transition = Be(e)[n])); return t } function lD(e) { return "data-framer-name" in e } var cD = Ne(function (t, n) { let { name: r, center: i, border: o, _border: s, __portal: a } = t, { props: l, children: c } = EO(t), u = aD(l), f = _a(t), d = rD(t), p = D(null), g = n ?? p, v = { "data-framer-component-type": t.componentType ?? "Frame", "data-framer-cursor": d, "data-framer-highlight": d === "pointer" ? !0 : void 0, "data-layoutid": f, "data-framer-offset-parent-id": Be(t)["data-framer-offset-parent-id"] }; !lD(t) && r && (Be(v)["data-framer-name"] = r); let [S, m] = oD(l), h = Bw(l), y = $w(h); i && !(m && !y && Ea(h)) ? (u.transformTemplate || (u.transformTemplate = mu(i)), Object.assign(v, Rw(i))) : u.transformTemplate || (u.transformTemplate = void 0), gu(t, g); let x = wO(t), k = !!O(jo), w = uD(l, h, m, k), T = qL(ae(Le, { children: [x ? C(Ew, { alt: t.alt ?? "", image: x, containerSize: m ?? void 0, nodeId: t.id && lm(t.id), layoutId: f }) : null, c, C(CO, { ...s, border: o, layoutId: f })] }), w), E = pu(t.as), { size: I, radius: F, shadow: B } = S; return I !== void 0 && (delete S.size, S.height === void 0 && (S.height = I), S.width === void 0 && (S.width = I)), F !== void 0 && (delete S.radius, S.borderRadius = F), B !== void 0 && (delete S.shadow, S.boxShadow = B), ae(E, { ...v, ...u, layoutId: f, style: S, ref: g, children: [T, a] }) }), Qc = Ne(function (t, n) { let { visible: r = !0 } = t; return r ? C(cD, { ...t, ref: n }) : null }); function uD(e, t, n, r) { if (r) return n ? { width: n.width, height: n.height } : 1; let { _usesDOMRect: i } = e, { widthType: o = 0, heightType: s = 0, width: a, height: l } = t; return n && !i ? n : o === 0 && s === 0 && typeof a == "number" && typeof l == "number" ? { width: a, height: l } : i || e.positionFixed || e.positionAbsolute ? 2 : 0 } function $w({ width: e, height: t }) { return e === "auto" || e === "min-content" || t === "auto" || t === "min-content" } var dm = "__LAYOUT_TREE_ROOT", zw = b.createContext({ schedulePromoteTree: () => { }, scheduleProjectionDidUpdate: () => { }, initLead: () => { } }), fD = class extends ve { constructor() { super(...arguments), R(this, "shouldAnimate", !1), R(this, "transition"), R(this, "lead"), R(this, "follow"), R(this, "scheduledPromotion", !1), R(this, "scheduledDidUpdate", !1), R(this, "scheduleProjectionDidUpdate", () => { this.scheduledDidUpdate = !0 }), R(this, "schedulePromoteTree", (e, t, n) => { this.follow = this.lead, this.shouldAnimate = n, this.lead = e, this.transition = t, this.scheduledPromotion = !0 }), R(this, "initLead", (e, t) => { this.follow = this.lead, this.lead = e, this.follow && t && (this.follow.layoutMaybeMutated = !0) }), R(this, "sharedLayoutContext", { schedulePromoteTree: this.schedulePromoteTree, scheduleProjectionDidUpdate: this.scheduleProjectionDidUpdate, initLead: this.initLead }) } getSnapshotBeforeUpdate() { var e; if (!this.scheduledPromotion || !this.lead || !this.follow) return null; let t = !!((e = this.lead) != null && e.layoutMaybeMutated) && !this.shouldAnimate; return this.lead.projectionNodes.forEach(n => { var r; n?.promote({ needsReset: t, transition: this.shouldAnimate ? this.transition : void 0, preserveFollowOpacity: n.options.layoutId === dm && !((r = this.follow) != null && r.isExiting) }) }), this.shouldAnimate ? this.follow.layoutMaybeMutated = !0 : this.scheduleProjectionDidUpdate(), this.lead.layoutMaybeMutated = !1, this.transition = void 0, this.scheduledPromotion = !1, null } componentDidUpdate() { var e, t; if (!this.lead) return null; this.scheduledDidUpdate && ((t = (e = this.lead.rootProjectionNode) == null ? void 0 : e.root) == null || t.didUpdate(), this.scheduledDidUpdate = !1) } render() { return C(zw.Provider, { value: this.sharedLayoutContext, children: this.props.children }) } }, dD = { width: "100%", height: "100%", backgroundColor: "none" }; function hD(e) { return C(Nt.div, { layoutId: dm, style: dD, children: e.children }) } var pD = class { constructor(e) { R(this, "sharedIntersectionObserver"), R(this, "callbacks", new WeakMap), document && (this.sharedIntersectionObserver = new IntersectionObserver(this.resizeObserverCallback.bind(this), e)) } resizeObserverCallback(e, t) { for (let n of e) { let r = this.callbacks.get(n.target); r && r([n], t) } } observeElementWithCallback(e, t) { this.sharedIntersectionObserver && (this.sharedIntersectionObserver.observe(e), this.callbacks.set(e, t)) } unobserve(e) { this.sharedIntersectionObserver && (this.sharedIntersectionObserver.unobserve(e), this.callbacks.delete(e)) } get root() { var e; return (e = this.sharedIntersectionObserver) == null ? void 0 : e.root } }, mD = b.createContext(new Map); function vD(e, t, n) { if (typeof IntersectionObserver > "u") return; let r = Rt(() => `${n.rootMargin}`), i = b.useContext(mD), { enabled: o } = n; b.useEffect(() => { var s; let a = e.current; if (!o || !a) return; let l = i.get(r); if (!l || l.root !== ((s = n.root) == null ? void 0 : s.current)) { let { root: c, ...u } = n; l = new pD({ ...u, root: c?.current }), i.set(r, l) } return l.observeElementWithCallback(a, t), () => l?.unobserve(a) }, [o]) } var gD = new Array(100).fill(void 0).map((e, t) => t * .01), yD = b.createContext(null); function bD(e, t, n) { let r = b.useRef({ isInView: !1, hasAnimatedOnce: !1 }), { enabled: i, animateOnce: o, threshold: s, rootMargin: a = "0px 0px 0px 0px" } = n, l = b.useCallback(([c]) => { if (!c) return; let { isInView: u, hasAnimatedOnce: f } = r.current, d = SD(c, s?.y ?? 0); if (d && !u) { if (o && f) return; r.current.hasAnimatedOnce = !0, r.current.isInView = !0, t(!0); return } if (!d && u) { if (r.current.isInView = !1, o) return; t(!1); return } }, [o, s?.y, t]); vD(e, l, { threshold: gD, rootMargin: a, enabled: i ?? !0 }) } function xD(e, t) { return t.height === 0 ? 0 : e.height / Math.min(t.height, Ve.innerHeight) } function SD({ boundingClientRect: e, intersectionRect: t, isIntersecting: n }, r) { return e.height === 0 ? n : n && xD(t, e) >= r } var f6 = Dn(fu(), 1); var h6 = Dn(fu(), 1); var iS = (e, t) => Object.prototype.hasOwnProperty.call(e, t), dr = Symbol("private"), Lp = (() => { function e(t = {}, n = !1, r = !0) { let i = { [dr]: { makeAnimatables: n, observeAnimatables: r, observers: new lw, reset() { for (let s in o) if (iS(o, s)) { let a = iS(t, s) ? Be(t)[s] : void 0; a !== void 0 ? o[s] = a : delete o[s] } }, transactions: new Set } }, o = new Proxy(i, kD); return Object.assign(o, t), o } return e.resetObject = t => t[dr].reset(), e.addObserver = (t, n) => t[dr].observers.add(n), e })(), wD = class { constructor() { R(this, "set", (e, t, n, r) => { if (t === dr) return !1; let i = e[dr], o, s; if (Tn(n) ? (o = n, s = o.get()) : s = n, i.makeAnimatables && typeof n != "function" && typeof n != "object" && !o && (o = Ke(n)), i.observeAnimatables && o) { let u = i.transactions; o.onUpdate({ update: (f, d) => { d && u.add(d), i.observers.notify({ value: r }, d) }, finish: f => { u.delete(f) && i.observers.finishTransaction(f) } }) } let a = !1, l = !0, c = Be(e)[t]; if (c !== void 0) { Tn(c) ? (l = c.get() !== s, c.set(s)) : (l = c !== s, Be(e)[t] = s); let u = s !== null && typeof s == "object"; (Array.isArray(s) || u) && (l = !0), a = !0 } else o && (n = o), a = Reflect.set(e, t, n); return l && i.observers.notify({ value: r }), a }), R(this, "get", (e, t, n) => { if (t === dr) return Be(e)[t]; let r = Reflect.get(e, t, n); return typeof r == "function" ? r.bind(n) : r }) } deleteProperty(e, t) { let n = Reflect.deleteProperty(e, t); return e[dr].observers.notify({ value: e }), n } ownKeys(e) { let t = Reflect.ownKeys(e), n = t.indexOf(dr); return n !== -1 && t.splice(n, 1), t } getOwnPropertyDescriptor(e, t) { if (t !== dr) return Reflect.getOwnPropertyDescriptor(e, t) } }, kD = new wD; var CD = "opacity"; function TD(e) { return CD in e } function ED(e, t) { if (!TD(e)) return; let n = Ke.getNumber(e.opacity); n !== 1 && (t.opacity = n) } function RD(e) { let t = []; if (e && e.length) { let n = e.map(r => `drop-shadow(${r.x}px ${r.y}px ${r.blur}px ${r.color})`); t.push(...n) } return t } function Nw(e, t) { if (!e.shadows || e.shadows.length === 0) return; let n = e.shadows.map(r => `${r.x}px ${r.y}px ${r.blur}px ${r.color}`).join(", "); n && (t.textShadow = n) } function PD(e, t) { let n = []; Q(e.brightness) && n.push(`brightness(${e.brightness / 100})`), Q(e.contrast) && n.push(`contrast(${e.contrast / 100})`), Q(e.grayscale) && n.push(`grayscale(${e.grayscale / 100})`), Q(e.hueRotate) && n.push(`hue-rotate(${e.hueRotate}deg)`), Q(e.invert) && n.push(`invert(${e.invert / 100})`), Q(e.saturate) && n.push(`saturate(${e.saturate / 100})`), Q(e.sepia) && n.push(`sepia(${e.sepia / 100})`), Q(e.blur) && n.push(`blur(${e.blur}px)`), e.dropShadows && n.push(...RD(e.dropShadows)), n.length !== 0 && (t.filter = t.WebkitFilter = n.join(" ")) } function _D(e, t) { Q(e.backgroundBlur) && (t.backdropFilter = t.WebkitBackdropFilter = `blur(${e.backgroundBlur}px)`) } function hm(e, t) { _D(e, t), PD(e, t) } var FD = class extends ve { constructor() { super(...arguments), R(this, "layoutMaybeMutated"), R(this, "projectionNodes", new Map), R(this, "rootProjectionNode"), R(this, "isExiting"), R(this, "shouldPreserveFollowOpacity", e => e.options.layoutId === dm && !this.props.isExiting), R(this, "switchLayoutGroupContext", { register: e => this.addChild(e), deregister: e => this.removeChild(e), transition: this.props.isLead !== void 0 && this.props.animatesLayout ? this.props.transition : void 0, shouldPreserveFollowOpacity: this.shouldPreserveFollowOpacity }) } componentDidMount() { this.props.isLead && this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout) } shouldComponentUpdate(e) { let { isLead: t, isExiting: n, isOverlayed: r, animatesLayout: i, transition: o, sharedLayoutContext: s } = e; if (this.isExiting = n, t === void 0) return !0; let a = !this.props.isLead && !!t, l = this.props.isExiting && !n, c = a || l, u = !!this.props.isLead && !t, f = this.props.isOverlayed !== r; return (c || u) && this.projectionNodes.forEach(d => d?.willUpdate()), c ? s.schedulePromoteTree(this, o, !!i) : f && s.scheduleProjectionDidUpdate(), !!c && !!i } addChild(e) { let t = e.options.layoutId; t && (this.projectionNodes.set(t, e), this.setRootChild(e)) } setRootChild(e) { if (!this.rootProjectionNode) return this.rootProjectionNode = e; this.rootProjectionNode = this.rootProjectionNode.depth < e.depth ? this.rootProjectionNode : e } removeChild(e) { let t = e.options.layoutId; t && this.projectionNodes.delete(t) } render() { return C(nl.Provider, { value: this.switchLayoutGroupContext, children: this.props.children }) } }, ID = e => { let t = b.useContext(zw); return C(FD, { ...e, sharedLayoutContext: t }) }, LD = b.createContext(!0); function MD() { return new Map } function OD() { return Rt(MD) } var Hw = ge({ register: () => { }, deregister: () => { } }), DD = ({ isCurrent: e, isOverlayed: t, children: n }) => { let r = OD(), i = pe(a => { if (r.has(a)) { console.warn("NavigationTargetWrapper: already registered"); return } r.set(a, void 0) }, [r]), o = pe(a => { let l = r.get(a); l?.(), r.delete(a) }, [r]), s = D({ register: i, deregister: o }).current; return H(() => (r.forEach((a, l) => { let c = l(e, t); r.set(l, $o(c) ? c : void 0) }), () => { r.forEach((a, l) => { a && (a(), r.set(l, void 0)) }) }), [e, t, r]), C(Hw.Provider, { value: s, children: n }) }; function jw(e, t = []) { let { register: n, deregister: r } = O(Hw); H(() => { if (e) return n(e), () => r(e) }, [n, r, ...t]) } var Mp = b.memo(function ({ isLayeredContainer: t, isCurrent: n, isPrevious: r, isOverlayed: i = !1, visible: o, transitionProps: s, children: a, backdropColor: l, onTapBackdrop: c, backfaceVisible: u, exitBackfaceVisible: f, animation: d, exitAnimation: p, instant: g, initialProps: v, exitProps: S, position: m = { top: 0, right: 0, bottom: 0, left: 0 }, withMagicMotion: h, index: y, areMagicMotionLayersPresent: x, id: k, isInitial: w }) { let T = e0(), E = O(Ui), { persistLayoutIdCache: I } = O(Bo), F = D({ wasCurrent: void 0, wasPrevious: !1, wasBeingRemoved: !1, wasReset: !0, origins: oS({}, v, s) }), B = D(null), V = E !== null && !E.isPresent; n && F.current.wasCurrent === void 0 && I(), H(() => { if (t || !T) return; if (V) { F.current = { ...F.current, wasBeingRemoved: V }; return } let { wasPrevious: te, wasCurrent: re } = F.current, Qt = n && !re || !V && F.current.wasBeingRemoved && n, fe = r && !te, Pt = oS(F.current.origins, v, s), ee = F.current.wasReset; Qt || fe ? (T.stop(), T.start({ zIndex: y, ...Pt, ...s }), ee = !1) : ee === !1 && (T.stop(), T.set({ zIndex: y, ...Ri, opacity: 0 }), ee = !0), F.current = { wasCurrent: !!n, wasPrevious: !!r, wasBeingRemoved: !1, wasReset: ee, origins: Pt } }, [n, r, V]); let K = g ? { type: !1 } : "velocity" in d ? { ...d, velocity: 0 } : d, Z = g ? { type: !1 } : p || d, j = { ...m }; (j.left === void 0 || j.right === void 0) && (j.width = "auto"), (j.top === void 0 || j.bottom === void 0) && (j.height = "auto"); let U = (sS(s) || sS(v)) && (t || n || r) ? 1200 : void 0, X = { ...Ri, ...F.current.origins }, z = t ? { initial: { ...X, ...v }, animate: { ...X, ...s, transition: K }, exit: { ...X, ...S, transition: d } } : { animate: T, exit: { ...X, ...S, transition: Z } }, J = !(V || x === !1), ie = !!n && J; return ae(Qc, { "data-framer-component-type": "NavigationContainerWrapper", width: "100%", height: "100%", style: { position: "absolute", transformStyle: "flat", backgroundColor: "transparent", overflow: "hidden", zIndex: t || V || n && h ? y : void 0, pointerEvents: void 0, visibility: o ? "visible" : "hidden", perspective: U }, children: [t && C(Qc, { width: "100%", height: "100%", "data-framer-component-type": "NavigationContainerBackdrop", transition: d, initial: { opacity: g && o ? 1 : 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, backgroundColor: l || "transparent", onTap: V ? void 0 : c }), C(Qc, { ...j, ...z, transition: { default: K, originX: { type: !1 }, originY: { type: !1 }, originZ: { type: !1 } }, backgroundColor: "transparent", backfaceVisible: V ? f : u, "data-framer-component-type": "NavigationContainer", "data-framer-is-current-navigation-target": !!n, style: { pointerEvents: void 0, opacity: n && w || t || n && h ? 1 : 0 }, "data-is-present": J ? void 0 : !1, ref: B, children: C(yD.Provider, { value: B, children: C(LD.Provider, { value: ie, children: C(DD, { isCurrent: ie, isOverlayed: i, children: C(ID, { isLead: n, animatesLayout: !!h, transition: K, isExiting: !J, isOverlayed: i, id: k, children: a }) }) }) }) })] }) }, AD); function AD(e, t) { return !(t.isCurrent === void 0 || e.isCurrent !== t.isCurrent || e.isPrevious !== t.isPrevious || t.isCurrent && e.isOverlayed !== t.isOverlayed) } function oS(e, t, n) { let r = { ...e }; return t && (Q(t.originX) && (r.originX = t.originX), Q(t.originY) && (r.originY = t.originY), Q(t.originZ) && (r.originZ = t.originZ)), n && (Q(n.originX) && (r.originX = n.originX), Q(n.originY) && (r.originY = n.originY), Q(n.originZ) && (r.originZ = n.originZ)), r } function sS(e) { var t, n, r; if (!e || !("rotateX" in e || "rotateY" in e || "z" in e)) return !1; let o = e.rotateX !== 0 || e.rotateY !== 0 || e.z !== 0, s = ((t = e?.transition) == null ? void 0 : t.rotateX.from) !== 0 || ((n = e?.transition) == null ? void 0 : n.rotateY.from) !== 0 || ((r = e?.transition) == null ? void 0 : r.z.from) !== 0; return o || s } var Ri = { x: 0, y: 0, z: 0, rotate: 0, rotateX: 0, rotateY: 0, rotateZ: 0, scale: 1, scaleX: 1, scaleY: 1, scaleZ: 1, skew: 0, skewX: 0, skewY: 0, originX: .5, originY: .5, originZ: 0, opacity: 1 }, VD = class { constructor() { R(this, "warning", () => { da("The Navigator API is only available inside of Framer: https://www.framer.com/") }), R(this, "goBack", () => this.warning()), R(this, "instant", () => this.warning()), R(this, "fade", () => this.warning()), R(this, "push", () => this.warning()), R(this, "modal", () => this.warning()), R(this, "overlay", () => this.warning()), R(this, "flip", () => this.warning()), R(this, "customTransition", () => this.warning()), R(this, "magicMotion", () => this.warning()) } }, BD = new VD, $D = ge(BD), Ze = { Fade: { exit: { opacity: 0 }, enter: { opacity: 0 } }, PushLeft: { exit: { x: "-30%" }, enter: { x: "100%" } }, PushRight: { exit: { x: "30%" }, enter: { x: "-100%" } }, PushUp: { exit: { y: "-30%" }, enter: { y: "100%" } }, PushDown: { exit: { y: "30%" }, enter: { y: "-100%" } }, Instant: { animation: { type: !1 }, enter: { opacity: 0 } }, Modal: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { center: !0 }, enter: { opacity: 0, scale: 1.2 } }, OverlayLeft: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { right: 0, top: 0, bottom: 0 }, enter: { x: "100%" } }, OverlayRight: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { left: 0, top: 0, bottom: 0 }, enter: { x: "-100%" } }, OverlayUp: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { bottom: 0, left: 0, right: 0 }, enter: { y: "100%" } }, OverlayDown: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { top: 0, left: 0, right: 0 }, enter: { y: "-100%" } }, FlipLeft: { backfaceVisible: !1, exit: { rotateY: -180 }, enter: { rotateY: 180 } }, FlipRight: { backfaceVisible: !1, exit: { rotateY: 180 }, enter: { rotateY: -180 } }, FlipUp: { backfaceVisible: !1, exit: { rotateX: 180 }, enter: { rotateX: -180 } }, FlipDown: { backfaceVisible: !1, exit: { rotateX: -180 }, enter: { rotateX: 180 } }, MagicMotion: { withMagicMotion: !0 } }; function zD(e) { switch (e && e.appearsFrom ? e.appearsFrom : "right") { case "right": return Ze.PushLeft; case "left": return Ze.PushRight; case "bottom": return Ze.PushUp; case "top": return Ze.PushDown } } function ND(e) { switch (e && e.appearsFrom ? e.appearsFrom : "bottom") { case "right": return Ze.OverlayLeft; case "left": return Ze.OverlayRight; case "bottom": return Ze.OverlayUp; case "top": return Ze.OverlayDown } } function HD(e) { switch (e && e.appearsFrom ? e.appearsFrom : "bottom") { case "right": return Ze.FlipLeft; case "left": return Ze.FlipRight; case "bottom": return Ze.FlipUp; case "top": return Ze.FlipDown } } var jD = () => ({ current: -1, previous: -1, currentOverlay: -1, previousOverlay: -1, visualIndex: 0, overlayItemId: 0, historyItemId: 0, history: [], overlayStack: [], containers: {}, containerIndex: {}, containerVisualIndex: {}, containerIsRemoved: {}, transitionForContainer: {}, previousTransition: null }); function aS(e, t) { switch (t.type) { case "addOverlay": return UD(e, t.transition, t.component); case "removeOverlay": return XD(e); case "add": return Ww(e, t.key, t.transition, t.component); case "remove": return Uw(e); case "update": return WD(e, t.key, t.component); case "back": return YD(e); case "forward": return GD(e); default: return } } function WD(e, t, n) { return { ...e, containers: { ...e.containers, [t]: n } } } function UD(e, t, n) { let r = e.overlayStack[e.currentOverlay]; if (r && r.component === n) return; let i = e.overlayItemId + 1, o = [...e.overlayStack, { key: `stack-${i}`, component: n, transition: t }]; return { ...e, overlayStack: o, overlayItemId: i, currentOverlay: Math.max(0, Math.min(e.currentOverlay + 1, o.length - 1)), previousOverlay: e.currentOverlay } } function XD(e) { return { ...e, overlayStack: [], currentOverlay: -1, previousOverlay: e.currentOverlay } } function Ww(e, t, n, r) { e.containers[t] || (e.containers[t] = r), e.history = e.history.slice(0, e.current + 1), e.visualIndex = Math.max(e.history.length, 0); let i = e.history[e.history.length - 1], o = i && i.key === t; if (e.overlayStack = [], o && e.currentOverlay > -1) return { ...e, currentOverlay: -1, previousOverlay: e.currentOverlay }; if (o) return; let s = e.containerVisualIndex[t], a = e.containerIsRemoved[t], l = i?.key && n.withMagicMotion ? ZD(t, s, a, e.history) : !0; e.history.push({ key: t, transition: n, visualIndex: l ? Math.max(e.visualIndex, 0) : e.containerVisualIndex[t] }); let c = e.current + 1, u = e.current; for (let g in e.containerIndex) e.containerIndex[g] === c && (e.containerIndex[g] = QD(g, e.history)); e.containerIndex[t] = c; let { containerVisualIndex: f, containerIsRemoved: d } = KD(e, t, l), p = Xw(c, u, e.history, e.containerIndex, e.transitionForContainer); return { ...e, current: c, previous: u, containerVisualIndex: f, containerIsRemoved: d, transitionForContainer: p, previousTransition: null, currentOverlay: -1, historyItemId: e.historyItemId + 1, previousOverlay: e.currentOverlay } } function YD(e) { let t = { ...e.containers }, n = Uw(e); if (n) return n.containers = t, n } function GD(e) { let t = e.history[e.current + 1]; if (!t) return; let { key: n, transition: r, component: i } = t, o = [...e.history], s = Ww(e, n, r, i); if (s) return s.history = o, s } function Uw(e) { let t = [...e.history.slice(0, e.current + 1)]; if (t.length === 1) return; let n = t.pop(); if (!n) return; let r = t[t.length - 1]; de(r, "The navigation history must have at least one component"), e.containerIndex[r.key] = t.length - 1, t.every(d => d.key !== n.key) && delete e.containers[n.key]; let o = e.current - 1, s = e.current, { containerIsRemoved: a, containerVisualIndex: l, previousTransition: c, visualIndex: u } = qD(e, r, n), f = Xw(o, s, e.history, e.containerIndex, e.transitionForContainer); return { ...e, current: o, previous: s, containerIsRemoved: a, containerVisualIndex: l, previousTransition: c, visualIndex: u, transitionForContainer: f } } function KD(e, t, n) { let r = { containerVisualIndex: { ...e.containerVisualIndex }, containerIsRemoved: { ...e.containerIsRemoved } }; if (n) r.containerVisualIndex[t] = e.history.length - 1, r.containerIsRemoved[t] = !1; else { let i = e.containerVisualIndex[t]; for (let [o, s] of Object.entries(e.containerVisualIndex)) i !== void 0 && s > i && (r.containerIsRemoved[o] = !0) } return r } function qD(e, t, n) { let r = [t.key, n.key], i = e.history[e.history.length - 2], o = e.previousTransition === null ? null : { ...e.previousTransition }, s = { containerIsRemoved: { ...e.containerIsRemoved }, containerVisualIndex: { ...e.containerVisualIndex }, previousTransition: o, visualIndex: e.visualIndex }; i && r.push(i.key); let a = e.containerVisualIndex[t.key], l = e.containerVisualIndex[n.key], c = a !== void 0 && l !== void 0 && a <= l || t.visualIndex !== void 0 && t.visualIndex < e.history.length - 1, u = t.visualIndex; return c ? (s.containerIsRemoved[n.key] = !0, s.containerVisualIndex[t.key] = u !== void 0 ? u : e.history.length - 1) : (s.visualIndex = e.visualIndex + 1, s.containerVisualIndex[t.key] = e.visualIndex + 1), n.transition.withMagicMotion && (s.previousTransition = n.transition || null), e.containerIsRemoved[t.key] = !1, s } function QD(e, t) { var n; for (let r = t.length; r > t.length; r--)if (((n = t[r]) == null ? void 0 : n.key) === e) return r; return -1 } function Xw(e, t, n, r, i) { let o = { ...i }; for (let [s, a] of Object.entries(r)) { let l = JD(a, { current: e, previous: t, history: n }); l && (o[s] = l) } return o } function ZD(e, t, n, r) { return n || t === void 0 ? !0 : t === 0 ? !1 : r.slice(t, r.length).findIndex(s => s.key === e) > -1 ? !0 : !(r.slice(0, t - 1).findIndex(s => s.key === e) > -1) } function JD(e, t) { let { current: n, previous: r, history: i } = t; if (!(e !== n && e !== r)) { if (e === n && n > r) { let o = i[e]; return jc("enter", o?.transition.enter, o?.transition.animation) } if (e === r && n > r) { let o = i[e + 1]; return jc("exit", o?.transition.exit, o?.transition.animation) } if (e === n && n < r) { let o = i[e + 1]; return jc("enter", o?.transition.exit, o?.transition.animation) } if (e === r && n < r) { let o = i[e]; return jc("exit", o?.transition.enter, o?.transition.animation) } } } var eA = Ii(Ri); function jc(e, t, n) { let r = {}, i = {}; return eA.forEach(o => { r[o] = Ri[o], i[o] = { ...n, from: Ri[o] } }), t && Object.keys(t).forEach(o => { if (t[o] === void 0) return; let s = t[o], a = typeof t[o] == "string" ? `${Be(Ri)[o]}%` : Be(Ri)[o]; Be(r)[o] = e === "enter" ? a : s, i[o] = { ...n, from: e === "enter" ? s : a, velocity: 0 } }), { ...r, transition: { ...i } } } var tA = b.createContext(void 0); var Yw = b.createContext(void 0), nA = (() => { var e, t, n, r, i, o, s, a, l; return t = class extends ve { constructor(c) { var u; super(c), Wi(this, n), Wi(this, i), Wi(this, a), Wi(this, e, null), R(this, "state", jD()), Wi(this, s, S => { if (!this.props.enabled && this.state.history.length > 0) return; let m = aS(this.state, S); if (!m) return; let { skipLayoutAnimation: h } = this.props, y = m.history[m.current], x = S.type === "add" && S.transition.withMagicMotion || S.type === "forward" && y?.transition.withMagicMotion || S.type === "remove" && !!m.previousTransition, k = () => { var w; this.setState(m), y?.key && ((w = this.context) == null || w.call(this, y.key)) }; h && !x ? h(k) : k() }), R(this, "goBack", () => { var S; if (!It(this, i, o).call(this)) return vf(this, e, ((S = globalThis.event) == null ? void 0 : S.timeStamp) || null), this.state.currentOverlay !== -1 ? li(this, s).call(this, { type: "removeOverlay" }) : li(this, s).call(this, { type: "remove" }) }); let f = this.props.children; if (!f || !ca(f) || !la(f)) return; let d = { ...Ze.Instant }, g = { type: "add", key: ((u = f.key) == null ? void 0 : u.toString()) || `stack-${this.state.historyItemId + 1}`, transition: d, component: f }, v = aS(this.state, g); v && (this.state = v) } componentDidMount() { var c; let u = this.state.history[this.state.current]; u && ((c = this.context) == null || c.call(this, u.key)) } UNSAFE_componentWillReceiveProps(c) { var u; let f = c.children; if (!ca(f) || !la(f)) return; let d = (u = f.key) == null ? void 0 : u.toString(); d && (this.state.history.length === 0 ? It(this, a, l).call(this, f, Ze.Instant) : li(this, s).call(this, { type: "update", key: d, component: f })) } componentWillUnmount() { var c, u; (u = (c = this.props).resetProjection) == null || u.call(c) } instant(c) { It(this, a, l).call(this, c, Ze.Instant, void 0) } fade(c, u) { It(this, a, l).call(this, c, Ze.Fade, u) } push(c, u) { It(this, a, l).call(this, c, zD(u), u) } modal(c, u) { It(this, a, l).call(this, c, Ze.Modal, u) } overlay(c, u) { It(this, a, l).call(this, c, ND(u), u) } flip(c, u) { It(this, a, l).call(this, c, HD(u), u) } magicMotion(c, u) { It(this, a, l).call(this, c, Ze.MagicMotion, u) } customTransition(c, u) { It(this, a, l).call(this, c, u) } render() { var c, u, f, d, p; let g = It(this, n, r).call(this, { overCurrentContext: !1 }), v = It(this, n, r).call(this, { overCurrentContext: !0 }), S = rA(v), m = v.current > -1, h = this.state.history.length === 1, y = []; for (let [k, w] of Object.entries(this.state.containers)) { let T = this.state.containerIndex[k]; de(T !== void 0, "Container's index must be registered"); let E = this.state.containerVisualIndex[k]; de(E !== void 0, "Container's visual index must be registered"); let I = this.state.containerIsRemoved[k], F = this.state.history[T], B = this.state.transitionForContainer[k], V = T === this.state.current, K = T === this.state.previous, Z = V ? !1 : I, j = ((c = F?.transition) == null ? void 0 : c.withMagicMotion) || V && !!this.state.previousTransition; y.push(C(Mp, { id: k, index: E, isInitial: h, isCurrent: V, isPrevious: K, isOverlayed: m, visible: V || K, position: (u = F?.transition) == null ? void 0 : u.position, instant: cS(T, g), transitionProps: B, animation: lS(T, g), backfaceVisible: uA(T, g), exitAnimation: (f = F?.transition) == null ? void 0 : f.animation, exitBackfaceVisible: (d = F?.transition) == null ? void 0 : d.backfaceVisible, exitProps: (p = F?.transition) == null ? void 0 : p.enter, withMagicMotion: j, areMagicMotionLayersPresent: Z ? !1 : void 0, children: C(hD, { children: uS({ component: w, transition: F?.transition }) }) }, k)) } let x = this.state.overlayStack.map((k, w) => C(Mp, { isLayeredContainer: !0, isCurrent: w === this.state.currentOverlay, position: k.transition.position, initialProps: cA(w, v), transitionProps: fA(w, v), instant: cS(w, v, !0), animation: lS(w, v), exitProps: k.transition.enter, visible: dA(w, v), backdropColor: aA(k.transition), backfaceVisible: lA(w, v), onTapBackdrop: hA(k.transition, this.goBack), index: this.state.current + 1 + w, children: uS({ component: k.component, transition: k.transition }) }, k.key)); return C(Qc, { "data-framer-component-type": "NavigationRoot", top: 0, left: 0, width: "100%", height: "100%", position: "relative", style: { overflow: "hidden", backgroundColor: "unset", pointerEvents: void 0, ...this.props.style }, children: C($D.Provider, { value: this, children: ae(Yw.Provider, { value: h, children: [C(Mp, { isLayeredContainer: !0, position: void 0, initialProps: {}, instant: !1, transitionProps: iA(S), animation: oA(S), backfaceVisible: sA(S), visible: !0, backdropColor: void 0, onTapBackdrop: void 0, index: 0, children: C(RL, { children: C(fD, { children: C(od, { presenceAffectsLayout: !1, children: y }) }) }) }), C(od, { children: x })] }) }) }) } }, e = new WeakMap, n = new WeakSet, r = function (c) { let { current: u, previous: f, currentOverlay: d, previousOverlay: p } = this.state; return c.overCurrentContext ? { current: d, previous: p, history: this.state.overlayStack } : { current: u, previous: f, history: this.state.history } }, i = new WeakSet, o = function () { return globalThis.event ? li(this, e) === globalThis.event.timeStamp : !1 }, s = new WeakMap, a = new WeakSet, l = function (c, u, f) { var d, p; if (It(this, i, o).call(this) || (vf(this, e, ((d = globalThis.event) == null ? void 0 : d.timeStamp) || null), !c || !ca(c) || !la(c))) return; let g = { ...u, ...f }; if (!!g.overCurrentContext) return li(this, s).call(this, { type: "addOverlay", transition: g, component: c }); let S = ((p = c.key) == null ? void 0 : p.toString()) || `stack-${this.state.historyItemId + 1}`; li(this, s).call(this, { type: "add", key: S, transition: g, component: c }) }, R(t, "defaultProps", { enabled: !0 }), R(t, "contextType", tA), t })(), Gw = { stiffness: 500, damping: 50, restDelta: 1, type: "spring" }; function rA(e) { let t, n; return e.current !== -1 ? t = e.history[e.current] : n = e.history[e.previous], { currentOverlayItem: t, previousOverlayItem: n } } function iA({ currentOverlayItem: e }) { return e && e.transition.exit } function oA({ currentOverlayItem: e, previousOverlayItem: t }) { return e && e.transition.animation ? e.transition.animation : t && t.transition.animation ? t.transition.animation : Gw } function sA({ currentOverlayItem: e, previousOverlayItem: t }) { return e ? e.transition.backfaceVisible : t && t.transition.backfaceVisible } function aA(e) { if (e.backdropColor) return e.backdropColor; if (e.overCurrentContext) return "rgba(4,4,15,.4)" } function lA(e, t) { let { current: n, history: r } = t; if (e === n) { let i = r[e]; return i && i.transition ? i.transition.backfaceVisible : !0 } else if (e < n) { let i = r[e + 1]; return i && i.transition ? i.transition.backfaceVisible : !0 } else { let i = r[e]; return i && i.transition ? i.transition.backfaceVisible : !0 } } function cA(e, t) { let n = t.history[e]; if (n) return n.transition.enter } function uA(e, t) { var n, r, i, o; let { current: s, previous: a, history: l } = t; return e === a && s > a || e === s && s < a ? (r = (n = l[e + 1]) == null ? void 0 : n.transition) == null ? void 0 : r.backfaceVisible : (o = (i = l[e]) == null ? void 0 : i.transition) == null ? void 0 : o.backfaceVisible } function fA(e, t) { let { current: n, history: r } = t; if (e !== n) if (e < n) { let i = r[e + 1]; if (i && i.transition) return i.transition.exit } else { let i = r[e]; if (i && i.transition) return i.transition.enter } } function lS(e, t) { let { current: n, previous: r, history: i } = t, o = r > n ? r : n; if (e < o) { let s = i[e + 1]; if (s && s.transition.animation) return s.transition.animation } else if (e !== o) { let s = i[e]; if (s && s.transition.animation) return s.transition.animation } else { let s = i[e]; if (s?.transition.animation) return s.transition.animation } return Gw } function cS(e, t, n) { let { current: r, previous: i, history: o } = t; return !!(n && o.length > 1 || e !== i && e !== r || r === i) } function dA(e, t) { let { current: n, previous: r } = t; return e > n && e > r ? !1 : e === n } function uS(e) { return b.Children.map(e.component, n => { var r; if (!ca(n) || !la(n) || !n.props) return n; let i = { style: n.props.style ?? {} }, o = (r = e?.transition) == null ? void 0 : r.position, s = !o || o.left !== void 0 && o.right !== void 0, a = !o || o.top !== void 0 && o.bottom !== void 0, l = "style" in n.props ? ke(n.props.style) : !0; return s && ("width" in n.props && (i.width = "100%"), l && (i.style.width = "100%")), a && ("height" in n.props && (i.height = "100%"), l && (i.style.height = "100%")), b.cloneElement(n, i) }) } function hA(e, t) { if (e.goBackOnTapOutside !== !1) return t } function pA(e) { let t = i0(), n = cd(); return b.useInsertionEffect(() => { Pa() }, []), C(nA, { ...e, resetProjection: t, skipLayoutAnimation: n, children: e.children }) } var _6 = Dn(fu(), 1); var O6 = Dn(em(), 1); function pm(...e) { return e.filter(Boolean).join(" ") } var mA = (() => { function e(t = {}) { let n = Lp(t, !1, !1); return e.addData(n), n } return e._stores = [], e.addData = t => { e._stores.push(t) }, e.reset = () => { e._stores.forEach(t => Lp.resetObject(t)) }, e.addObserver = (t, n) => Lp.addObserver(t, n), e })(), Op = mA; var vA = { update: 0 }, gA = b.createContext({ update: NaN }); var yA = class extends ve { constructor() { super(...arguments), R(this, "observers", []), R(this, "state", vA), R(this, "taskAdded", !1), R(this, "frameTask", () => { this.setState({ update: this.state.update + 1 }), this.taskAdded = !1 }), R(this, "observer", () => { this.taskAdded || (this.taskAdded = !0, fw.addFrameTask(this.frameTask)) }) } componentWillUnmount() { this.observers.map(e => e()), Op.reset() } render() { let { children: e } = this.props; return this.observers.map(t => t()), this.observers = [], Op._stores.forEach(t => { let n = Op.addObserver(t, this.observer); this.observers.push(n) }), C(gA.Provider, { value: { ...this.state }, children: e }) } }, sN = Dn(fu(), 1); var Kw = "__framer__", bA = (() => Kw.length)(); function xA(e) { if (e.startsWith(Kw)) return e.substr(bA) } var Xn = ["opacity", "x", "y", "scale", "rotate", "rotateX", "rotateY", "skewX", "skewY", "transformPerspective"], ou = e => ({ x: Ee(e?.x ?? 0), y: Ee(e?.y ?? 0), opacity: Ee(e?.opacity ?? 1), scale: Ee(e?.scale ?? 1), rotate: Ee(e?.rotate ?? 0), rotateX: Ee(e?.rotateX ?? 0), rotateY: Ee(e?.rotateY ?? 0), skewX: Ee(e?.skewX ?? 0), skewY: Ee(e?.skewY ?? 0), transformPerspective: Ee(e?.transformPerspective ?? 0) }), je = { x: 0, y: 0, scale: 1, opacity: 1, rotate: 0, rotateX: 0, rotateY: 0, skewX: 0, skewY: 0, transformPerspective: 0 }; function qw(e) { return e in je } function Qw(e, t) { let n = Rt(() => ({ values: ou(t ? e : void 0) })); return b.useEffect(() => { if (!t) for (let r of Xn) { let i = je[r]; at(i) || n.values[r].set(i) } }, [n, t]), n } var SA = new Set(["loopEffectEnabled", "loopTransition", "loop", "loopRepeatType", "loopRepeatDelay"]), wA = () => { let e = D(); return H(() => () => { clearTimeout(e.current) }, []), async t => new Promise(n => { e.current = setTimeout(() => { n(!0) }, t * 1e3) }) }; function kA({ loopEffectEnabled: e, loopRepeatDelay: t, loopTransition: n, loopRepeatType: r, loop: i }) { let o = ui(), s = Rt(() => ({ values: ou() })), a = b.useRef(!1), l = wA(), c = async () => { if (!i) return; let d = n || void 0, p = a.current && r === "mirror", g = p ? je : i, v = p ? i : je; return a.current = !a.current, Promise.all(Xn.map(S => { if (!(o && S !== "opacity")) return s.values[S].set(v[S] ?? je[S]), new Promise(m => { let h = { ...d, onComplete: () => m() }; Qi(s.values[S], g[S] ?? v[S], h) }) })) }, u = async () => { e && (await c(), await l(t ?? 0), await u()) }, f = pe(() => { Xn.forEach(d => { s.values[d].stop() }), Xn.forEach(d => { s.values[d].set(je[d]) }), a.current = !1 }, [s]); return b.useEffect(() => (e && i ? u() : f(), () => f()), [e]), s } function CA(e, t, n, r, i) { let o = n / 100 - 1, s = i ? (t - r) * o : 0, a = -e * o; return s + a } var TA = new Set(["speed", "adjustPosition", "offset", "parallaxTransformEnabled"]); function EA(e, t, n) { let { speed: r = 100, offset: i = 0, adjustPosition: o = !1, parallaxTransformEnabled: s } = e, a = b.useRef(null), l = ui(), c = b.useCallback(g => a.current === null || r === 100 ? 0 : CA(g, a.current, r, i, o), [a, r, i, o]); b.useLayoutEffect(() => { Y.read(() => { var g, v; a.current = ((v = (g = t.current) == null ? void 0 : g.getBoundingClientRect()) == null ? void 0 : v.top) ?? 0 }), Y.update(() => { f.set(c(u.get())), o && d.set(n ?? "initial") }) }, [t, a, o]); let { scrollY: u } = Gy(), f = St(u, c), d = An(o && a.current === null ? "hidden" : n), p = An(0); return { values: { y: l || !s ? p : f }, style: s ? { visibility: d } : void 0 } } function RA(e) { if (!(Ce(e) || !ke(e))) return e?.transition } async function Dp(e, t, n, r, i, o) { let s = RA(e); return Promise.all(Xn.map(a => new Promise(l => { if (n && a !== "opacity") return l(); let c = t.values[a]; c.stop(); let u = ke(e) ? e?.[a] ?? je[a] : je[a]; if (Te(u) && (u = u.get()), !En(u)) return l(); let f = tr.get(r.current); f && f.setBaseTarget(a, u); let d = Ce(i) && !c?.hasAnimated && Ve.HandoffAppearAnimations ? { elapsed: Ve.HandoffAppearAnimations(i, a, c, Y) } : void 0; o ? c.set(u) : Qi(c, u, { ...s, velocity: 0, elapsed: 0, ...d, onComplete: () => l() }) }))) } var PA = new Set(["presenceInitial", "presenceAnimate", "presenceExit"]); function _A({ initial: e, animate: t, exit: n, presenceInitial: r, presenceAnimate: i, presenceExit: o }, s, a, l, c) { let u = r ?? e, f = i ?? t, d = o ?? n, p = D(!1), g = D(f), [v, S] = pl(), m = D(!1), h = Rt(() => { var x; let k = u ?? l; if (!ke(k)) return { values: ou() }; let w = {}; for (let T in k) { let E = ke(k) ? (x = Be(k)) == null ? void 0 : x[T] : void 0; En(E) && (w[T] = E) } return { values: ou(w) } }); Pn(() => { if (p.current && f) return; let x = tr.get(s.current); if (x) { p.current = !0; for (let k in h.values) { if (!qw(k)) continue; let w = l?.[k]; x.setBaseTarget(k, En(w) ? w : je[k]) } } }, [f]); let y = ui(); return Pn(() => { if (!a) { S?.(); return } if (v !== m.current) m.current = v, v ? u && f && Dp(f, h, y, s, c) : d ? Dp(d, h, y, s, c).then(() => S()) : S(); else { if (!!$e(f, g.current) || !f) return; g.current = f, Dp(f, h, y, s, c, !0) } }), h } function FA(e, t) { let n = 0, r = e; for (; r && r !== t && r instanceof HTMLElement;)n += r.offsetTop, r = r.offsetParent; return n } var IA = 1; function Zw(e, t = 0, n) { var r; let i = [], o = []; for (let s = e.length; s >= 0; s--) { let { ref: a, offset: l } = e[s] ?? {}; if (!a || !a.current) continue; let u = FA(a.current, document.documentElement) - IA - (l ?? 0) - t, f = ((r = a.current) == null ? void 0 : r.clientHeight) ?? 0, d = i[i.length - 1], p = Math.max(u + f, 0); i.push(u), o.unshift(Math.max(u, 0), d === void 0 ? p : Math.min(p, Math.max(d - 1, 0))), n?.(s) } return o } function LA(e, t = 0) { return e < t ? "up" : "down" } var MA = 4; function OA(e, t, n = {}) { let { direction: r, target: i } = e ?? {}, { repeat: o = !0, enabled: s = !0 } = n; b.useEffect(() => { if (!r || !s) return; let a, l = 0, c, u; return qi(({ y: f }) => { if (!o && u === i || f.current > f.scrollLength || f.current < 0) return; let d = LA(f.current, a); a = f.current; let p = d !== c; if (c = d, p) l = f.current; else { if (Math.abs(f.current - l) < MA) return; let v = d === r ? i : void 0; v !== u && t(v), u = v } }) }, [r, o, i, s, t]) } var DA = new Set(["threshold", "animateOnce", "opacity", "targetOpacity", "x", "y", "scale", "transition", "rotate", "rotateX", "rotateY", "perspective", "enter", "exit", "animate", "styleAppearEffectEnabled", "targets", "scrollDirection"]), AA = ["animate", "animate"], fS = { inputRange: [], outputRange: [] }; function VA(e, t, n) { let r = Zw(e, t), i = [...AA], o = r[0]; if (!En(o)) return fS; if (o > 1 && (r.unshift(0, o - 1), i.unshift("initial", "initial")), n) { let s = r.length - 1, a = r[s]; if (!En(a)) return fS; r.push(a + 1), i.push("exit") } return { inputRange: r, outputRange: i } } function Ap(e) { return { x: e?.x ?? je.x, y: e?.y ?? je.y, scale: e?.scale ?? je.scale, opacity: e?.opacity ?? je.opacity, transformPerspective: e?.transformPerspective ?? je.transformPerspective, rotate: e?.rotate ?? je.rotate, rotateX: e?.rotateX ?? je.rotateX, rotateY: e?.rotateY ?? je.rotateY, skewX: e?.skewX ?? je.skewX, skewY: e?.skewY ?? je.skewY, transition: e?.transition ?? void 0 } } function BA({ opacity: e, targetOpacity: t, perspective: n, enter: r, exit: i, animate: o, ...s }) { return b.useMemo(() => ({ initial: r ?? Ap({ ...s, opacity: e ?? t ?? 1, transformPerspective: n }), animate: o ?? Ap({ opacity: t }), exit: i ?? Ap() }), [o, s, r, i, e, t, n]) } function $A(e, t) { let n = ui(), r = BA(e), i = e.styleAppearEffectEnabled, o = Qw(i ? r.initial : r.animate, i), s = b.useRef({ isPlaying: !1, scheduledAppearState: void 0, lastAppearState: !e.styleAppearEffectEnabled }), a = b.useRef(), l = b.useCallback(async ({ transition: d, ...p }, g) => { let v = d ?? r.animate.transition ?? e.transition; await a.current, a.current = Promise.all(Xn.map(S => { g && o.values[S].set(r.initial[S] ?? je[S]); let m = p[S] ?? je[S], h = tr.get(t.current); return h && typeof m != "object" && h.setBaseTarget(S, m), new Promise(y => { if (n && S !== "opacity") y(); else { let x = { restDelta: S === "scale" ? .001 : void 0, ...v, onComplete: () => y() }; Qi(o.values[S], m, x) } }) })) }, []), c = e.animateOnce && s.current.lastAppearState === !0, u = !e.targets && e.styleAppearEffectEnabled && !e.scrollDirection && !c; bD(t, d => { let { isPlaying: p, lastAppearState: g } = s.current; if (p) { s.current.scheduledAppearState = d; return } s.current.scheduledAppearState = void 0, s.current.lastAppearState = d, g !== d && l(d ? r.animate : r.exit, d) }, { enabled: u, animateOnce: !!e.animateOnce, threshold: { y: e.threshold } }); let f = e.targets && i && !e.scrollDirection; return b.useEffect(() => { if (!f) return; let d = { initial: !0 }, p = "initial"; return qi(({ y: g }) => { let { targets: v } = e; if (!v || !v[0] || v[0].ref && !v[0].ref.current) return; let { inputRange: S, outputRange: m } = VA(v, (e.threshold ?? 0) * g.containerLength, !!e.exit); if (S.length === 0 || S.length !== m.length) return; let h = ds(g.current, S, m); if (e.animateOnce && d[h] || (d[h] = !0, p === h)) return; p = h; let y = Be(r)[h]; y && l(y) }) }, [f]), OA(e.scrollDirection, d => l(d ?? r.animate), { enabled: i, repeat: !e.animateOnce }), o } var zA = new Set(["transformViewportThreshold", "styleTransformEffectEnabled", "transformTargets", "spring", "transformTrigger"]), NA = (e, t) => { var n; let r = (n = e?.[0]) == null ? void 0 : n.target; return t ? { opacity: r?.opacity ?? 1 } : r }, Jw = () => ({ opacity: [], x: [], y: [], scale: [], rotate: [], rotateX: [], rotateY: [], skewX: [], skewY: [], transformPerspective: [] }); function HA(e, t) { let n = b.useRef({}); b.useEffect(() => { if (t !== void 0) for (let r of Ii(e)) { let i = e[r]; i.attach((o, s) => { let a = n.current[r]; if (a && a.stop(), n.current[r] = Bf({ keyframes: [i.get(), o], velocity: i.getVelocity(), ...t, restDelta: .001, onUpdate: s }), !Oe.isProcessing) { let l = performance.now() - Oe.timestamp; l < 40 && (n.current[r].time = l / 1e3) } return i.get() }) } }, [JSON.stringify(t)]) } function jA(e, t) { let n = Jw(); return { inputRange: Zw(e, t, i => { var o, s, a; let l = (o = e[i - 1]) == null ? void 0 : o.target, c = (s = e[i]) == null ? void 0 : s.target; for (let u of Xn) (a = n[u]) == null || a.unshift(l?.[u] ?? 0, c?.[u] ?? 0) }), effectKeyOutputRange: n } } function WA(e) { var t; let n = Jw(); for (let { target: r } of e) for (let i of Xn) (t = n[i]) == null || t.push(r[i]); return n } var dS = [0, 1]; function UA({ transformTrigger: e, styleTransformEffectEnabled: t, transformTargets: n, spring: r, transformViewportThreshold: i = 0 }, o) { let s = ui(), a = Qw(NA(n, s), t); return b.useLayoutEffect(() => { if (!(!t || !n)) if (e !== "onScrollTarget") { let l = WA(n); return qi(({ y: c }) => { for (let u of Xn) s && u !== "opacity" || dS.length === l[u].length && l[u][0] !== void 0 && a.values[u].set(ds(c.progress, dS, l[u])) }, e === "onInView" ? { target: o.current ?? void 0, offset: ["start end", "end end"] } : void 0) } else return qi(({ y: l }) => { if (!n[0] || n[0].ref && !n[0].ref.current) return; let { inputRange: c, effectKeyOutputRange: u } = jA(n, i * l.containerLength); if (c.length !== 0) for (let f of Xn) s && f !== "opacity" || c.length === u[f].length && u[f][0] !== void 0 && a.values[f].set(ds(l.current, c, u[f])) }) }, [s, e, o, i, t, a, n]), HA(a.values, r), a } var ek = { parallax: TA, styleAppear: DA, styleTransform: zA, loop: SA, presence: PA }, XA = Ii(ek); function hS(e, t, n) { return !(e in n) && t in n || n[e] === !0 } function YA(e) { let t = { parallax: {}, styleAppear: {}, styleTransform: {}, presence: { animate: e.animate, initial: e.initial, exit: e.exit }, loop: {}, forwardedProps: {} }; for (let n in e) { let r = xA(n); if (r) for (let i of XA) { let o = ek[i]; if (o?.has(r)) { t[i][r] = Be(e)[n]; break } } else t.forwardedProps[n] = Be(e)[n] } return t.parallax.parallaxTransformEnabled = hS("parallaxTransformEnabled", "speed", t.parallax), t.styleAppear.styleAppearEffectEnabled = hS("styleAppearEffectEnabled", "animateOnce", t.styleAppear), t } var Xr = e => e.reduce((t, n) => t += n, 0), pS = e => e.reduce((t, n) => t = t * n, 1), GA = "current"; function KA(e) { return ke(e) && GA in e } function qA(e, t) { if (!e || !ke(e)) return t; for (let n in e) { let r = e[n]; !Te(r) || !qw(n) || En(r.get()) && t[n].push(r) } } function oa(e) { return Ce(e) || Array.isArray(e) } var QA = e => b.forwardRef((t, n) => { if (t.__withFX) return C(e, { ...t, animate: void 0, initial: void 0, exit: void 0, ref: n }); if (oe.current() === oe.canvas) { let te = oa(t.animate) ? t.animate : void 0, re = oa(t.initial) ? t.initial : void 0; return C(e, { ...t, animate: te, initial: re, exit: void 0, ref: n }) } let r = b.useRef(null), i = n ?? r, { parallax: o = {}, styleAppear: s = {}, styleTransform: a = {}, presence: l = {}, loop: c = {}, forwardedProps: u } = YA(t), { __targetOpacity: f, __perspectiveFX: d, __smartComponentFX: p = !1 } = t, g = An(f ?? 1), { values: v } = _A(l, i, p, t.style, t[el]), { values: S, style: m } = EA(o, i), { values: h } = UA(a, i), { values: y } = $A(s, i), { values: x } = kA(c), k = b.useMemo(() => ({ scale: [y.scale, x.scale, v.scale, h.scale], opacity: [y.opacity, x.opacity, v.opacity, g, h.opacity], x: [y.x, x.x, v.x, h.x], y: [y.y, x.y, S.y, v.y, h.y], rotate: [y.rotate, x.rotate, v.rotate, h.rotate], rotateX: [y.rotateX, x.rotateX, v.rotateX, h.rotateX], rotateY: [y.rotateY, x.rotateY, v.rotateY, h.rotateY], skewX: [y.skewX, x.skewX, v.skewX, h.skewX], skewY: [y.skewY, x.skewY, v.skewY, h.skewY], transformPerspective: [h.transformPerspective, y.transformPerspective] }), [g, h, S, y, x, v]); qA(t.style, k); let w = St(k.scale, pS), T = St(k.opacity, pS), E = St(k.x, Xr), I = St(k.y, Xr), F = St(k.rotate, Xr), B = St(k.rotateX, Xr), V = St(k.rotateY, Xr), K = St(k.skewX, Xr), Z = St(k.skewY, Xr), j = St(k.transformPerspective, Xr), { drag: ne, dragConstraints: U } = u; _O(ne && KA(U) ? U : void 0); let X = { opacity: T, scale: w, x: E, y: I, rotate: F, rotateX: B, rotateY: V, skewX: K, skewY: Z }; at(d) && (X.transformPerspective = j); let z = oa(t.animate) ? t.animate : void 0, J = oa(t.initial) ? t.initial : void 0, ie = oa(t.exit) ? t.exit : void 0, se = p && !l.presenceInitial ? { initial: J, animate: z, exit: ie } : {}; return C(e, { ...u, ...se, __withFX: !0, style: { ...t.style, ...m, ...X }, values: v, ref: i }) }); var yN = QA, ZA = ge({}); function SN({ presets: e, children: t }) { let n = D(e); return $e(e, n.current, !1) || (n.current = e), C(ZA.Provider, { value: n.current, children: t }) } function Gp(e, t) { $o(e) ? e(t) : tk(e) && (e.current = t) } function tk(e) { return ke(e) && "current" in e } function mS(e, t) { return { get current() { return e.current }, set current(n) { e.current = n, t(n) } } } function JA(...e) { return t => e.forEach(n => Gp(n, t)) } function bu(e) { let t = Rt(() => eV(e)); return t.useSetup(e), t.cloneAsElement } function eV(e) { let t = { forwardedRef: e, childRef: null, ref: null }; t.ref = vS(t); let n = (s, a) => { if (!t.forwardedRef && t.forwardedRef === s) { t.ref = a; return } let l = !1; t.childRef !== a && (t.childRef = a, l = !0), t.forwardedRef !== s && (t.forwardedRef = s, l = !0), l && (t.ref = vS(t)) }, r = !1; function i(s, a) { if (r) throw new ReferenceError("useCloneChildrenWithPropsAndRef: You should not call cloneChildrenWithPropsAndRef more than once during the render cycle."); return r = !0, Rn.count(s) > 1 && e && (t.forwardedRef = void 0, t.ref = t.childRef), Rn.map(s, l => { if (en(l)) { let c = "ref" in l ? l.ref : void 0; n(t.forwardedRef, c); let u = t.ref !== c ? { ...a, ref: t.ref } : a; return mn(l, u) } return l }) } let o = function (a, l) { return C(Le, { children: i(a, l) }) }; return o.cloneAsArray = i, { useSetup: s => { r = !1, n(s, t.childRef) }, cloneAsElement: o } } function vS(e) { if (!e.forwardedRef) return e.childRef; let { forwardedRef: t, childRef: n } = e; return r => { Gp(n, r), Gp(t, r) } } var nk = b.createContext({}); function TN() { return b.useContext(nk) } var EN = b.forwardRef(({ width: e, children: t, ...n }, r) => { let i = b.useMemo(() => ({ width: e }), [e]), o = bu(r); return C(nk.Provider, { value: i, children: o(t, n) }) }), tV = e => b.forwardRef((t, n) => { let r = _a(t); return C(e, { layoutId: r, ...t, layoutIdKey: void 0, duplicatedFrom: void 0, ref: n }) }), nV = class extends ve { constructor() { super(...arguments), R(this, "state", { hasError: !1 }) } static getDerivedStateFromError() { return console.error("Error in component (see previous error log). This component has been hidden."), { hasError: !0 } } render() { let { children: e } = this.props, { hasError: t } = this.state; return t ? null : e } }, rV = b.forwardRef(({ children: e, layoutId: t, ...n }, r) => { let i = Rt(() => t ? `${t}-container` : void 0); return C(Nt.div, { layoutId: i, ...n, ref: r, children: C(jo.Provider, { value: !0, children: C(_L, { enabled: !1, children: C(Wy, { id: t ?? "", inherit: "id", children: C(nV, { children: b.Children.map(e, o => b.isValidElement(o) ? b.cloneElement(o, { layoutId: t }) : o) }) }) }) }) }) }), LN = tV(rV), iV = b.createContext(void 0), oV = (() => { var e; if (!mr()) return new Set; let t = (e = document.querySelector("style[data-framer-css-ssr-minified]")) == null ? void 0 : e.getAttribute("data-framer-components"); return t ? new Set(t.split(" ")) : new Set })(), rk = "data-framer-css-ssr", sV = (e, t, n) => b.forwardRef((r, i) => {
    let { sheet: o, cache: s } = b.useContext(iV) ?? {}; if (!mr()) {
        let a = Array.isArray(t) ? t.join(`
`) : t; return ae(Le, { children: [C("style", { [rk]: !0, "data-framer-component": n, dangerouslySetInnerHTML: { __html: a } }), C(e, { ...r, ref: i })] })
    } return b.useInsertionEffect(() => {
        if (n && oV.has(n)) return; (Array.isArray(t) ? t : t.split(`
`)).forEach(l => l && gw(l, o, s))
    }, []), C(e, { ...r, ref: i })
}), mm = b.createContext({ onRegisterCursors: () => () => { }, registerCursors: () => { } }), su = "framer-cursor-none", Kp = "framer-pointer-events-none", aV = b.memo(function ({ children: t }) { let n = Rt(() => { let i = new Set, o = {}; return { onRegisterCursors: s => (s(o), i.add(s), () => i.delete(s)), registerCursors: s => { let a = {}; for (let l in s) { let c = o[l] ?? s[l]; c && (a[l] = c) } o = a; for (let l of i) l(o) } } }), r = ui(); return ae(mm.Provider, { value: n, children: [t, !r && C(hV, {})] }) }), lV = (() => sV(aV, [`.${su}, .${su} * { cursor: none !important; }`, `.${Kp}, .${Kp} * { pointer-events: none !important; }`]))(), cV = (() => ({ position: "fixed", top: 0, left: 0, zIndex: 12 + 1, pointerEvents: "none" }))(); function uV(e) { return !(!e || e.placement || e.alignment) } function Wc(e) { switch (e) { case "start": return "0%"; case "center": return "-50%"; case "end": return "-100%"; default: We(e) } } function fV(e, t = "center") { switch (e) { case "top": return `${Wc(t)}, -100%`; case "right": return `0%, ${Wc(t)}`; case "bottom": return `${Wc(t)}, 0%`; case "left": return `-100%, ${Wc(t)}`; default: return "-50%, -50%" } } var gS = "data-framer-portal-id"; function yS(e, t) { let n = document.elementFromPoint(e, t); for (; n;) { if (n === document.body) return; let r = n.getAttribute("data-framer-cursor"); if (r) return r; if (n.hasAttribute(gS)) { let i = n.getAttribute(gS); n = n.parentElement, i && (n = document.getElementById(i) ?? n) } else n = n.parentElement } } function dV(e) { for (let t in e) return !1; return !0 } var hV = b.memo(function () { let { onRegisterCursors: t } = O(mm), n = An(0), r = An(0), i = An(0), o = b.useRef(null), s = b.useRef({ cursors: {}, cursorHash: void 0 }), a = vu(), l = !dV(s.current.cursors); b.useEffect(() => { let w = 0, T = 0; function E() { n.set(w), r.set(T), Qi(i, 1, { type: "tween", duration: .2 }) } function I(V) { V.pointerType !== "touch" && (w = V.clientX, T = V.clientY, Y.update(E)) } let F = () => { if (!l) return; let V = yS(w, T); V !== s.current.cursorHash && (s.current.cursorHash = V, Y.update(() => a())) }; Y.read(F, !0); function B(V) { if (V.target === o.current || !o.current) return; let K = new PointerEvent(V.type, { bubbles: !0, cancelable: V.cancelable, pointerType: V.pointerType, pointerId: V.pointerId, composed: V.composed, isPrimary: V.isPrimary, buttons: V.buttons, button: V.button }); Y.update(() => { var Z; (Z = o.current) == null || Z.dispatchEvent(K) }) } return Ve.addEventListener("pointermove", I), document.addEventListener("pointerdown", B), document.addEventListener("pointerup", B), () => { Ve.removeEventListener("pointermove", I), document.removeEventListener("pointerdown", B), document.removeEventListener("pointerup", B), dt(F) } }, [i, n, r, l, a]), b.useEffect(() => { function w() { Qi(i, 0, { type: "tween", duration: .2 }) } return document.addEventListener("mouseleave", w), Ve.addEventListener("blur", w), () => { document.removeEventListener("mouseleave", w), Ve.removeEventListener("blur", w) } }, [i]), b.useLayoutEffect(() => { function w(E) { s.current.cursors = E, s.current.cursorHash = yS(n.get(), r.get()), a() } let T = t(w); return () => { T(), document.body.classList.toggle(su, !1) } }, [n, r, t, a]); let { cursors: c, cursorHash: u } = s.current, f = u ? c[u] : null, d = uV(f); b.useLayoutEffect(() => { document.body.classList.toggle(su, d) }, [d]); let p = f?.component, g = f?.transition ?? { duration: 0 }, v = sd(n, g), S = sd(r, g), m = St(() => { var w; return v.get() + (((w = f?.offset) == null ? void 0 : w.x) ?? 0) }), h = St(() => { var w; return S.get() + (((w = f?.offset) == null ? void 0 : w.y) ?? 0) }), y = f?.alignment, x = f?.placement, k = b.useCallback((w, T) => `translate(${fV(x, y)}) ${T}`, [y, x]); return !f || !p ? null : C(p, { transformTemplate: k, style: { ...cV, x: m, y: h, opacity: i }, globalTapTarget: !0, variant: f?.variant, ref: o, className: Kp }) }); function BN(e) { let { registerCursors: t } = O(mm), n = Rt(() => e); b.useLayoutEffect(() => { t(n) }, [n, t]) } var Io = { isClockwise: e => Io.signedArea(e) <= 0, signedArea: e => { let t = 0, n = e.length; for (let r = 0; r < n; r++) { let i = e[r], o = e[(r + 1) % n]; !i || !o || (t += i.x * -o.y - o.x * -i.y) } return 1 / 2 * t }, containsPoint: (e, t) => { var n, r, i, o; let s; for (let a = 0; a < e.length; a++) { if (yt.isEqual(e[a], t)) return !0; let l = ((n = e[a]) == null ? void 0 : n.x) ?? 0, c = ((r = e[a]) == null ? void 0 : r.y) ?? 0, u = (a + 1) % e.length; if (yt.isEqual(e[u], t)) return !0; let f = ((i = e[u]) == null ? void 0 : i.x) ?? 0, d = ((o = e[u]) == null ? void 0 : o.y) ?? 0, p = (t.x - l) * (d - c) - (t.y - c) * (f - l); if (p === 0) continue; let g = p > 0; if (s ?? (s = g), s !== g) return !1 } return !0 }, intersects: (e, t) => { if (e.length < 1 || t.length < 1) return !1; let n = $.boundingRectFromPoints(e), r = $.boundingRectFromPoints(t); if (!$.intersects(n, r)) return !1; let i = [], o = e.length; e.forEach((l, c) => { let u = e[(c + 1) % o]; u && i.push(st(l, u)) }); let s = [], a = t.length; t.forEach((l, c) => { let u = t[(c + 1) % a]; u && s.push(st(l, u)) }); for (let l of i) for (let c of s) if (st.intersection(l, c, !0)) return !0; return !!(Io.containsPoint(t, e[0]) || Io.containsPoint(e, t[0])) }, contains: (e, t) => { for (let n = 0; n < t.length; n++)if (!Io.containsPoint(e, t[n])) return !1; return !0 }, clipToRect: (e, t) => { let n = $.edges(t), r = new Set, i = e.length, o = [], s = []; for (let a = 0; a < i; a++) { let l = e[a], c = e[(a + 1) % i]; if ($.containsPoint(t, l)) { let f = Vp(l); if (r.add(f), s.push(l), $.containsPoint(t, c)) continue } let u = st(l, c); n.forEach(f => { let d = st.intersection(u, f, !0); if (!d) return; let p = Vp(d); r.has(p) || (r.add(p), o.push(d)) }) } return o.length === 0 ? s : ($.points(t).forEach(a => { Io.containsPoint(e, a) && (r.add(Vp(a)), o.push(a)) }), yt.sortClockwise([...s, ...o])) } }; function Vp(e) { return `${e?.x}-${e?.y}` } function bS(e) { switch (e) { case "top": return "bottom"; case "right": return "left"; case "bottom": return "top"; case "left": return "right"; default: We(e) } } function xS(e, t, n, r = 0) { let i = Math.max(e, r); if (e < i) return i; let o = t + r; return i + o > n ? n - o : i } function pV(e, t, n) { switch (e) { case "top": case "bottom": return t.y < 0 || t.y + t.height > n.height ? "y" : void 0; case "left": case "right": return t.x < 0 || t.x + t.width > n.width ? "x" : void 0; default: We(e) } } function mV(e, t, n, r) { switch (pV(t, e, r)) { case "x": return { placement: bS(t), x: n.x * -1, y: n.y }; case "y": return { placement: bS(t), x: n.x, y: n.y * -1 }; default: return { placement: t, x: n.x, y: n.y } } } function vV(e, t, n, r, i, o, s) { let a = $.rebaseRectOnto(t, e, n, r), l = { x: a.x + i.x, y: a.y + i.y, width: t.width, height: t.height }; if (!o) return [n, l]; let { x: c, y: u, placement: f } = mV(l, n, i, o), d = $.rebaseRectOnto(t, e, f, r); return [f, { x: xS(d.x + c, t.width, o.width, s), y: xS(d.y + u, t.height, o.height, s), width: t.width, height: t.height }] } function Yr(e, t, n) { return Io.containsPoint([t, ...n], e) ? t : e } var Uc = 5; function gV(e) { return { constrainX: t => Math.min(Math.max(t, e.x + Uc), e.x + e.width - Uc), constrainY: t => Math.min(Math.max(t, e.y + Uc), e.y + e.height - Uc) } } var Xc = 4; function yV({ x: e, y: t }, n, r, { constrainX: i, constrainY: o }) { let [s, a, l, c] = $.points(r); switch (n) { case "left": { let u = { x: i(e - Xc), y: t }; return [u, Yr(c, a, [u, l]), Yr(l, s, [u, c])] } case "right": { let u = { x: i(e + Xc), y: t }; return [u, Yr(a, c, [u, s]), Yr(s, l, [u, a])] } case "top": { let u = { x: e, y: o(t - Xc) }; return [u, Yr(a, s, [u, c]), Yr(c, l, [u, a])] } case "bottom": { let u = { x: e, y: o(t + Xc) }; return [u, Yr(s, a, [u, l]), Yr(l, c, [u, s])] } default: We(n) } } function bV(e, t) { switch (e) { case "left": return `${Math.min(t.y, 0)}px auto auto 0px`; case "right": return `${Math.min(t.y, 0)}px 0px auto auto`; case "top": return `0px auto auto ${Math.min(t.x, 0)}px`; case "bottom": return `auto auto 0px ${Math.min(t.x, 0)}px`; default: We(e) } } function xV(e, t, n, r, i) { let o = Math.min(i.x, r.x), s = Math.min(i.y, r.y), a = $.merge(r, i), l = yV({ x: e, y: t }, n, i, gV(r)).map(c => `${c.x - o}px ${c.y - s}px`).join(", "); return { height: `${a.height}px`, width: `${a.width}px`, clipPath: `polygon(${l})`, inset: bV(n, $.delta(r, i)) } } function Yc(e) { switch (e) { case "start": return 0; case "center": return .5; case "end": return 1; default: We(e) } } function SS(e = "bottom", t = "center") { switch (e) { case "top": return { originX: Yc(t), originY: 1 }; case "right": return { originX: 0, originY: Yc(t) }; case "bottom": return { originX: Yc(t), originY: 0 }; case "left": return { originX: 1, originY: Yc(t) }; default: We(e) } } function SV(e) { return ke(e) && "current" in e } function wV(e) { var t; let n = e.current, r = { position: "absolute", scrolls: !1 }; for (; n;) { if (n?.tagName === "BODY" || (((t = getComputedStyle(n)) == null ? void 0 : t.position) === "fixed" && (r.position = "fixed"), (n.scrollWidth > n.clientWidth || n.scrollHeight > n.clientHeight) && (r.scrolls = !0), r.scrolls && r.position === "fixed")) return r; n = n.parentElement } return r } function kV(e) { return [() => Y.read(e, !0), () => dt(e)] } function CV(e) { let t = 0, n = 0; return (r, i, o, s) => { var a; (a = e.current) != null && a.style && (t = s?.clientX ?? t, n = s?.clientY ?? n, Object.assign(e.current.style, xV(t, n, o, r, i))) } } function wS(e, t, n) { e.current && Object.assign(e.current.style, { position: t, visibility: "visible", left: (n?.x ?? 0) + (t === "fixed" ? 0 : Ve.scrollX) + "px", top: (n?.y ?? 0) + (t === "fixed" ? 0 : Ve.scrollY) + "px" }) } var ik = b.createContext(new Set); function TV(e, t, n, { safeArea: r, onDismiss: i }) { let o = Rt(() => new Set), s = b.useContext(ik), [a, l] = pl(); return b.useEffect(() => { if (a) { if (!t.current) return; t.current.style.pointerEvents = "", s.add(t.current) } else { if (!t.current) return; t.current.style.pointerEvents = "none", s.delete(t.current), l() } }, [a, t, s]), b.useEffect(() => { if (!r) { let d = p => { p.key === "Escape" && i() }; return Ve.addEventListener("keyup", d), () => Ve.removeEventListener("keyup", d) } let c; function u() { if (!(!c || o.size !== 0)) { for (let d of document.elementsFromPoint(c.x, c.y)) if (d === e.current || d === t.current || d === n.current) return; i() } } function f(d) { c = d, Y.read(u) } return Ve.addEventListener("mousemove", f), () => { Ve.removeEventListener("mousemove", f) } }, [i, r, e, n, t, l, s, o]), o } function EV({ placement: e, alignment: t, offset: n, collisionDetectionSize: r, collisionDetectionPadding: i }) { return (o, s) => vV(o, s, e, t, n, r, i) } function RV(e, t) { return Rt(() => { let { originX: n, originY: r } = SS(e, t), i = { x: Ee(n), y: Ee(r) }; return [i, o => { let s = SS(o, t); i.x.set(s.originX), i.y.set(s.originY) }] }) } function PV(e, { x: t, y: n }) { if (!e || !ca(e) || !la(e) || !ke(e.props.style) && !at(e.props.style)) return null; let r = { ...e.props.style, originX: t, originY: n }; return b.cloneElement(e, { style: r }) } function HN({ alignment: e, placement: t, safeArea: n, offsetX: r, offsetY: i, anchorRef: o, className: s, children: a, portalSelector: l, zIndex: c, collisionDetection: u = !1, collisionDetectionPadding: f, onDismiss: d, ...p }) { let g = b.useRef(null), v = b.useRef(null), S = b.useRef(null), [m, h] = RV(t, e); b.useLayoutEffect(() => { if (!SV(o) || !S.current || !t || !e) return; let { position: x, scrolls: k } = wV(o), w = S.current.getBoundingClientRect(), T = o.current.getBoundingClientRect(), I = EV({ placement: t, alignment: e, offset: { x: r ?? 0, y: i ?? 0 }, collisionDetectionSize: u ? { width: Ve.innerWidth, height: Ve.innerHeight } : void 0, collisionDetectionPadding: f }), [F, B] = I(T, w); Y.render(() => { g.current && (wS(g, x, B), h(F)) }); let V = CV(v), K = T, Z, j = () => { let [ie, se] = I(K, w); wS(g, x, se), h(ie), n && V(K, se, ie, Z), Z = void 0 }, ne = () => { K = o.current.getBoundingClientRect(), Y.render(j) }, [U, X] = kV(ne); if (k && U?.(), !n) return () => X?.(); let z = ie => { Z = ie, Y.read(ne) }, J = o.current; return J.addEventListener("mousemove", z), () => { X?.(), J.removeEventListener("mousemove", z) } }, [n, t, e, r, i, o, u, f, h]); let y = TV(o, g, v, { safeArea: n, onDismiss: d }); return wp.createPortal(ae("div", { ref: g, className: s, style: { visibility: "hidden", width: "auto", height: "auto", position: "absolute", zIndex: c }, ...p, children: [n ? C("div", { ref: v, style: { position: "absolute" }, "data-safearea": !0 }) : C("div", { style: { position: "fixed", inset: 0 }, "aria-hidden": !0, onMouseDown: d }), C(ik.Provider, { value: y, children: C("div", { ref: S, children: PV(a, m) }) })] }), document.querySelector(l) ?? document.body) } var _V = b.createContext(void 0), xu = class { constructor(e) { this.resolver = e, R(this, "status") } static is(e) { return e instanceof xu } preload() { if (this.status) { let t = this.status; return t.type !== "pending" ? void 0 : t.promise } let e = this.resolver().then(t => { this.status = { type: "fulfilled", value: t } }, t => { this.status = { type: "rejected", error: t } }); return this.status = { type: "pending", promise: e }, e } read() { let e = this.status; if (!e) throw new Error("Need to call preload() before read()"); switch (e.type) { case "pending": throw new Error("Need to wait for preload() to resolve"); case "fulfilled": return e.value; case "rejected": throw e.error; default: We(e) } } }; function vm(e, t) { return e instanceof HTMLAnchorElement ? e : e instanceof Element ? e === t ? null : vm(e.parentElement, t) : null } var kS = "element", FV = "collection", IV = "collectionItemId", LV = "pathVariables", ok = "framer/page-link,"; function sk(e) { return Ce(e) && e.startsWith(`data:${ok}`) } function gm(e) { if (sk(e)) try { let t = new URL(e), n = t.pathname.substring(ok.length), r = t.searchParams, i = r.has(kS) ? r.get(kS) : void 0, o, s = r.get(FV), a = r.get(IV), l = r.get(LV); if (s && a && l) { let c = Object.fromEntries(new URLSearchParams(l).entries()); o = { collection: s, collectionItemId: a, pathVariables: c } } return { target: n === "none" ? null : n, element: i === "none" ? void 0 : i, collectionItem: o } } catch { return } } function MV(e, t, n) { var r; let i = t.getAttribute("data-framer-page-link-target"), o, s; if (i) { o = t.getAttribute("data-framer-page-link-element") ?? void 0; let l = t.getAttribute("data-framer-page-link-path-variables"); l && (s = Object.fromEntries(new URLSearchParams(l).entries())) } else { let l = t.getAttribute("href"); if (!l) return !1; let c = gm(l); if (!c || !c.target) return !1; i = c.target, o = c.element ?? void 0, s = (r = c.collectionItem) == null ? void 0 : r.pathVariables } let a = o ? t.dataset.framerSmoothScroll !== void 0 : void 0; return e(i, o, Object.assign({}, n, s), a), !0 } var OV = 500, DV = .9, AV = 1.7, VV = 4, BV = 1 / 0, _o = new WeakMap, Gc = new Set, Fo = new Map; function $V() { var e; let t = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}, n = navigator.deviceMemory && navigator.deviceMemory > AV, r, i, o; function s() { r = t.effectiveType || "", i = t.saveData || r.includes("2g"), o = r === "3g" || n ? VV : BV } (e = t.addEventListener) == null || e.call(t, "change", s), s(); let a = new IntersectionObserver(u, { threshold: DV }), l = 0; async function c(f, d) { if (i) return; let p = Fo.get(f); if (!p?.size || Gc.has(f)) return; ++l, Gc.add(f); let g = aw(f).catch(() => { }); a.unobserve(d), _o.delete(d); for (let v of p) a.unobserve(v), _o.delete(v); p.clear(), Fo.delete(f), await g, --l } function u(f) { var d; for (let p of f) { let g = p.target, v = _o.get(g); if (!v || Gc.has(v)) { a.unobserve(g), _o.delete(g); continue } let S = Fo.get(v), m = ((d = Fo.get(v)) == null ? void 0 : d.size) ?? 0; if (p.isIntersecting) { if (l >= o) continue; S ? S.add(g) : Fo.set(v, new Set([g])), setTimeout(c.bind(void 0, v, g), OV) } else S && S.delete(g), m <= 1 && Fo.delete(v) } } return (f, d) => { if (!Gc.has(f)) return _o.set(d, f), a.observe(d), () => { _o.delete(d), a.unobserve(d) } } } var zV = !rm || typeof IntersectionObserver > "u" ? null : $V(), Bp = {}, Kc = new WeakMap; function ak(e, t, n) { var r, i; let o = (i = (r = Kc?.get(n ?? Bp)) == null ? void 0 : r.get(e.collectionId)) == null ? void 0 : i.get(e.collectionItemId); if (o) return o; let s = Kc.get(n ?? Bp) ?? new Map; Kc.set(n ?? Bp, s); let a = s.get(e.collectionId) ?? new Map; s.set(e.collectionId, a); let l = new xu(async () => { try { let c = t[e.collectionId]; if (!c) throw new Error(`Key not found in collection utils for collection id: "${e.collectionId}`); let u = await c(); if (!u) throw new Error("Collection does not contain utility functions"); return await u.getSlugByRecordId(e.collectionItemId, n ?? void 0) } catch (c) { console.warn(`Failed to resolve slug: ${c instanceof Error ? c.message : "Unknown error"}`); return } }); return a.set(e.collectionItemId, l), l } var NV = "webPageId"; function au(e) { return !!(e && typeof e == "object" && NV in e) } function HV(e) { if (!e) return; let t = {}; for (let n in e.pathVariables) { let r = e.pathVariables[n]; r && (t[n] = r) } return t } function lu(e) { if (!sk(e)) return e; let t = gm(e); if (!t) return; let { target: n, element: r, collectionItem: i } = t; if (n) return { webPageId: n, hash: r ?? void 0, pathVariables: HV(i) } } var lk = /:([a-z]\w*)/gi, jV = ge(void 0); function ck() { var e; let t = O(jV), n = (e = hu()) == null ? void 0 : e.pathVariables; return t || n } function uk(e, { webPageId: t, hash: n, pathVariables: r }, i) { if (t !== e.id || n) return !1; if (e.path && e.pathVariables) { let o = Object.assign({}, i, r); for (let [, s] of e.path.matchAll(lk)) if (!s || e.pathVariables[s] !== o[s]) return !1 } return !0 } function ym(e) { return e === void 0 ? !1 : !!(e.startsWith("#") || e.startsWith("/") || e.startsWith(".")) } function WV(e, t) { try { return !!new URL(e).protocol } catch { } return t } function bm(e, t) { return e !== void 0 ? e ? "_blank" : void 0 : t ? void 0 : "_blank" } function qp(e, t = void 0) { let n = ym(e), r = bm(t, n); return { href: WV(e, n) ? e : `https://${e}`, target: r, rel: n ? void 0 : "noopener" } } function fk(e, t, n, r, i) { return async o => { var s, a; if (o.metaKey) return; let l = vm(o.target); if (!l || l.getAttribute("target") === "_blank") return; o.preventDefault(); let c = (s = e.getRoute) == null ? void 0 : s.call(e, t); c && qS(c?.page) && await c.page.preload(), (a = e.navigate) == null || a.call(e, t, n, r, i) } } function UV(e, t, n, r) { let i = []; function o(a) { if (!a || !n) return; let l = {}; for (let c in a) { let u = a[c]; de(u, "unresolvedSlug should be defined"); let f = ak(u, n, r), d = f.preload(); if (d) i.push(d); else { let p = f.read(); p && (l[c] = p) } } return l } let s = { path: o(e), hash: o(t) }; if (i.length) throw Promise.allSettled(i); return s } function XV(e, t, n, r, i, o) { let s = ym(e); if (!n.routes || !n.getRoute || !r || !s) return qp(e, t); try { let [a, l] = e.split("#", 2); de(a !== void 0, "A href must have a defined pathname."); let [c] = a.split("?", 2); de(c !== void 0, "A href must have a defined pathname."); let { routeId: u, pathVariables: f } = sw(n.routes, c), d = n.getRoute(u); if (d) { let p = Object.assign({}, i, f), g = Ca(d, { currentRoutePath: r.path, currentPathVariables: r.pathVariables, hash: l || void 0, pathVariables: p, preserveQueryParams: n.preserveQueryParams }), v = bm(t, !0); return { href: g, target: v, onClick: fk(n, u, l || void 0, p, o) } } } catch { } return qp(e, t) } function YV(e, t, n) { var r; if (Ce(e)) { let o = ym(e); if (!t.routes || !t.getRoute || !n || !o) return; let [s] = e.split("#", 2); if (s === void 0) return; let [a] = s.split("?", 2); if (a === void 0) return; let { routeId: l } = sw(t.routes, a); return t.getRoute(l) } let { webPageId: i } = e; return (r = t.getRoute) == null ? void 0 : r.call(t, i) } var UN = Ne(({ children: e, href: t, openInNewTab: n, smoothScroll: r, ...i }, o) => { let s = Ta(), a = hu(), l = ck(), { activeLocale: c } = du(), u = D(null), f = he(() => { let g, v = m => { var h; if (m === null) { g?.(), g = void 0; return } let y = au(t) ? t : lu(t); if (!y) return; let x = YV(y, s, a); x && (g = (h = zV) == null ? void 0 : h(x, m)) }, S = en(e) && "ref" in e; return S && tk(e.ref) ? mS(e.ref, v) : S && $o(e.ref) ? JA(e.ref, v) : mS(u, v) }, [t, s, a, e]), d = bu(o), p = he(() => { var g; if (!t) return {}; let v = au(t) ? t : lu(t); if (!v) return {}; if (Ce(v)) return XV(v, n, s, a, l, r); let { webPageId: S, hash: m, pathVariables: h, hashVariables: y, unresolvedHashSlugs: x, unresolvedPathSlugs: k } = v, w = UV(k, x, s.collectionUtils, c), T = { ...l, ...h, ...w?.path }, E = { ...l, ...y, ...w?.hash }, I = bm(n, !0), F = (g = s.getRoute) == null ? void 0 : g.call(s, S), B = Ca(F, { currentRoutePath: a?.path, currentPathVariables: a?.pathVariables, hash: m, pathVariables: T, hashVariables: E, preserveQueryParams: s.preserveQueryParams }), V = B.split("#", 2)[1]; return { href: B, target: I, onClick: fk(s, S, V, T, r), "data-framer-page-link-current": a && uk(a, v, l) || void 0 } }, [t, s, c, l, n, a, r]); return d(e, { ...i, ...p, ref: f }) }); function XN(e, t, n) { return dk(e, t, n) } function dk(e, t, n, r) { let i = au(e) ? e : lu(e); if (!au(i)) return Ce(e) ? qp(e).href : void 0; if (!t.getRoute || !t.currentRouteId) return; let o = t.getRoute(t.currentRouteId), { webPageId: s, hash: a, pathVariables: l, hashVariables: c, unresolvedHashSlugs: u, unresolvedPathSlugs: f } = i, d = t.getRoute(s), p = f || u ? r?.(f, u) : void 0, g = Object.assign({}, t.currentPathVariables, n, l, p?.path), v = Object.assign({}, t.currentPathVariables, n, c, p?.hash); return Ca(d, { currentRoutePath: o?.path, currentPathVariables: t.currentPathVariables, hash: a, pathVariables: g, hashVariables: v, relative: !1, preserveQueryParams: t.preserveQueryParams }) } function YN(e, t) { if (!t.getRoute || !t.currentRouteId) return; let n = t.getRoute(t.currentRouteId), { webPageId: r } = e, i = t.getRoute(r); return Ca(i, { currentRoutePath: n?.path, currentPathVariables: t.currentPathVariables, relative: !1, preserveQueryParams: !1 }) } var GV = b.createContext(void 0); function ZN({ RootComponent: e, isWebsite: t, routeId: n, framerSiteId: r, pathVariables: i, routes: o, collectionUtils: s, notFoundPage: a, isReducedMotion: l = !1, includeDataObserver: c = !1, localeId: u, locales: f, preserveQueryParams: d, enableImproveInpDuringHydration: p, addHydrationMarkers: g = !1 }) { if (b.useEffect(() => { t || fw.start() }, []), t) return C(Ny, { reducedMotion: l ? "user" : "never", children: C(lV, { children: C(GV.Provider, { value: r, children: C(JI, { initialRoute: n, initialPathVariables: i, initialLocaleId: u, routes: o, collectionUtils: s, notFoundPage: a, locales: f, defaultPageStyle: { minHeight: "100vh", width: "auto" }, preserveQueryParams: d, enableImproveInpDuringHydration: p, addHydrationMarkers: g }) }) }) }); { let v = c ? yA : b.Fragment; return C(v, { children: C(jI, { routes: o, children: C(pA, { children: b.isValidElement(e) ? e : b.createElement(e, { key: n }) }) }) }) } } function KV(e, t, n) { let r = Rn.map(e, i => en(i) ? mn(i, t) : i); return n ? r : C(Le, { children: r }) } var hk = b.createContext(void 0), CS = "ssr-variant"; function TS(e, t, n, r, i, o, s, a) { let l = b.Children.toArray(t), c = l[0]; if (l.length !== 1 || !b.isValidElement(c)) return console.warn("PropertyOverrides: expected exactly one React element for a child", t), s(t, n); let u = [], f = []; for (let [S] of Object.entries(r)) { if (S === i) continue; let m = e[S]; if (!m || !QV(c.props, m)) { f.push(S); continue } let h = ES([S], o); h.length && u.push({ variants: h, propOverrides: m }) } if (u.length === 0) return s(c, n); let d = [i, ...f], p = ES(d, o); p.length && u.unshift({ variants: p }); let g = `.${CS} { display: contents }`, v = []; for (let { variants: S, propOverrides: m } of u) { if (a && !S.includes(a)) continue; let h = S.join("+"), y = C(hk.Provider, { value: new Set(S), children: s(c, m ? { ...n, ...m } : n) }, h), x = qV(S, o, r); x.length ? (de(u.length > 1, "Must branch out when there are hiddenClassNames"), y = C("div", { className: `${CS} ${x.join(" ")}`, children: y }, h)) : de(u.length === 1, "Cannot branch out when hiddenClassNames is empty"), v.push(y) } return de(!a || v.length === 1, "Must render exactly one branch when activeVariantId is given"), ae(Le, { children: [!o && !mr() && C("style", { [rk]: !0, children: g }), v] }) } function qV(e, t, n) { let r = []; for (let [i, o] of Object.entries(n)) { let s = t && !t.has(i); if (e.includes(i) || s) continue; let a = o.split("-")[2]; r.push(`hidden-${a}`) } return r } function ES(e, t) { return t ? e.filter(n => t.has(n)) : e } function QV(e, t) { for (let n of Object.keys(t)) if (!$e(e[n], t[n], !0)) return !0; return !1 } function ZV(e, t, n) { return !n || !e ? t : { ...t, ...n[e] } } var JV = () => () => { }, e3 = () => !0, t3 = () => !1, n8 = b.forwardRef(function ({ breakpoint: t, overrides: n, children: r, ...i }, o) { let s = bu(o), a = b.useContext(hk), l = b.useSyncExternalStore(JV, t3, e3), c = Rt(() => l ? mr() ? 1 : 2 : 0), u = b.useContext(_V); if (!u) return console.warn("PropertyOverrides is missing GeneratedComponentContext"), s(r, i); let { primaryVariantId: f, variantClassNames: d } = u; switch (c) { case 0: return s(r, ZV(t, i, n)); case 1: return TS(n, r, i, d, f, a, s, t); case 2: return TS(n, r, i, d, f, a, KV, void 0); default: We(c) } }), r8 = Ne(function ({ links: t, children: n, ...r }, i) { let o = Ta(), { activeLocale: s } = du(), a = bu(i), l = [], c = t.map(f => dk(f.href, o, f.implicitPathVariables, (d, p) => { function g(v) { let S = {}; for (let m in v) { let h = v[m]; de(o.collectionUtils, "collectionUtils should be defined"), de(h, "unresolvedSlug be defined"); let y = ak(h, o.collectionUtils, s), x = y.preload(); if (x) l.push(x); else { let k = y.read(); k && (S[m] = k) } } return S } return { path: g(d), hash: g(p) } })); if (l.length > 0) throw Promise.allSettled(l); let u = n(c); return a(u, r) }); var n3 = Dn(nI(), 1); function r3(e) { return { trace(...t) { var n; return (n = Je.getLogger(e)) == null ? void 0 : n.trace(...t) }, debug(...t) { var n; return (n = Je.getLogger(e)) == null ? void 0 : n.debug(...t) }, info(...t) { var n; return (n = Je.getLogger(e)) == null ? void 0 : n.info(...t) }, warn(...t) { var n; return (n = Je.getLogger(e)) == null ? void 0 : n.warn(...t) }, error(...t) { var n; return (n = Je.getLogger(e)) == null ? void 0 : n.error(...t) } } } function i3(e) { return sm(e) && e.every(ke) } function pk(e) { return ke(e) && $o(e.read) && $o(e.preload) } function o3(e) { return i3(e) || pk(e) } function s3(e) { return ke(e) && ke(e.schema) } function xm(e) { return ke(e) && ke(e.collectionByLocaleId) } async function RS(e, t) { return pk(e) ? (await e.preload(t), e.read(t)) : e } var a3 = class { constructor(e, t) { this.collection = e, this.locale = t, R(this, "schema"), R(this, "indexes", []); let n = ww(e); de(n, "Collection does not have properties"); let r = { id: { type: "string", isNullable: !1 } }, i = Object.entries(n); for (let [o, s] of i) s && (r[o] = { type: s.type, isNullable: !0 }); this.schema = r } getDatabaseItem(e, t) { let n = {}; for (let r in this.schema) { let i = e[r]; if (zo(i)) continue; let o = this.schema[r]; at(o) || (n[r] = { type: o.type, value: i }) } return { pointer: t, data: n } } async resolveRichText(e) { if (xu.is(e)) { let t = e.preload(); return t && await t, e.read() } return e } async scanItems() { return (await RS(this.collection, this.locale)).map((t, n) => { let r = String(n); return this.getDatabaseItem(t, r) }) } async resolveItems(e) { let t = await RS(this.collection, this.locale); return e.map(n => { let r = Number(n), i = t[r]; return de(i, "Can't find collection item"), this.getDatabaseItem(i, n) }) } compareItems(e, t) { return Number(e.pointer) - Number(t.pointer) } }, dn = { equal(e, t, n) { return e?.type !== t?.type ? !1 : sa(e, t, n) === 0 }, lessThan(e, t, n) { return e?.type !== t?.type ? !1 : sa(e, t, n) < 0 }, lessThanOrEqual(e, t, n) { return e?.type !== t?.type ? !1 : sa(e, t, n) <= 0 }, greaterThan(e, t, n) { return e?.type !== t?.type ? !1 : sa(e, t, n) > 0 }, greaterThanOrEqual(e, t, n) { return e?.type !== t?.type ? !1 : sa(e, t, n) >= 0 }, stringify(e) { if (e === null) return "null"; switch (e.type) { case "boolean": case "number": return String(e.value); case "string": return `'${e.value}'`; case "enum": return `'${e.value}' /* Enum */`; case "color": return `'${e.value}' /* Color */`; case "date": return `'${e.value}' /* Date */`; case "richtext": return "RichText"; case "responsiveimage": return "ResponsiveImage"; case "file": return "File"; case "link": return Ce(e.value) ? `'${e.value}' /* Link */` : "Link"; default: We(e) } } }; function sa(e, t, n) { if (Ae(e) || Ae(t)) return de(e === t), 0; switch (e.type) { case "boolean": return de(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "color": return de(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "date": { de(e.type === t.type); let r = new Date(e.value), i = new Date(t.value); return r < i ? -1 : r > i ? 1 : 0 } case "enum": return de(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "file": return de(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "responsiveimage": { de(e.type === t.type); let r = JSON.stringify(e.value), i = JSON.stringify(t.value); return r < i ? -1 : r > i ? 1 : 0 } case "link": { de(e.type === t.type); let r = JSON.stringify(e.value), i = JSON.stringify(t.value); return r < i ? -1 : r > i ? 1 : 0 } case "number": return de(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "richtext": { de(e.type === t.type); let r = e.value, i = t.value; return r < i ? -1 : r > i ? 1 : 0 } case "string": { de(e.type === t.type); let r = e.value, i = t.value; return n.type === 0 && (r = e.value.toLowerCase(), i = t.value.toLowerCase()), r < i ? -1 : r > i ? 1 : 0 } default: We(e) } } var Qp = "index", Tt = class { static from(e, t) { return Wn(e, t, void 0) } }, lt = class extends Tt { constructor(e, t) { super(), this.schema = e, this.name = t, R(this, "definition"), t === Qp ? this.definition = { type: "number", isNullable: !1 } : this.definition = e[t] ?? null } stringify() { return this.name } equals(e) { return e instanceof lt && $e(this.definition, e.definition) && $e(e.name, this.name) } evaluate(e) { let t = this.name; if (at(e) || t === Qp) throw new Error(`Can't evaluate identifier: ${t}`); return e.data[t] ?? null } canEvaluate() { return !1 } }, Ie = class extends Tt { constructor(e, t) { super(), this.definition = e, this.value = t } stringify() { return dn.stringify(this.value) } static fromNull() { return new Ie(null, null) } static fromBoolean(e) { return new Ie({ type: "boolean", isNullable: Ae(e) }, Ae(e) ? null : { type: "boolean", value: e }) } static fromDate(e) { return new Ie({ type: "date", isNullable: Ae(e) }, Ae(e) ? null : { type: "date", value: e.toISOString() }) } static fromEnum(e) { return new Ie({ type: "enum", isNullable: Ae(e) }, Ae(e) ? null : { type: "enum", value: e }) } static fromNumber(e) { return new Ie({ type: "number", isNullable: Ae(e) }, Ae(e) ? null : { type: "number", value: e }) } static fromString(e) { return new Ie({ type: "string", isNullable: Ae(e) }, Ae(e) ? null : { type: "string", value: e }) } equals(e) { return e instanceof Ie && $e(this.definition, e.definition) && $e(e.value, this.value) } evaluate() { return this.value } canEvaluate() { return !0 } }, Ia = class extends Tt { constructor(e) { super(), this.argumentExpressions = e, R(this, "collation", { type: 0 }) } getArgumentExpression(e) { let t = this.argumentExpressions[e]; if (at(t)) throw new Error("Missing argument in function call"); return t } equals(e) { return e instanceof Ia && $e(this.constructor, e.constructor) && $e(this.argumentExpressions, e.argumentExpressions) } canEvaluate() { return this.argumentExpressions.every(e => e.canEvaluate()) } }, Su = class extends Ia { constructor() { super(...arguments), R(this, "definition", Su.getDefinition()), R(this, "sourceExpression", this.getArgumentExpression(0)), R(this, "targetExpression", this.getArgumentExpression(1)) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `CONTAINS(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})` } getValue(e, t) { if (Ae(e) || e.type !== "string" || Ae(t) || t.type !== "string") return !1; let n = e.value, r = t.value; return this.collation.type === 0 && (n = n.toLowerCase(), r = r.toLowerCase()), n.includes(r) } evaluate(e) { let t = this.sourceExpression.evaluate(e), n = this.targetExpression.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, wu = class extends Ia { constructor() { super(...arguments), R(this, "definition", wu.getDefinition()), R(this, "sourceExpression", this.getArgumentExpression(0)), R(this, "targetExpression", this.getArgumentExpression(1)) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `STARTS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})` } getValue(e, t) { if (Ae(e) || e.type !== "string" || Ae(t) || t.type !== "string") return !1; let n = e.value, r = t.value; return this.collation.type === 0 && (n = n.toLowerCase(), r = r.toLowerCase()), n.startsWith(r) } evaluate(e) { let t = this.sourceExpression.evaluate(e), n = this.targetExpression.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, ku = class extends Ia { constructor() { super(...arguments), R(this, "definition", ku.getDefinition()), R(this, "sourceExpression", this.getArgumentExpression(0)), R(this, "targetExpression", this.getArgumentExpression(1)) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `ENDS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})` } getValue(e, t) { if (Ae(e) || e.type !== "string" || Ae(t) || t.type !== "string") return !1; let n = e.value, r = t.value; return this.collation.type === 0 && (n = n.toLowerCase(), r = r.toLowerCase()), n.endsWith(r) } evaluate(e) { let t = this.sourceExpression.evaluate(e), n = this.targetExpression.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, cu = class extends Tt { constructor(e, t, n) { super(), this.valueExpression = e, this.conditions = t, this.elseExpression = n, R(this, "definition"), R(this, "collation", { type: 0 }); let r = []; for (let { thenExpression: i } of t) r.push(i.definition); n && r.push(n.definition), this.definition = cu.getDefinition(r) } static getDefinition(e) { let t = null, n = !1; for (let r of e) { if (t ?? (t = r), t && r && t.type !== r.type) throw new Error("Incompatible types in CASE expression"); n || (n = r?.isNullable ?? !0) } return t ? { type: t.type, isNullable: n } : null } stringify() { let e = "CASE"; this.valueExpression && (e += ` ${this.valueExpression.stringify()}`); for (let { whenExpression: t, thenExpression: n } of this.conditions) e += ` WHEN ${t.stringify()} THEN ${n.stringify()}`; return this.elseExpression && (e += ` ELSE ${this.elseExpression.stringify()}`), e += " END", e } equals(e) { return e instanceof cu && $e(this.valueExpression, e.valueExpression) && $e(this.conditions, e.conditions) && $e(this.elseExpression, e.elseExpression) } evaluate(e) { var t, n; let r = ((t = this.valueExpression) == null ? void 0 : t.evaluate(e)) ?? null; for (let { whenExpression: i, thenExpression: o } of this.conditions) { let s = i.evaluate(e); if (this.valueExpression ? dn.equal(s, r, this.collation) : Li(s)) return o.evaluate(e) } return ((n = this.elseExpression) == null ? void 0 : n.evaluate(e)) ?? null } canEvaluate() { let e = []; this.valueExpression && e.push(this.valueExpression); for (let t of this.conditions) e.push(t.whenExpression), e.push(t.thenExpression); return this.elseExpression && e.push(this.elseExpression), e.every(t => t.canEvaluate()) } }, l3 = class { constructor(e, t) { this.whenExpression = e, this.thenExpression = t } }, mk = class extends Tt { constructor(e) { super(), this.valueExpression = e } equals(e) { return e instanceof mk && $e(this.constructor, e.constructor) && $e(this.valueExpression, e.valueExpression) } canEvaluate() { return this.valueExpression.canEvaluate() } }, ga = class extends mk { constructor() { super(...arguments), R(this, "definition", ga.getDefinition()) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `NOT ${this.valueExpression.stringify()}` } evaluate(e) { let t = this.valueExpression.evaluate(e); return { type: "boolean", value: !Li(t) } } }, ya = class extends Tt { constructor(e) { super(), this.operandExpressions = e, R(this, "definition", ya.getDefinition()) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return this.operandExpressions.map(e => e.stringify()).join(" AND ") } equals(e) { return e instanceof ya && $e(this.constructor, e.constructor) && $e(this.operandExpressions, e.operandExpressions) } canEvaluate() { return this.operandExpressions.every(e => e.canEvaluate()) } }, Pi = class extends ya { constructor() { super(...arguments), R(this, "operator", "AND") } evaluate(e) { return { type: "boolean", value: this.operandExpressions.every(n => { let r = n.evaluate(e); return Li(r) }) } } }, ua = class extends ya { constructor() { super(...arguments), R(this, "operator", "OR") } evaluate(e) { return { type: "boolean", value: this.operandExpressions.some(n => { let r = n.evaluate(e); return Li(r) }) } } }, Yn = class extends Tt { constructor(e, t) { super(), this.leftExpression = e, this.rightExpression = t, R(this, "definition", Yn.getDefinition()), R(this, "collation", { type: 0 }) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `${this.leftExpression.stringify()} ${this.operator} ${this.rightExpression.stringify()}` } equals(e) { return e instanceof Yn && $e(this.constructor, e.constructor) && $e(this.leftExpression, e.leftExpression) && $e(this.rightExpression, e.rightExpression) } canEvaluate() { return this.leftExpression.canEvaluate() && this.rightExpression.canEvaluate() } }, No = class extends Yn { constructor() { super(...arguments), R(this, "operator", "=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: dn.equal(t, n, this.collation) } } }, Ho = class extends Yn { constructor() { super(...arguments), R(this, "operator", "!=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: !dn.equal(t, n, this.collation) } } }, ba = class extends Yn { constructor() { super(...arguments), R(this, "operator", "<") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: dn.lessThan(t, n, this.collation) } } }, xa = class extends Yn { constructor() { super(...arguments), R(this, "operator", "<=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: dn.lessThanOrEqual(t, n, this.collation) } } }, Sa = class extends Yn { constructor() { super(...arguments), R(this, "operator", ">") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: dn.greaterThan(t, n, this.collation) } } }, wa = class extends Yn { constructor() { super(...arguments), R(this, "operator", ">=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: dn.greaterThanOrEqual(t, n, this.collation) } } }, La = class extends Tt { constructor(e) { super(), this.valueExpression = e } stringify() { return `CAST(${this.valueExpression.stringify()} AS ${this.dataType})` } equals(e) { return e instanceof La && $e(this.constructor, e.constructor) && $e(this.valueExpression, e.valueExpression) } canEvaluate() { return this.valueExpression.canEvaluate() } }, Cu = class extends La { constructor() { super(...arguments), R(this, "dataType", "BOOLEAN"), R(this, "definition", Cu.getDefinition()) } static getDefinition() { return { type: "boolean", isNullable: !1 } } evaluate(e) { let t = this.valueExpression.evaluate(e); return { type: "boolean", value: Li(t) } } }; function Li(e) { switch (e?.type) { case "boolean": case "number": case "string": return !!e.value }return !1 } var Sm = class extends La { constructor() { super(...arguments), R(this, "dataType", "DATE"), R(this, "definition", Sm.getDefinition()) } static getDefinition() { return { type: "date", isNullable: !0 } } evaluate(e) { let t = this.valueExpression.evaluate(e), n = vk(t); return Ae(n) ? null : { type: "date", value: n.toISOString() } } }; function vk(e) { switch (e?.type) { case "date": case "number": case "string": { let t = new Date(e.value); return xw(t) ? t : null } }return null } var wm = class extends La { constructor() { super(...arguments), R(this, "dataType", "NUMBER"), R(this, "definition", wm.getDefinition()) } static getDefinition() { return { type: "number", isNullable: !0 } } evaluate(e) { let t = this.valueExpression.evaluate(e), n = gk(t); return Ae(n) ? null : { type: "number", value: n } } }; function gk(e) { switch (e?.type) { case "number": case "string": { let t = Number(e.value); return Number.isFinite(t) ? t : null } }return null } var km = class extends La { constructor() { super(...arguments), R(this, "dataType", "STRING"), R(this, "definition", km.getDefinition()) } static getDefinition() { return { type: "string", isNullable: !0 } } evaluate(e) { let t = this.valueExpression.evaluate(e), n = yk(t); return Ae(n) ? null : { type: "string", value: n } } }; function yk(e) { switch (e?.type) { case "string": case "number": return String(e.value) }return null } function Wn(e, t, n) { let r = c3(e, t, n), i = r instanceof Ie; if (r.canEvaluate() && !i) { let o = r.evaluate(); return new Ie(r.definition, o) } return r } function c3(e, t, n) { switch (e.type) { case "Identifier": return u3(e, t); case "LiteralValue": return f3(e, n); case "FunctionCall": return h3(e, t); case "Case": return p3(e, t, n); case "UnaryOperation": return m3(e, t); case "BinaryOperation": return v3(e, t); case "TypeCast": return T3(e, t); default: throw new Error(`Unsupported expression: ${JSON.stringify(e)}`) } } function u3(e, t) { return new lt(t, e.name) } function f3(e, t) { var n; let r = d3(e.value); switch (t?.type) { case "boolean": { let i = Li(r.value); return Ie.fromBoolean(i) } case "date": { let i = vk(r.value); return Ie.fromDate(i) } case "enum": return ((n = r.value) == null ? void 0 : n.type) === "string" ? Ie.fromEnum(r.value.value) : r; case "number": { let i = gk(r.value); return Ie.fromNumber(i) } case "string": { let i = yk(r.value); return Ie.fromString(i) } }return r } function d3(e) { return bw(e) ? Ie.fromBoolean(e) : xw(e) ? Ie.fromDate(e) : En(e) ? Ie.fromNumber(e) : Ce(e) ? Ie.fromString(e) : Ie.fromNull() } function h3(e, t) { let n = e.arguments.map(r => Wn(r, t, void 0)); switch (e.functionName) { case "CONTAINS": return new Su(n); case "STARTS_WITH": return new wu(n); case "ENDS_WITH": return new ku(n); default: throw new Error(`Unsupported function name: ${e.functionName}`) } } function p3(e, t, n) { let r = e.value && Wn(e.value, t, void 0), i = e.value && ka(e.value, t), o = e.conditions.map(a => { let l = Wn(a.when, t, i), c = Wn(a.then, t, n); return new l3(l, c) }), s = e.else && Wn(e.else, t, n); return new cu(r, o, s) } function m3(e, t) { let n = Wn(e.value, t, void 0); switch (e.operator) { case "not": return Zp(n); default: throw new Error(`Unsupported unary operator: ${e.operator}`) } } function Zp(e) { var t; if (e instanceof ga) { let n = e.valueExpression; return ((t = n.definition) == null ? void 0 : t.type) === "boolean" ? n : new Cu(n) } if (e instanceof No) { let { leftExpression: n, rightExpression: r } = e; return new Ho(n, r) } if (e instanceof Ho) { let { leftExpression: n, rightExpression: r } = e; return new No(n, r) } if (e instanceof ba) { let { leftExpression: n, rightExpression: r } = e; return new wa(n, r) } if (e instanceof xa) { let { leftExpression: n, rightExpression: r } = e; return new Sa(n, r) } if (e instanceof Sa) { let { leftExpression: n, rightExpression: r } = e; return new xa(n, r) } if (e instanceof wa) { let { leftExpression: n, rightExpression: r } = e; return new ba(n, r) } if (e instanceof Pi) { let { operandExpressions: n } = e, r = n.map(Zp); return new ua(r) } if (e instanceof Pi) { let { operandExpressions: n } = e, r = n.map(Zp); return new Pi(r) } return new ga(e) } function v3(e, t) { let n = e.operator !== "and" && e.operator !== "or" ? ka(e.left, t) || ka(e.right, t) : void 0, r = Wn(e.left, t, n), i = Wn(e.right, t, n); switch (e.operator) { case "and": return g3(r, i); case "or": return y3(r, i); case "==": return b3(r, i); case "!=": return x3(r, i); case "<": return S3(r, i); case "<=": return w3(r, i); case ">": return k3(r, i); case ">=": return C3(r, i); default: throw new Error(`Unsupported binary operator: ${e.operator}`) } } function g3(e, t) { let n = []; return e instanceof Pi ? n.push(...e.operandExpressions) : n.push(e), t instanceof Pi ? n.push(...t.operandExpressions) : n.push(t), new Pi(n) } function y3(e, t) { let n = []; return e instanceof ua ? n.push(...e.operandExpressions) : n.push(e), t instanceof ua ? n.push(...t.operandExpressions) : n.push(t), new ua(n) } function b3(e, t) { let n = e instanceof lt; return t instanceof lt && !n ? new No(t, e) : new No(e, t) } function x3(e, t) { let n = e instanceof lt; return t instanceof lt && !n ? new Ho(t, e) : new Ho(e, t) } function S3(e, t) { let n = e instanceof lt; return t instanceof lt && !n ? new Sa(t, e) : new ba(e, t) } function w3(e, t) { let n = e instanceof lt; return t instanceof lt && !n ? new wa(t, e) : new xa(e, t) } function k3(e, t) { let n = e instanceof lt; return t instanceof lt && !n ? new ba(t, e) : new Sa(e, t) } function C3(e, t) { let n = e instanceof lt; return t instanceof lt && !n ? new xa(t, e) : new wa(e, t) } function T3(e, t) { let n = Wn(e.value, t, void 0); switch (e.dataType) { case "BOOLEAN": return E3(n); case "DATE": return R3(n); case "NUMBER": return P3(n); case "STRING": return _3(n); default: throw new Error(`Unsupported data type: ${e.dataType}`) } } function E3(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "boolean" ? e : new Cu(e) } function R3(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "date" ? e : new Sm(e) } function P3(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "number" ? e : new wm(e) } function _3(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "string" ? e : new km(e) } function ka(e, t) { switch (e.type) { case "Identifier": return F3(e, t); case "LiteralValue": return; case "FunctionCall": return I3(e); case "Case": return L3(e, t); case "UnaryOperation": return M3(e); case "BinaryOperation": return O3(e); case "TypeCast": return D3(e); default: throw new Error(`Unsupported expression: ${JSON.stringify(e)}`) } } function F3(e, t) { return t[e.name] } function I3(e) { switch (e.functionName) { case "CONTAINS": return Su.getDefinition(); case "STARTS_WITH": return wu.getDefinition(); case "ENDS_WITH": return ku.getDefinition(); default: throw new Error(`Unsupported function name: ${e.functionName}`) } } function L3(e, t) { let n = []; for (let r of e.conditions) { let i = ka(r.then, t); at(i) || n.push(i) } if (e.else) { let r = ka(e.else, t); at(r) || n.push(r) } return cu.getDefinition(n) ?? void 0 } function M3(e) { switch (e.operator) { case "not": return ga.getDefinition(); default: throw new Error(`Unsupported unary operator: ${e.operator}`) } } function O3(e) { switch (e.operator) { case "and": case "or": return ya.getDefinition(); case "==": case "!=": case "<": case "<=": case ">": case ">=": return Yn.getDefinition(); default: throw new Error(`Unsupported binary operator: ${e.operator}`) } } function D3(e) { switch (e.dataType) { case "BOOLEAN": return Cu.getDefinition(); case "DATE": return Sm.getDefinition(); case "NUMBER": return wm.getDefinition(); case "STRING": return km.getDefinition(); default: throw new Error(`Unsupported data type: ${e.dataType}`) } } function Qr(e, t) { return `(self: ${e}ms${t ? `, total: ${t}ms` : ""})` } function Gn(e) { return `(items: ${e})` } var Zr = class { constructor() { R(this, "executionTime", 0), R(this, "itemCount", 0) } async execute() { let e = performance.now(), t = await this._execute(); return this.executionTime = performance.now() - e, this.itemCount = t.length, t } }, bk = class extends Zr { constructor(e) { super(), this.collection = e } inspect() { return { label: `ScanCollectionPlan ${Qr(this.executionTime)} ${Gn(this.itemCount)}` } } async _execute() { return this.collection.scanItems() } }, hr = class extends Zr { constructor(e, t) { super(), this.index = e, this.query = t } inspect() { let e = [], t = n => { switch (n.type) { case "All": return n.type; case "Equals": case "NotEquals": case "LessThan": case "GreaterThan": case "Contains": case "StartsWith": case "EndsWith": return `${n.type} ${dn.stringify(n.value)}`; default: We(n) } }; for (let n = 0; n < this.index.fields.length; n++) { let r = this.index.fields[n], i = this.query[n]; !r || r.type !== "Identifier" || !i || i.type === "All" || e.push(`${r.name} ${t(i)}`) } return { label: `LookupIndexPlan(${e.join(", ")}) ${Qr(this.executionTime)} ${Gn(this.itemCount)}` } } async _execute() { return this.index.lookupItems(this.query) } }, A3 = class extends Zr { constructor(e) { super(), this.childPlans = e } inspect() { let e = Math.max(...this.childPlans.map(t => t.executionTime ?? 0)); return { label: `UnionPlan ${Qr(this.executionTime - e, this.executionTime)} ${Gn(this.itemCount)}`, nodes: this.childPlans.map(t => t.inspect()) } } async _execute() { let e = await Promise.all(this.childPlans.map(async n => { let r = await n.execute(); return new uu(r) })), t; for (let n of e) t ? t = t.union(n) : t = n; return t?.items() ?? [] } }, V3 = class extends Zr { constructor(e) { super(), this.childPlans = e } inspect() { let e = Math.max(...this.childPlans.map(t => t.executionTime ?? 0)); return { label: `IntersectionPlan ${Qr(this.executionTime - e, this.executionTime)} ${Gn(this.itemCount)} ${Gn(this.itemCount)}`, nodes: this.childPlans.map(t => t.inspect()) } } async _execute() { let e = await Promise.all(this.childPlans.map(async n => { let r = await n.execute(); return new uu(r) })), t; for (let n of e) t ? t = t.intersection(n) : t = n; return t?.items() ?? [] } }, B3 = class extends Zr { constructor(e, t, n, r) { super(), this.childPlan = e, this.collection = t, this.richTextResolver = n, this.select = r } inspect() { return { label: `ResolveItemsPlan ${Qr(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${Gn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } async _execute() { let e = await this.childPlan.execute(), t = e.map(n => n.pointer); for (let n of e) for (let r of this.select) { if (r.type !== "Identifier") continue; let i = n.data[r.name]; i?.type === "richtext" && this.richTextResolver.resolve(i.value) } return this.collection.resolveItems(t) } }, $3 = class extends Zr { constructor(e, t) { super(), this.childPlan = e, this.filterExpression = t } inspect() { return { label: `FilterItemsPlan(${this.filterExpression.stringify()}) ${Qr(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${Gn(this.itemCount)} ${Gn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } async _execute() { return (await this.childPlan.execute()).filter(t => { let n = this.filterExpression.evaluate(t); return Li(n) }) } }, z3 = class extends Zr { constructor(e, t, n) { super(), this.childPlan = e, this.orderExpressions = t, this.collection = n } inspect() { return { label: `SortItemsPlan(${this.orderExpressions.map(t => `${t.expression.stringify()} ${t.direction.toUpperCase()}`).join(", ")}) ${Qr(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${Gn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } async _execute() { return (await this.childPlan.execute()).sort((t, n) => { for (let { expression: r, direction: i, collation: o } of this.orderExpressions) { let s = i === "asc"; if (r instanceof lt && r.name === Qp) { let c = this.collection.compareItems(t, n); return s ? c : -c } let a = r.evaluate(t), l = r.evaluate(n); if (!dn.equal(a, l, o)) { if (dn.lessThan(a, l, o) || zo(a)) return s ? -1 : 1; if (dn.greaterThan(a, l, o) || zo(l)) return s ? 1 : -1; throw new Error("Invalid comparison result.") } } return this.collection.compareItems(t, n) }) } }, N3 = class { constructor(e, t, n) { this.expression = e, this.direction = t, this.collation = n } }, H3 = class extends Zr { constructor(e, t, n) { super(), this.childPlan = e, this.offsetExpression = t, this.limitExpression = n } inspect() { var e, t; return { label: `SliceItemsPlan(LIMIT ${((e = this.limitExpression) == null ? void 0 : e.stringify()) ?? "Infinity"}, OFFSET ${((t = this.offsetExpression) == null ? void 0 : t.stringify()) ?? "0"}) ${Qr(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${Gn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } getOffset() { var e; let t = (e = this.offsetExpression) == null ? void 0 : e.evaluate(); if (!(zo(t) || t.type !== "number")) return t.value } getLimit() { var e; let t = (e = this.limitExpression) == null ? void 0 : e.evaluate(); if (!(zo(t) || t.type !== "number")) return t.value } async _execute() { let e = await this.childPlan.execute(), t = this.getOffset() ?? 0, n = this.getLimit() ?? 1 / 0; return e.slice(t, t + n) } }, uu = class extends Map { constructor(e = []) { super(); for (let t of e) this.set(t.pointer, t) } union(e) { let t = new uu; for (let [n, r] of this) t.set(n, r); for (let [n, r] of e) t.set(n, r); return t } intersection(e) { let t = new uu; for (let [n, r] of this) e.has(n) && t.set(n, r); return t } items() { return [...this.values()] } }, j3 = class { constructor(e) { this.collection = e, R(this, "cache", new Map) } resolve(e) { let t = this.cache.get(e); if (t) return t; let n = this.collection.resolveRichText(e); return this.cache.set(e, n), n } }; function W3(e, t) { var n; if (xm(e)) { let r = ww(e), i = (n = r?.[t.name]) == null ? void 0 : n.title; if (i) return `"${t.name}" /* ${i} */` } return `"${t.name}"` } function U3(e) { return typeof e.value == "string" ? `'${e.value}'` : e.value } function X3(e, t) { return `${t.functionName}(${t.arguments.map(n => qt(e, n)).join(", ")})` } function Y3(e, t) { let n = "CASE"; t.value && (n += ` ${qt(e, t.value)}`); for (let r of t.conditions) n += ` WHEN ${qt(e, r.when)} THEN ${qt(e, r.then)}`; return t.else && (n += ` ELSE ${t.else}`), n += " END", n } function G3(e, t) { let n = qt(e, t.value); return `${t.operator.toUpperCase()} ${n}` } function K3(e, t) { let n = qt(e, t.left), r = qt(e, t.right), i = t.operator.toUpperCase(); return `${n} ${i} ${r}` } function q3(e, t) { return `CAST(${qt(e, t.value)} as ${t.dataType})` } function qt(e, t) { switch (t.type) { case "Identifier": return W3(e, t); case "LiteralValue": return U3(t); case "FunctionCall": return X3(e, t); case "Case": return Y3(e, t); case "UnaryOperation": return G3(e, t); case "BinaryOperation": return K3(e, t); case "TypeCast": return q3(e, t); default: We(t) } } function Q3(e) {
    let t = ""; return e.split(/\s+/u).forEach(r => {
        r !== "" && (["SELECT", "FROM", "WHERE", "ORDER", "LIMIT", "OFFSET"].includes(r) ? t += `
${r}` : ["AND", "OR"].includes(r) ? t += `
	${r}` : t += ` ${r}`)
    }), t.trim()
} function Z3(e) { let t = ""; return t += `SELECT ${e.select.map(n => { let r = qt(e.from.data, n); return n.alias ? `${r} AS ${n.alias}` : r }).join(", ")}`, xm(e.from.data) ? t += ` FROM ${e.from.data.displayName}` : t += ` FROM ${e.from.data.displayName}`, e.where && (t += ` WHERE ${qt(e.from.data, e.where)}`), e.orderBy && (t += ` ORDER BY ${e.orderBy.map(n => `${qt(e.from.data, n)} ${n.direction ?? "asc"}`).join(", ")}`), e.limit && (t += ` LIMIT ${qt(e.from.data, e.limit)}`), e.offset && (t += ` OFFSET ${qt(e.from.data, e.offset)}`), Q3(t) } var J3 = r3("query-engine"); function e5({ data: e }, t) { if (o3(e)) return new a3(e, t); if (s3(e)) return e; if (xm(e)) { for (; t;) { let n = e.collectionByLocaleId[t.id]; if (n) return n; t = t.fallback } return e.collectionByLocaleId.default } We(e, "Unsupported collection type") } var t5 = class {
    async query(e, t) {
        let n = e5(e.from, t), r = new j3(n), i = this.createQueryPlan(n, r, e), o = await this.executeQueryPlan(n, r, e, i); return J3.debug(`Query:
${Z3(e)}

${(0, n3.default)(i.inspect())}`), o
    } createQueryPlan(e, t, n) { var r; let i = new bk(e); if (n.where) { let l = Tt.from(n.where, e.schema); i = Jp(e, l) } let o = (r = n.orderBy) == null ? void 0 : r.map(l => new N3(Tt.from(l, e.schema), l.direction ?? "asc", { type: 0 })); i = new z3(i, o ?? [], e); let s; n.offset && (s = Tt.from(n.offset, e.schema)); let a; return n.limit && (a = Tt.from(n.limit, e.schema)), (s || a) && (i = new H3(i, s, a)), n.select.length > 0 && (i = new B3(i, e, t, n.select)), i } async executeQueryPlan(e, t, n, r) { let i = await r.execute(); return Promise.all(i.map(async o => { let s = {}; for (let a of n.select) { let l = Tt.from(a, e.schema), c = n5(a), u = l.evaluate(o); s[c] = await r5(t, u) } return s })) }
}; function n5(e) { if (e.alias) return e.alias; if (e.type === "Identifier") return e.name; throw new Error("Can't serialize expression") } async function r5(e, t) { return zo(t) ? null : t.type === "richtext" ? e.resolve(t.value) : t.value } function Jp(e, t) { if (t instanceof Pi) { let n = t.operandExpressions.map(r => Jp(e, r)); return new V3(n) } if (t instanceof ua) { let n = t.operandExpressions.map(r => Jp(e, r)); return new A3(n) } return i5(e, t) ?? s5(e, t) } function i5(e, t) { var n, r; if (t instanceof Yn) return $p(e, t); if (t instanceof Ia) return o5(e, t); if (t instanceof lt && ((n = t.definition) == null ? void 0 : n.type) === "boolean") { let i = Ie.fromBoolean(!0), o = new No(t, i); return $p(e, o) } if (t instanceof ga && t.valueExpression instanceof lt && ((r = t.valueExpression.definition) == null ? void 0 : r.type) === "boolean") { let i = Ie.fromBoolean(!0), o = new Ho(t.valueExpression, i); return $p(e, o) } } function $p(e, t) { let n = t.leftExpression, r = t.rightExpression; if (r instanceof Ie) for (let i of e.indexes) { let o = i.fields[0]; if (at(o)) continue; let s = Tt.from(o, e.schema); if (!n.equals(s)) continue; let a = new Array(i.fields.length - 1).fill({ type: "All" }); if (t instanceof No && i.supportedLookupTypes.includes("Equals")) return new hr(i, [{ type: "Equals", value: r.evaluate() }, ...a]); if (t instanceof Ho && i.supportedLookupTypes.includes("NotEquals")) return new hr(i, [{ type: "NotEquals", value: r.evaluate() }, ...a]); if (t instanceof ba && i.supportedLookupTypes.includes("LessThan")) return new hr(i, [{ type: "LessThan", value: r.evaluate(), inclusive: !1 }, ...a]); if (t instanceof xa && i.supportedLookupTypes.includes("LessThan")) return new hr(i, [{ type: "LessThan", value: r.evaluate(), inclusive: !0 }, ...a]); if (t instanceof Sa && i.supportedLookupTypes.includes("GreaterThan")) return new hr(i, [{ type: "GreaterThan", value: r.evaluate(), inclusive: !1 }, ...a]); if (t instanceof wa && i.supportedLookupTypes.includes("GreaterThan")) return new hr(i, [{ type: "GreaterThan", value: r.evaluate(), inclusive: !0 }, ...a]) } } function o5(e, t) { if (t.argumentExpressions.length !== 2) return; let n = t.argumentExpressions[0], r = t.argumentExpressions[1]; if (!at(n) && !at(r) && r instanceof Ie) for (let i of e.indexes) { let o = i.fields[0]; if (at(o)) continue; let s = Tt.from(o, e.schema); if (!n.equals(s)) continue; let a = new Array(i.fields.length - 1).fill({ type: "All" }); if (t instanceof Su && i.supportedLookupTypes.includes("Contains")) return new hr(i, [{ type: "Contains", value: r.evaluate() }, ...a]); if (t instanceof wu && i.supportedLookupTypes.includes("StartsWith")) return new hr(i, [{ type: "StartsWith", value: r.evaluate() }, ...a]); if (t instanceof ku && i.supportedLookupTypes.includes("EndsWith")) return new hr(i, [{ type: "EndsWith", value: r.evaluate() }, ...a]) } } function s5(e, t) { let n = new bk(e); return new $3(n, t) } var a5 = class { constructor() { R(this, "entries", new Map) } set(e, t, n, r) { let i = this.entries.get(e); switch (t) { case "transformTemplate": { de(typeof n == "string", `transformTemplate must be a string, received: ${n}`), i ? i.transformTemplate = n : this.entries.set(e, { transformTemplate: n }); break } case "initial": case "animate": { de(typeof n == "object", `${t} must be a valid object, received: ${n}`), i ? (i[t] = n, i.variantHash || (i.variantHash = r)) : this.entries.set(e, { [t]: n, variantHash: r }); break } default: break } } clear() { this.entries.clear() } toObject() { return Object.fromEntries(this.entries) } }, xk = new a5, i8 = (e, t, n, r) => (mr() || xk.set(t, e, n, r), n), l5 = "__Appear_Animation_Transform__", o8 = (e, t) => { if (!mr()) { let n = t?.({}, l5); if (n === void 0) return t; xk.set(e, "transformTemplate", n) } return t }, s8 = "data-framer-appear-id", a8 = "data-framer-appear-animation"; function zp(e, t) { e.forEach(n => clearTimeout(n)), e.clear(), t.forEach(n => n && n("Callback cancelled by variant change")), t.clear() } function PS() { return new Set } function c8(e) { let t = Rt(PS), n = Rt(PS); return jw(() => () => zp(n, t)), b.useEffect(() => () => zp(n, t), [t, n]), b.useEffect(() => { zp(n, t) }, [e, t, n]), b.useRef({ activeVariantCallback: r => (...i) => new Promise((o, s) => { t.add(s), r(...i).then(o) }).catch(() => { }), delay: async (r, i) => { await new Promise(o => n.add(globalThis.setTimeout(() => o(!0), i))), r() } }).current } function c5(e, t, n) { return b.useCallback(r => { var i, o, s; return n ? e ? t ? Object.assign({}, (i = n[e]) == null ? void 0 : i[r], (o = n[t]) == null ? void 0 : o[r]) : ((s = n[e]) == null ? void 0 : s[r]) || {} : {} : {} }, [e, t, n]) } function u5(e) { for (let [t, n] of Object.entries(e)) if (Ve.matchMedia(n).matches) return t } function f5(e) { var t; for (let { hash: n, mediaQuery: r } of e) { if (!r) continue; if (Ve.matchMedia(r).matches) return n } return (t = e[0]) == null ? void 0 : t.hash } function d8(e, t, n = !0) { let r = O(Yw), i = D(mr() ? u5(t) ?? e : e), o = D(n && r ? e : i.current), s = vu(), a = r0(), l = pe(c => { (c !== i.current || c !== o.current) && a(() => { i.current = o.current = c, Ai(() => { s() }) }) }, [a, s]); return Pw(() => { !n || r !== !0 || l(i.current) }, []), H(() => { let c = []; for (let [u, f] of Object.entries(t)) { let d = Ve.matchMedia(f), p = g => { g.matches && l(u) }; d5(d, p), c.push([d, p]) } return () => c.forEach(([u, f]) => h5(u, f)) }, [t, l]), [i.current, o.current] } function d5(e, t) { e.addEventListener ? e.addEventListener("change", t) : e.addListener(t) } function h5(e, t) { e.removeEventListener ? e.removeEventListener("change", t) : e.removeListener(t) } function h8(e) { var t, n; let r = f5(e); if (r) for (let i of document.querySelectorAll(".hidden-" + r)) (t = i.parentNode) == null || t.removeChild(i); for (let i of document.querySelectorAll(".ssr-variant:empty")) (n = i.parentNode) == null || n.removeChild(i) } function Tu() { return oe.current() === oe.canvas } function _S(e, t) { if (e[t]) return e[t]; if (!(t in e)) return e.default } function b8(e, t) { if (Tu()) return; let r = b.useRef(!0), i = b.useRef(t); jw((o, s) => { let a = o && !s; if (!r.current && a) { let l = _S(i.current, e); l && l() } r.current = a }, []), b.useEffect(() => { if (r.current) { let o = _S(i.current, e); o && o() } }, [e]) } function S8({ blockDocumentScrolling: e = !0 } = {}) { let [t, n] = b.useState(!1), r = b.useCallback(i => { n(i), e !== !1 && (i ? document.documentElement.style.setProperty("overflow", "hidden") : document.documentElement.style.removeProperty("overflow")) }, [e]); return b.useEffect(() => () => { e !== !1 && document.documentElement.style.removeProperty("overflow") }, [e]), [t, r] } var p5 = class { constructor(e) { this.queryEngine = e, R(this, "cache", new Map) } get(e, t) { let n = v5(e, t), r = this.cache.get(n); if (r) return r; let i = () => this.queryEngine.query(e, t), o = new xu(i); return this.cache.set(n, o), o } }, FS = new WeakMap; function m5(e) { let t = FS.get(e); if (t) return t; let n = Math.random().toString(16).slice(2); return FS.set(e, n), n } function v5({ from: e, ...t }, n) { let r = m5(e.data), i = n?.id ?? "default"; return r + JSON.stringify(t) + i } function g5(e) { throw e } var y5 = new t5, b5 = new p5(y5); function x5(e) { let { activeLocale: t } = du(), n = b5.get(e, t), r = n.preload(); return r && g5(r), n.read() } function S5(e) { let t = { ...e, select: [] }; return x5(t).length } function k8(e) { let n = Object.entries(e).filter(([, r]) => !(at(r) || ke(r))).map(([r, i]) => ({ type: "BinaryOperation", operator: "==", left: { type: "TypeCast", value: { type: "Identifier", name: r }, dataType: "STRING" }, right: { type: "LiteralValue", value: String(i) } })); return n.length === 0 ? { type: "LiteralValue", value: !1 } : n.reduce((r, i) => ({ type: "BinaryOperation", operator: "and", left: r, right: i })) } function T8(e, t, n) { let r = S5(e), [i, o] = ut(() => { var c, u, f, d; let p = Math.ceil(r / t); return { currentPage: ((d = (f = (u = (c = globalThis?.history) == null ? void 0 : c.state) == null ? void 0 : u.paginationInfo) == null ? void 0 : f[n]) == null ? void 0 : d.currentPage) ?? 1, totalPages: p, isLoading: !1 } }); H(() => { $I(n, i) }, [n, i]); let s = he(() => { let c = t * i.currentPage; if (e.limit) { if (e.limit.type !== "LiteralValue" || typeof e.limit.value != "number") throw new Error("Unexpected type for query limit"); c = Math.min(c, e.limit.value) } return { ...e, limit: { type: "LiteralValue", value: c } } }, [e, t, i]), a = Tu(), l = pe(() => { a || i.currentPage >= i.totalPages || (o(c => ({ ...c, isLoading: !0 })), requestAnimationFrame(() => { o(c => ({ ...c, currentPage: Math.min(c.currentPage + 1, c.totalPages), isLoading: !1 })) })) }, [a, i.currentPage, i.totalPages]); return { paginatedQuery: s, paginationInfo: i, loadMore: l } } function w5(e, t) { return `${e}-${t}` } function k5(e, t) { let r = e.indexOf(t) + 1; r >= e.length && (r = 0); let i = e[r]; return de(i !== void 0, "nextVariant should be defined"), i } function C5(e, t) { if (e) { if (t) { let n = e[t]; if (n) return n } return e.default } } function IS(e, t, n) { let { hover: r, pressed: i } = e || {}; if (i && n) return "pressed"; if (r && t) return "hover" } function T5(e, t) { let n = t[e]; return n || `framer-v-${e}` } function LS(e, t, n) { return e && n.has(e) ? e : t } var E5 = Symbol("cycle"); function R8({ variant: e, defaultVariant: t, transitions: n, enabledGestures: r, cycleOrder: i = [], variantProps: o = {}, variantClassNames: s = {} }) { let a = vu(), l = Rt(() => new Set(i)), c = b.useRef({ isHovered: !1, isPressed: !1, hasPressedVariants: !0, baseVariant: LS(e, t, l), lastVariant: e, gestureVariant: void 0, defaultVariant: t, enabledGestures: r, cycleOrder: i, transitions: n }), u = b.useCallback(x => { let { isHovered: k, isPressed: w, enabledGestures: T, defaultVariant: E } = c.current, I = LS(x, E, l), F = IS(T?.[I], k, w), B = F ? w5(I, F) : void 0; return [I, B] }, [l]), f = b.useCallback(({ isHovered: x, isPressed: k }) => { x !== void 0 && (c.current.isHovered = x), k !== void 0 && (c.current.isPressed = k); let { baseVariant: w, gestureVariant: T, defaultVariant: E } = c.current, [I, F] = u(w); (I !== w || F !== T) && (c.current.baseVariant = I || E, c.current.gestureVariant = F, a()) }, [u, a]), d = b.useCallback(x => { let { defaultVariant: k, cycleOrder: w, baseVariant: T, gestureVariant: E } = c.current, I = x === E5 ? k5(w || [], T || k) : x, [F, B] = u(I); (F !== T || B !== E) && (c.current.baseVariant = F || k, c.current.gestureVariant = B, a()) }, [u, a]); if (e !== c.current.lastVariant) { let [x, k] = u(e); c.current.lastVariant = x, (x !== c.current.baseVariant || k !== c.current.gestureVariant) && (c.current.baseVariant = x, c.current.gestureVariant = k) } let { baseVariant: p, gestureVariant: g, defaultVariant: v, enabledGestures: S, isHovered: m, isPressed: h } = c.current, y = c5(c.current.baseVariant, c.current.gestureVariant, o); return b.useMemo(() => { let x = []; p !== v && x.push(p), g && x.push(g); let k = S?.[p], w = {}; return k?.hover && Object.assign(w, { onMouseEnter: () => f({ isHovered: !0 }), onMouseLeave: () => f({ isHovered: !1 }) }), k?.pressed && Object.assign(w, { onTapStart: () => f({ isPressed: !0 }), onTapCancel: () => f({ isPressed: !1 }), onTap: () => f({ isPressed: !1 }) }), { variants: x, baseVariant: p, gestureVariant: g, transition: C5(c.current.transitions, p), setVariant: d, setGestureState: f, addVariantProps: y, gestureHandlers: w, classNames: pm(T5(p, s), IS(k, m, h)) } }, [p, g, m, h, y, d, v, S, f, s]) } function R5(e) { var t; let n = (t = e.__FramerMetadata__.exports.default.annotations) == null ? void 0 : t.framerVariables; if (n) try { return JSON.parse(n) } catch { return } } function _8(e, t) { return n => { let r = {}, i = R5(t); for (let o in n) Be(r)[i?.[o] ?? o] = n[o]; return C(e, { ...r }) } } var P5 = b.createContext(void 0), _5 = () => b.useContext(P5); var F5 = { Arial: { Regular: { selector: "Arial", weight: void 0 }, Black: { selector: "Arial-Black", weight: void 0 }, Narrow: { selector: "Arial Narrow", weight: void 0 }, "Rounded Bold": { selector: "Arial Rounded MT Bold", weight: void 0 } }, Avenir: { Book: { selector: "Avenir", weight: void 0 }, Light: { selector: "Avenir-Light", weight: void 0 }, Medium: { selector: "Avenir-Medium", weight: void 0 }, Heavy: { selector: "Avenir-Heavy", weight: void 0 }, Black: { selector: "Avenir-Black", weight: void 0 } }, "Avenir Next": { Regular: { selector: "Avenir Next", weight: void 0 }, "Ultra Light": { selector: "AvenirNext-UltraLight", weight: void 0 }, Medium: { selector: "AvenirNext-Medium", weight: void 0 }, "Demi Bold": { selector: "AvenirNext-DemiBold", weight: void 0 }, Heavy: { selector: "AvenirNext-Heavy", weight: void 0 } }, "Avenir Next Condensed": { Regular: { selector: "Avenir Next Condensed", weight: void 0 }, "Ultra Light": { selector: "AvenirNextCondensed-UltraLight", weight: void 0 }, Medium: { selector: "AvenirNextCondensed-Medium", weight: void 0 }, "Demi Bold": { selector: "AvenirNextCondensed-DemiBold", weight: void 0 }, Heavy: { selector: "AvenirNextCondensed-Heavy", weight: void 0 } }, Baskerville: { Regular: { selector: "Baskerville", weight: void 0 }, "Semi Bold": { selector: "Baskerville-SemiBold", weight: void 0 } }, "Bodoni 72": { Book: { selector: "Bodoni 72", weight: void 0 }, Oldstyle: { selector: "Bodoni 72 Oldstyle", weight: void 0 }, Smallcaps: { selector: "Bodoni 72 Smallcaps", weight: void 0 } }, Courier: { Regular: { selector: "Courier", weight: void 0 } }, "Courier New": { Regular: { selector: "Courier New", weight: void 0 } }, Futura: { Medium: { selector: "Futura", weight: void 0 }, Condensed: { selector: "Futura-CondensedMedium", weight: void 0 }, "Condensed ExtraBold": { selector: "Futura-CondensedExtraBold", weight: void 0 } }, Georgia: { Regular: { selector: "Georgia", weight: void 0 } }, "Gill Sans": { Regular: { selector: "Gill Sans", weight: void 0 }, Light: { selector: "GillSans-Light", weight: void 0 }, SemiBold: { selector: "GillSans-SemiBold", weight: void 0 }, UltraBold: { selector: "GillSans-UltraBold", weight: void 0 } }, Helvetica: { Regular: { selector: "Helvetica", weight: void 0 }, Light: { selector: "Helvetica-Light", weight: void 0 }, Bold: { selector: "Helvetica-Bold", weight: void 0 }, Oblique: { selector: "Helvetica-Oblique", weight: void 0 }, "Light Oblique": { selector: "Helvetica-LightOblique", weight: void 0 }, "Bold Oblique": { selector: "Helvetica-BoldOblique", weight: void 0 } }, "Helvetica Neue": { Regular: { selector: "Helvetica Neue", weight: void 0 }, UltraLight: { selector: "HelveticaNeue-UltraLight", weight: void 0 }, Thin: { selector: "HelveticaNeue-Thin", weight: void 0 }, Light: { selector: "HelveticaNeue-Light", weight: void 0 }, Medium: { selector: "HelveticaNeue-Medium", weight: void 0 }, Bold: { selector: "HelveticaNeue-Bold", weight: void 0 }, Italic: { selector: "HelveticaNeue-Italic", weight: void 0 }, "UltraLight Italic": { selector: "HelveticaNeue-UltraLightItalic", weight: void 0 }, "Thin Italic": { selector: "HelveticaNeue-ThinItalic", weight: void 0 }, "Light Italic": { selector: "HelveticaNeue-LightItalic", weight: void 0 }, "Medium Italic": { selector: "HelveticaNeue-MediumItalic", weight: void 0 }, "Bold Italic": { selector: "HelveticaNeue-BoldItalic", weight: void 0 }, "Condensed Bold": { selector: "HelveticaNeue-CondensedBold", weight: void 0 }, "Condensed Black": { selector: "HelveticaNeue-CondensedBlack", weight: void 0 } }, "Hoefler Text": { Regular: { selector: "Hoefler Text", weight: void 0 } }, Impact: { Regular: { selector: "Impact", weight: void 0 } }, "Lucida Grande": { Regular: { selector: "Lucida Grande", weight: void 0 } }, Menlo: { Regular: { selector: "Menlo", weight: void 0 } }, Monaco: { Regular: { selector: "Monaco", weight: void 0 } }, Optima: { Regular: { selector: "Optima", weight: void 0 }, ExtraBlack: { selector: "Optima-ExtraBlack", weight: void 0 } }, Palatino: { Regular: { selector: "Palatino", weight: void 0 } }, "SF Pro Display": { Regular: { selector: "__SF-UI-Display-Regular__", weight: 400 }, Ultralight: { selector: "__SF-UI-Display-Ultralight__", weight: 100 }, Thin: { selector: "__SF-UI-Display-Thin__", weight: 200 }, Light: { selector: "__SF-UI-Display-Light__", weight: 300 }, Medium: { selector: "__SF-UI-Display-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Display-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Display-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Display-Heavy__", weight: 800 }, Black: { selector: "__SF-UI-Display-Black__", weight: 900 }, Italic: { selector: "__SF-UI-Display-Italic__", weight: 400 }, "Ultralight Italic": { selector: "__SF-UI-Display-Ultralight-Italic__", weight: 100 }, "Thin Italic": { selector: "__SF-UI-Display-Thin-Italic__", weight: 200 }, "Light Italic": { selector: "__SF-UI-Display-Light-Italic__", weight: 300 }, "Medium Italic": { selector: "__SF-UI-Display-Medium-Italic__", weight: 500 }, "Semibold Italic": { selector: "__SF-UI-Display-Semibold-Italic__", weight: 600 }, "Bold Italic": { selector: "__SF-UI-Display-Bold-Italic__", weight: 700 }, "Heavy Italic": { selector: "__SF-UI-Display-Heavy-Italic__", weight: 800 }, "Black Italic": { selector: "__SF-UI-Display-Black-Italic__", weight: 900 } }, "SF Pro Display Condensed": { Regular: { selector: "__SF-UI-Display-Condensed-Regular__", weight: 400 }, Ultralight: { selector: "__SF-UI-Display-Condensed-Ultralight__", weight: 100 }, Thin: { selector: "__SF-UI-Display-Condensed-Thin__", weight: 200 }, Light: { selector: "__SF-UI-Display-Condensed-Light__", weight: 300 }, Medium: { selector: "__SF-UI-Display-Condensed-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Display-Condensed-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Display-Condensed-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Display-Condensed-Heavy__", weight: 800 }, Black: { selector: "__SF-UI-Display-Condensed-Black__", weight: 900 } }, "SF Pro Text": { Regular: { selector: "__SF-UI-Text-Regular__", weight: 400 }, Light: { selector: "__SF-UI-Text-Light__", weight: 200 }, Medium: { selector: "__SF-UI-Text-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Text-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Text-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Text-Heavy__", weight: 800 }, Italic: { selector: "__SF-UI-Text-Italic__", weight: 400 }, "Light Italic": { selector: "__SF-UI-Text-Light-Italic__", weight: 200 }, "Medium Italic": { selector: "__SF-UI-Text-Medium-Italic__", weight: 500 }, "Semibold Italic": { selector: "__SF-UI-Text-Semibold-Italic__", weight: 600 }, "Bold Italic": { selector: "__SF-UI-Text-Bold-Italic__", weight: 700 }, "Heavy Italic": { selector: "__SF-UI-Text-Heavy-Italic__", weight: 800 } }, "SF Pro Text Condensed": { Regular: { selector: "__SF-UI-Text-Condensed-Regular__", weight: 400 }, Light: { selector: "__SF-UI-Text-Condensed-Light__", weight: 200 }, Medium: { selector: "__SF-UI-Text-Condensed-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Text-Condensed-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Text-Condensed-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Text-Condensed-Heavy__", weight: 800 } }, Tahoma: { Regular: { selector: "Tahoma", weight: void 0 } }, Times: { Regular: { selector: "Times", weight: void 0 } }, "Times New Roman": { Regular: { selector: "Times New Roman", weight: void 0 } }, Trebuchet: { Regular: { selector: "Trebuchet MS", weight: void 0 } }, Verdana: { Regular: { selector: "Verdana", weight: void 0 } } }, I5 = { "__SF-Compact-Display-Regular__": "SFCompactDisplay-Regular|.SFCompactDisplay-Regular", "__SF-Compact-Display-Ultralight__": "SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight", "__SF-Compact-Display-Thin__": "SFCompactDisplay-Thin|.SFCompactDisplay-Thin", "__SF-Compact-Display-Light__": "SFCompactDisplay-Light|.SFCompactDisplay-Light", "__SF-Compact-Display-Medium__": "SFCompactDisplay-Medium|.SFCompactDisplay-Medium", "__SF-Compact-Display-Semibold__": "SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold", "__SF-Compact-Display-Heavy__": "SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy", "__SF-Compact-Display-Black__": "SFCompactDisplay-Black|.SFCompactDisplay-Black", "__SF-Compact-Display-Bold__": "SFCompactDisplay-Bold|.SFCompactDisplay-Bold", "__SF-UI-Text-Regular__": ".SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText", "__SF-UI-Text-Light__": ".SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light", "__SF-UI-Text-Medium__": ".SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium", "__SF-UI-Text-Semibold__": ".SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold", "__SF-UI-Text-Bold__": ".SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold", "__SF-UI-Text-Heavy__": ".SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy", "__SF-UI-Text-Italic__": ".SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic", "__SF-UI-Text-Light-Italic__": ".SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic", "__SF-UI-Text-Medium-Italic__": ".SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic", "__SF-UI-Text-Semibold-Italic__": ".SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic", "__SF-UI-Text-Bold-Italic__": ".SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic", "__SF-UI-Text-Heavy-Italic__": ".SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic", "__SF-Compact-Text-Regular__": "SFCompactText-Regular|.SFCompactText-Regular", "__SF-Compact-Text-Light__": "SFCompactText-Light|.SFCompactText-Light", "__SF-Compact-Text-Medium__": "SFCompactText-Medium|.SFCompactText-Medium", "__SF-Compact-Text-Semibold__": "SFCompactText-Semibold|.SFCompactText-Semibold", "__SF-Compact-Text-Bold__": "SFCompactText-Bold|.SFCompactText-Bold", "__SF-Compact-Text-Heavy__": "SFCompactText-Heavy|.SFCompactText-Heavy", "__SF-Compact-Text-Italic__": "SFCompactText-Italic|.SFCompactText-Italic", "__SF-Compact-Text-Light-Italic__": "SFCompactText-LightItalic|.SFCompactText-LightItalic", "__SF-Compact-Text-Medium-Italic__": "SFCompactText-MediumItalic|.SFCompactText-MediumItalic", "__SF-Compact-Text-Semibold-Italic__": "SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic", "__SF-Compact-Text-Bold-Italic__": "SFCompactText-BoldItalic|.SFCompactText-BoldItalic", "__SF-Compact-Text-Heavy-Italic__": "SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic", "__SF-UI-Display-Condensed-Regular__": ".SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular", "__SF-UI-Display-Condensed-Ultralight__": ".SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight", "__SF-UI-Display-Condensed-Thin__": ".SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin", "__SF-UI-Display-Condensed-Light__": ".SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light", "__SF-UI-Display-Condensed-Medium__": ".SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium", "__SF-UI-Display-Condensed-Semibold__": ".SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold", "__SF-UI-Display-Condensed-Bold__": ".SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold", "__SF-UI-Display-Condensed-Heavy__": ".SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy", "__SF-UI-Display-Condensed-Black__": ".SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black", "__SF-UI-Display-Regular__": ".SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay", "__SF-UI-Display-Ultralight__": ".SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight", "__SF-UI-Display-Thin__": ".SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin", "__SF-UI-Display-Light__": ".SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light", "__SF-UI-Display-Medium__": ".SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium", "__SF-UI-Display-Semibold__": ".SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold", "__SF-UI-Display-Bold__": ".SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold", "__SF-UI-Display-Heavy__": ".SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy", "__SF-UI-Display-Black__": ".SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black", "__SF-UI-Display-Italic__": ".SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic", "__SF-UI-Display-Ultralight-Italic__": ".SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic", "__SF-UI-Display-Thin-Italic__": ".SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic", "__SF-UI-Display-Light-Italic__": ".SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic", "__SF-UI-Display-Medium-Italic__": ".SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic", "__SF-UI-Display-Semibold-Italic__": ".SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic", "__SF-UI-Display-Bold-Italic__": ".SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic", "__SF-UI-Display-Heavy-Italic__": ".SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic", "__SF-UI-Display-Black-Italic__": ".SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic", "__SF-UI-Text-Condensed-Regular__": ".SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular", "__SF-UI-Text-Condensed-Light__": ".SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light", "__SF-UI-Text-Condensed-Medium__": ".SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium", "__SF-UI-Text-Condensed-Semibold__": ".SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold", "__SF-UI-Text-Condensed-Bold__": ".SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold", "__SF-UI-Text-Condensed-Heavy__": ".SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy", "__SF-Compact-Rounded-Regular__": "SFCompactRounded-Regular|.SFCompactRounded-Regular", "__SF-Compact-Rounded-Ultralight__": "SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight", "__SF-Compact-Rounded-Thin__": "SFCompactRounded-Thin|.SFCompactRounded-Thin", "__SF-Compact-Rounded-Light__": "SFCompactRounded-Light|.SFCompactRounded-Light", "__SF-Compact-Rounded-Medium__": "SFCompactRounded-Medium|.SFCompactRounded-Medium", "__SF-Compact-Rounded-Semibold__": "SFCompactRounded-Semibold|.SFCompactRounded-Semibold", "__SF-Compact-Rounded-Bold__": "SFCompactRounded-Bold|.SFCompactRounded-Bold", "__SF-Compact-Rounded-Heavy__": "SFCompactRounded-Heavy|.SFCompactRounded-Heavy", "__SF-Compact-Rounded-Black__": "SFCompactRounded-Black|.SFCompactRounded-Black" }, MS = F5; var L5 = "System Default", M5 = class { constructor() { R(this, "name", "local"), R(this, "fontFamilies", []), R(this, "byFamilyName", new Map), R(this, "fontAliasBySelector", new Map), R(this, "fontAliases", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } createFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.addFontFamily(t), t } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } importFonts() { let e = []; for (let r of Object.keys(MS)) { let i = MS[r]; if (!i) continue; let o = this.createFontFamily(r); for (let s of Object.keys(i)) { let a = i[s]; if (!a) continue; let { selector: l, weight: c } = a, u = { variant: s, selector: l, weight: c, family: o }; o.fonts.push(u) } e.push(...o.fonts) } for (let [r, i] of Object.entries(I5)) this.addFontAlias(r, i); let { fontFamily: t, aliases: n } = this.getSystemFontFamily(); this.addFontFamily(t); for (let [r, i] of n) this.addFontAlias(r, i); return e.push(...t.fonts), e } addFontAlias(e, t) { this.fontAliases.set(e, t), this.fontAliasBySelector.set(t, e) } getSystemFontFamily() { let e = "system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif", t = { name: L5, fonts: [], source: this.name }, n = new Map, r = [400, 100, 200, 300, 500, 600, 700, 800, 900], i = ["normal", "italic"]; for (let o of i) for (let s of r) { let a = O5(s, o), l = `__SystemDefault-${s}-${o}__`, c = { variant: a, selector: l, style: o, weight: s, family: t }; t.fonts.push(c), n.set(l, e) } return { fontFamily: t, aliases: n } } getFontAliasBySelector(e) { return this.fontAliasBySelector.get(e) || null } getFontSelectorByAlias(e) { return this.fontAliases.get(e) || null } isFontFamilyAlias(e) { return !!(e && /^__.*__$/u.exec(e)) } }, OS = { 100: "Thin", 200: "Extra Light", 300: "Light", 400: "Normal", 500: "Medium", 600: "Semi Bold", 700: "Bold", 800: "Extra Bold", 900: "Black" }; function O5(e, t) { let n = t === "normal" ? "Regular" : "Italic"; return e === 400 ? n : t !== "normal" ? `${OS[e]} ${n}` : `${OS[e]}` } var D5 = Dn(em(), 1), Oo = "CUSTOM;"; function A5(e, t) { if (!t) return e.substring(0, e.lastIndexOf(".")); let n = t.font.preferredFamily === "" ? t.font.fontFamily : t.font.preferredFamily, r = t.font.preferredSubFamily === "" ? t.font.fontSubFamily : t.font.preferredSubFamily; return `${n} ${r}` } var V5 = class { constructor() { R(this, "name", "custom"), R(this, "fontFamilies", []), R(this, "byFamilyName", new Map), R(this, "assetsByFamily", new Map) } importFonts(e) { var t; this.fontFamilies.length = 0, this.byFamilyName.clear(), this.assetsByFamily.clear(); let n = []; for (let r of e) { if (!this.isValidCustomFontAsset(r)) continue; let i = A5(r.name, r.properties), o = this.createFontFamily(i), s = { family: o, selector: `${Oo}${i}`, variant: this.inferVariantName(i), postscriptName: (t = r.properties) == null ? void 0 : t.font.postscriptName, file: r.url }; o.fonts.push(s), o.owner = r.ownerType === "team" ? "team" : "project", this.assetsByFamily.set(i, r), n.push(...o.fonts) } return n } isValidCustomFontAsset(e) { var t; return !e.mimeType.startsWith("font/") || ((t = e.properties) == null ? void 0 : t.kind) !== "font" || !e.properties.font ? !1 : "fontFamily" in e.properties.font } inferVariantName(e) { let t = ["thin", "ultra light", "extra light", "light", "normal", "medium", "semi bold", "bold", "extra bold", "black"], n = [...t.map(s => `${s} italic`), ...t], r = e.toLowerCase(), i = [...r.split(" "), ...r.split("-"), ...r.split("_")], o = n.find(s => i.includes(s) || i.includes(s.replace(/\s+/g, ""))); return o ? o.replace(/^\w|\s\w/g, s => s.toUpperCase()) : "Regular" } createFontFamily(e) { let t = this.byFamilyName.get(e); if (t) return t; let n = { source: this.name, name: e, fonts: [] }; return this.addFontFamily(n), n } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } parseSelector(e) { if (!e.startsWith(Oo)) return null; let t = e.split(Oo); return t[1] === void 0 ? null : { source: "custom", name: t[1] } } getFontBySelector(e, t = !0) { let n = this.parseSelector(e); if (!n || !t && !this.byFamilyName.get(n.name)) return; let r = this.getFontFamilyByName(n.name).fonts; return r.find(o => { var s; return (s = o.file) == null ? void 0 : s.endsWith(".woff2") }) || r[0] } getFontFamilyByName(e) { let t = this.byFamilyName.get(e); if (t) return t; let n = { source: "custom", name: e, fonts: [] }; return n.fonts.push({ selector: `${Oo}${e}`, variant: this.inferVariantName(e), family: n }), n } }; function Sk(e, t, n) { if (t.length === 0) return {}; let r = n(e); if (!r) return {}; let { weight: i, style: o } = r, s = new Map, a = new Map; t.forEach(f => { let d = Ce(f) ? f : f.name.toLocaleLowerCase(), p = n(d); p && (s.set(`${p.weight}-${p.style}`, d), !(p.weight <= i) && (a.has(p.style) || a.set(p.style, d))) }); let l = a.get(o), c = a.get("italic") ?? a.get("oblique"); r.weight <= 300 ? (l = s.get(`400-${o}`) ?? l, c = s.get("400-italic") ?? s.get("400-oblique") ?? c) : r.weight <= 500 ? (l = s.get(`700-${o}`) ?? l, c = s.get("700-italic") ?? s.get("700-oblique") ?? c) : (l = s.get(`900-${o}`) ?? l, c = s.get("900-italic") ?? s.get("900-oblique") ?? c); let u = s.get(`${i}-italic`) ?? s.get(`${i}-oblique`); return { variantBold: l, variantItalic: u, variantBoldItalic: c } } var B5 = ["display", "sans", "serif", "slab", "handwritten", "script"]; function $5(e) { return e.split(",").map(t => t.trim().toLowerCase()).filter(z5) } function z5(e) { return B5.includes(e) } var Zc = "FS;", wk = { thin: 100, hairline: 100, extralight: 200, light: 300, regular: 400, medium: 500, semibold: 600, bold: 700, extrabold: 800, ultra: 800, black: 900, heavy: 900 }, kk = Object.keys(wk), N5 = (() => new RegExp(`^(?:${[...kk, "italic"].join("|")})`, "u"))(), Gr = class { constructor() { R(this, "name", "fontshare"), R(this, "fontFamilies", []), R(this, "byFamilyName", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } static parseVariant(e) { let t = e.split(" "), n = kk.find(s => t.includes(s)), r = e.includes("italic") ? "italic" : "normal"; return { weight: n && wk[n] || 400, style: r === "italic" ? r : "normal" } } parseSelector(e) { if (!e.startsWith(Zc)) return null; let t = e.split("-"); if (t.length !== 2) return null; let [n, r] = t; return !n || !r ? null : { name: n.replace(Zc, ""), variant: r, source: this.name } } static createSelector(e, t) { return `${Zc}${e}-${t}` } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let t = []; for (let n of e) { let r = n.font_styles.filter(i => { let o = i.name.toLowerCase(); return !(!N5.exec(o) || o.endsWith("wide")) }); for (let i of r) { let { name: o } = n, s = i.name.toLowerCase(), a = this.getFontFamilyByName(o); a || (a = { name: o, fonts: [], source: this.name }, this.addFontFamily(a)); let l = Gr.createSelector(o, s), c = Gr.parseVariant(s) || { weight: void 0, style: void 0 }, { weight: u, style: f } = c, { variantBold: d, variantBoldItalic: p, variantItalic: g } = Sk(s, r, Gr.parseVariant), v = { family: a, variant: s, selector: l, selectorBold: d ? Gr.createSelector(o, d) : void 0, selectorBoldItalic: p ? Gr.createSelector(o, p) : void 0, selectorItalic: g ? Gr.createSelector(o, g) : void 0, weight: u, style: f, file: i.file, category: H5(n.category) }; a.fonts.push(v), t.push(v) } } return t } }; function H5(e) { let t = { serif: "serif", sans: "sans-serif", slab: "slab", display: "display", handwritten: "handwriting", script: "handwriting" }, n = $5(e)[0]; return n && t[n] } var j5 = "Inter", W5 = { Thin: 100, ExtraLight: 200, Light: 300, "": 400, Medium: 500, SemiBold: 600, Bold: 700, ExtraBold: 800, Black: 900 }, DS = class { constructor() { R(this, "name", "framer"), R(this, "fontFamilies", []), R(this, "byFamilyName", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } addFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.fontFamilies.push(t), this.byFamilyName.set(t.name, t), t } static getDraftFontPropertiesBySelector(e) { if (!e.startsWith(j5)) return null; let t = e.split("-"), [n, r = ""] = t; if (!n) return null; let i = r.includes("Italic") ? "italic" : "normal", o = r.replace("Italic", ""), s = o && W5[o] || 400; return { family: n, style: i, weight: s, source: "framer", variant: void 0, category: "sans-serif" } } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let t = []; return e.forEach(n => { let { familyName: r, ...i } = n, o = this.getFontFamilyByName(r); o || (o = this.addFontFamily(r)); let s = { ...i, family: o }; o.fonts.push(s), t.push(s) }), t } }, Jc = "GF;", Kr = class { constructor() { R(this, "name", "google"), R(this, "fontFamilies", []), R(this, "byFamilyName", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } static parseVariant(e) { if (e === "regular") return { style: "normal", weight: 400 }; let t = /(\d*)(normal|italic)?/.exec(e); if (!t) return null; let n = parseInt(t[1] || "400"), r = t[2] === "italic" ? "italic" : "normal"; return { weight: n, style: r } } parseSelector(e) { if (!e.startsWith(Jc)) return null; let t = e.split("-"); if (t.length !== 2) return null; let [n, r] = t; return !n || !r ? null : { name: n.replace(Jc, ""), variant: r, source: this.name } } static createSelector(e, t) { return `${Jc}${e}-${t}` } addFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.fontFamilies.push(t), this.byFamilyName.set(t.name, t), t } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let t = []; return e.forEach(n => { n.variants.forEach(r => { var i; let o = n.family, s = this.getFontFamilyByName(o); s || (s = this.addFontFamily(o)); let a = Kr.parseVariant(r) ?? {}, { weight: l, style: c } = a, u = Kr.createSelector(o, r), { variantBold: f, variantItalic: d, variantBoldItalic: p } = Sk(r, n.variants, Kr.parseVariant), g = { family: s, variant: r, selector: u, selectorBold: f ? Kr.createSelector(o, f) : void 0, selectorBoldItalic: p ? Kr.createSelector(o, p) : void 0, selectorItalic: d ? Kr.createSelector(o, d) : void 0, weight: l, style: c, category: U5(n.category), file: (i = n.files[r]) == null ? void 0 : i.replace("http://", "https://") }; s.fonts.push(g), t.push(g) }) }), t } }; function U5(e) { let t = { serif: "serif", "sans-serif": "sans-serif", display: "display", handwriting: "handwriting", monospace: "monospace" }; if (e) return t[e] } var X5 = Dn(rI(), 1), AS = 5e3, Y5 = 3, Ck = class extends Error { constructor(e) { super(e), this.name = "FontLoadingError" } }, Np = new Map, Hp = new Map, G5 = (e, t) => Tk(e, t); async function Tk(e, t, n = 0) { let { family: r, url: i, stretch: o, unicodeRange: s } = e, a = e.weight || 500, l = e.style || "normal", c = `${r}-${l}-${a}-${i}`; if (!Np.has(c) || n > 0) { let u = new FontFace(r, `url(${i})`, { weight: Ce(a) ? a : a?.toString(), style: l, stretch: o, unicodeRange: s }), f = u.load().then(() => (t.fonts.add(u), Ek(r, l, a))).catch(d => { if (d.name !== "NetworkError") throw d; if (n < Y5) return Tk(e, t, n + 1); throw new Ck(`Font loading failed after ${n} retries due to network error: ${JSON.stringify({ family: r, style: l, weight: a, url: i, stretch: o, unicodeRange: s })}`) }); Np.set(c, f) } await Np.get(c) } async function Ek(e, t, n) { let r = `${e}-${t}-${n}`; if (!Hp.has(r)) { let o = new X5.default(e, { style: t, weight: n }).load(null, AS); Hp.set(r, o) } try { await Hp.get(r) } catch { throw new Ck(`Failed to check if font is ready (${AS}ms timeout exceeded): ${JSON.stringify({ family: e, style: t, weight: n })}`) } } var K5 = class { constructor() { R(this, "enabled", !1), R(this, "bySelector", new Map), R(this, "getGoogleFontsListPromise"), R(this, "getFontshareFontsListPromise"), R(this, "loadedSelectors", new Set), R(this, "googleFamilyNames", new Set), R(this, "local"), R(this, "google"), R(this, "fontshare"), R(this, "framer"), R(this, "custom"), this.local = new M5, this.google = new Kr, this.fontshare = new Gr, this.framer = new DS, this.custom = new V5, this.bySelector = new Map, this.importLocalFonts() } addFont(e) { this.bySelector.set(e.selector, e) } getAvailableFonts() { return Array.from(this.bySelector.values()) } importLocalFonts() { for (let e of this.local.importFonts()) this.addFont(e), this.loadFont(e) } async importGoogleFonts() { if (!this.getGoogleFontsListPromise) { this.getGoogleFontsListPromise = Je.fetchGoogleFontsList(); let e = await this.getGoogleFontsListPromise; for (let t of this.google.importFonts(e)) this.googleFamilyNames.add(t.family.name.toLowerCase()), this.addFont(t) } return this.getGoogleFontsListPromise } async importFontshareFonts() { if (!this.getFontshareFontsListPromise) { this.getFontshareFontsListPromise = Je.fetchFontshareFontsList(); let e = await this.getFontshareFontsListPromise; for (let t of this.fontshare.importFonts(e)) this.googleFamilyNames.has(t.family.name.toLowerCase()) || this.addFont(t) } return this.getFontshareFontsListPromise } importFramerFonts(e) { this.framer.importFonts(e).forEach(t => { this.addFont(t) }) } importCustomFonts(e) { this.bySelector.forEach((t, n) => { n.startsWith(Oo) && this.bySelector.delete(n) }); for (let t of this.custom.importFonts(e)) this.addFont(t) } getFontFamily(e) { return this[e.source].getFontFamilyByName(e.name) } getFontBySelector(e, t = !0) { return e.startsWith(Oo) ? this.custom.getFontBySelector(e, t) : this.bySelector.get(e) } getDraftPropertiesBySelector(e) { let t = this.getFontBySelector(e); if (t) return { style: t.style, weight: t.weight, variant: t.variant, family: t.family.name, source: t.family.source, category: t.category }; let n = this.google.parseSelector(e); if (n) { let o = Kr.parseVariant(n.variant); if (o) return { style: o.style, weight: o.weight, variant: n.variant, family: n.name, source: "google", category: void 0 } } let r = this.fontshare.parseSelector(e); if (r) { let o = Gr.parseVariant(r.variant); if (o) return { style: o.style, weight: o.weight, variant: r.variant, family: r.name, source: "fontshare", category: void 0 } } let i = DS.getDraftFontPropertiesBySelector(e); return i || null } isSelectorLoaded(e) { return this.loadedSelectors.has(e) } async loadFont(e) { if (this.isSelectorLoaded(e.selector)) return 0; let t = e.family.source; switch (t) { case "local": return this.loadedSelectors.add(e.selector), 1; case "framer": return D5.default.env.NODE_ENV !== "test" && await Ek(e.family.name, e.style, e.weight), this.loadedSelectors.add(e.selector), 1; case "google": case "fontshare": case "custom": return e.file ? (await G5({ family: e.family.name, url: e.file, weight: e.weight, style: e.style }, document), this.loadedSelectors.add(e.selector), 1) : Promise.reject(`Unable to load font: ${e.selector}`); default: We(t) } } async loadFontsFromSelectors(e) { if (!this.enabled) return []; let t = e.some(i => i.startsWith(Jc)), n = e.some(i => i.startsWith(Zc)); if (t || n) { try { await this.importGoogleFonts() } catch (i) { da("Failed to load Google fonts:", i) } try { await this.importFontshareFonts() } catch (i) { da("Failed to load Fontshare fonts:", i) } } let r = e.map(i => this.bySelector.get(i)).filter(i => !!i); return Promise.allSettled(r.map(i => this.loadFont(i))) } async loadFonts(e) { return { newlyLoadedFontCount: (await this.loadFontsFromSelectors(e)).filter(r => r.status === "fulfilled" && r.value === 1).length } } async loadMissingFonts(e, t) { let n = e.filter(i => !eu.isSelectorLoaded(i)); if (n.length === 0) return; await eu.loadWebFontsFromSelectors(n), n.every(i => eu.isSelectorLoaded(i)) && t && t() } async loadWebFontsFromSelectors(e) { return this.loadFontsFromSelectors(e) } get defaultFont() { let e = this.getFontBySelector("Inter"); return de(e, "Can\u2019t find Inter font"), e } }, eu = new K5; Promise.allSettled = Promise.allSettled || (e => Promise.all(e.map(t => t.then(n => ({ status: "fulfilled", value: n })).catch(n => ({ status: "rejected", reason: n }))))); var Rk = (e => (e.Padding = "--framer-input-padding", e.BorderRadiusTopLeft = "--framer-input-border-radius-top-left", e.BorderRadiusTopRight = "--framer-input-border-radius-top-right", e.BorderRadiusBottomRight = "--framer-input-border-radius-bottom-right", e.BorderRadiusBottomLeft = "--framer-input-border-radius-bottom-left", e.BorderColor = "--framer-input-border-color", e.BorderTopWidth = "--framer-input-border-top-width", e.BorderRightWidth = "--framer-input-border-right-width", e.BorderBottomWidth = "--framer-input-border-bottom-width", e.BorderLeftWidth = "--framer-input-border-left-width", e.BorderStyle = "--framer-input-border-style", e.Background = "--framer-input-background", e.FontFamily = "--framer-input-font-family", e.FontWeight = "--framer-input-font-weight", e.FontSize = "--framer-input-font-size", e.FontColor = "--framer-input-font-color", e.FontLetterSpacing = "--framer-input-font-letter-spacing", e.FontTextAlignment = "--framer-input-font-text-alignment", e.FontLineHeight = "--framer-input-font-line-height", e.PlaceholderColor = "--framer-input-placeholder-color", e.BoxShadow = "--framer-input-box-shadow", e.FocusedBorderColor = "--framer-input-focused-border-color", e.FocusedBorderWidth = "--framer-input-focused-border-width", e.FocusedBorderStyle = "--framer-input-focused-border-style", e.FocusedBackground = "--framer-input-focused-background", e.FocusedBoxShadow = "--framer-input-focused-box-shadow", e.FocusedTransition = "--framer-input-focused-transition", e.BooleanCheckedIconURL = "--framer-input-boolean-icon", e.BooleanCheckedBackground = "--framer-input-boolean-checked-background", e.BooleanCheckedBorderColor = "--framer-input-boolean-checked-border-color", e.BooleanCheckedBorderWidth = "--framer-input-boolean-checked-border-width", e.BooleanCheckedBorderStyle = "--framer-input-boolean-checked-border-style", e.BooleanCheckedBoxShadow = "--framer-input-boolean-checked-box-shadow", e.BooleanCheckedTransition = "--framer-input-boolean-checked-transition", e.InvalidTextColor = "--framer-input-invalid-text-color", e))(Rk || {}), be = Rk, q5 = (() => "framer-form-input")(), VS = (() => "framer-form-input-wrapper")(); function Q5(e) { return typeof e == "number" ? e : e.startsWith("--") ? Ge.variable(e) : e === "" ? '""' : e } function Ge(e, t) { let n = " "; for (let r in t) n += `${r.replace(/([A-Z])/gu, "-$1").toLowerCase()}: ${Q5(t[r])}; `; return e + " {" + n + "}" } (e => { function t(...n) { let r = n[n.length - 1], i = r.startsWith("--") ? `var(${r})` : r; for (let o = n.length - 2; o >= 0; o--)i = `var(${n[o]}, ${i})`; return i } e.variable = t })(Ge || (Ge = {})); var $8 = [Ge(`.${q5}`, { padding: Ge.variable(be.Padding), background: Ge.variable(be.Background), fontFamily: Ge.variable(be.FontFamily), fontWeight: Ge.variable(be.FontWeight), fontSize: Ge.variable(be.FontSize), color: Ge.variable(be.FontColor), boxShadow: Ge.variable(be.BoxShadow), border: "none", textOverflow: "ellipsis", whiteSpace: "nowrap", overflow: "hidden", width: "100%", height: "100%", borderTopLeftRadius: Ge.variable(be.BorderRadiusTopLeft), borderTopRightRadius: Ge.variable(be.BorderRadiusTopRight), borderBottomRightRadius: Ge.variable(be.BorderRadiusBottomRight), borderBottomLeftRadius: Ge.variable(be.BorderRadiusBottomLeft), letterSpacing: Ge.variable(be.FontLetterSpacing), textAlign: Ge.variable(be.FontTextAlignment), lineHeight: Ge.variable(be.FontLineHeight), transition: Ge.variable(be.FocusedTransition), transitionProperty: "background, box-shadow", flex: "0 0 auto" })]; var z8 = [`.${VS} {
        position: relative;
    }`, `.${VS}:after {
        content: "";
        pointer-events: none;
        box-sizing: border-box;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-top-left-radius: var(${be.BorderRadiusTopLeft});
        border-top-right-radius: var(${be.BorderRadiusTopRight});
        border-bottom-right-radius: var(${be.BorderRadiusBottomRight});
        border-bottom-left-radius: var(${be.BorderRadiusBottomLeft});
        border-color: var(${be.BorderColor});
        border-top-width: var(${be.BorderTopWidth});
        border-right-width: var(${be.BorderRightWidth});
        border-bottom-width: var(${be.BorderBottomWidth});
        border-left-width: var(${be.BorderLeftWidth});
        border-style: var(${be.BorderStyle});
        transition: var(${be.FocusedTransition});
        transition-property: border-color, border-width, border-style, border-top-left-radius, border-top-right-radius, border-bottom-right-radius, border-bottom-left-radius;
    }`]; var G8 = b.forwardRef(function (t, n) { let { background: r, children: i, alt: o, ...s } = t, a = { ...s.style }; r && delete a.background; let l = pu(t.as); return ae(l, { ...s, style: a, ref: n, children: [r && C(Ew, { image: r, alt: o }), i] }) }); function Z5(e, t) { return e.length === t.length && e.every((n, r) => n === t[r]) } var J5 = /[&<>'"]/g, e4 = e => e.replace(J5, t => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" })[t] || t), t4 = /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi; function n4(e, t, n, r) { return e.replace(t4, (i, o, s, a, l, c, u) => { var f, d; if (s.toLowerCase() !== "a") return i; let p = l || c, g = gm(p.replace(/&amp;/g, "&")); if (!g || !g.target) return i; let v = t(g.target); if (!A1(v) || !A1(n)) return i; let S = v.path, m = n.path; if (!S || !m) return i; let h = ` data-framer-page-link-target="${g.target}"`, y = tm(v, g.element ?? void 0); y && (h += ` data-framer-page-link-element="${g.element}"`); let x = lu(p); if (!x || Ce(x)) return i; uk(n, x, r) && (h += " data-framer-page-link-current"); let k = S, w = Object.assign({}, r, (f = g.collectionItem) == null ? void 0 : f.pathVariables); if (Object.keys(w).length > 0 && (k = k.replace(lk, (T, E) => "" + w[E])), (d = g.collectionItem) != null && d.pathVariables) { let T = new URLSearchParams(g.collectionItem.pathVariables); h += ` data-framer-page-link-path-variables="${T}"` } return k = GS(m, k), o + a + `"${e4(k + (y ? `#${y}` : ""))}"` + h + u }) } var r4 = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Pk = /[&<>"']/gu, i4 = (() => new RegExp(Pk.source))(); function BS(e) { return e && i4.test(e) ? e.replace(Pk, t => r4[t] ?? "") : e || "" } var $S = "{{ text-placeholder }}", o4 = "rich-text-wrapper", s4 = Ne(function (t, n) { let { id: r, name: i, html: o, htmlFromDesign: s, text: a, textFromDesign: l, fonts: c = [], width: u, height: f, left: d, right: p, top: g, bottom: v, center: S, className: m, stylesPresetsClassName: h, visible: y = !0, opacity: x, rotation: k = 0, verticalAlignment: w = "top", isEditable: T = !1, willChangeTransform: E, environment: I = oe.current, withExternalLayout: F = !1, positionSticky: B, positionStickyTop: V, positionStickyRight: K, positionStickyBottom: Z, positionStickyLeft: j, __htmlStructure: ne, __fromCanvasComponent: U = !1, _forwardedOverrideId: X, _forwardedOverrides: z, _usesDOMRect: J, children: ie, ...se } = t, te = Ra(), re = _a(t), Qt = D(null), fe = n ?? Qt, { navigate: Pt, getRoute: ee } = Ta(), Zt = hu(); sL(t.preload ?? []), gu(t, fe); let hn = O(jo), Kn = Tu(), Mi = a, pn = X ?? r; if (pn && z) { let ze = z[pn]; typeof ze == "string" && (Mi = ze) } let Bt = ""; if (Mi) { let ze = BS(Mi); Bt = ne ? ne.replace($S, ze) : `<p>${ze}</p>` } else if (o) Bt = o; else if (l) { let ze = BS(l); Bt = ne ? ne.replace($S, ze) : `<p>${ze}</p>` } else s && (Bt = s); let qn = ck(), Eu = he(() => Kn || !ee || !Zt ? Bt : n4(Bt, ee, Zt, qn), [Kn, Bt, ee, Zt, qn]); if (H(() => { let ze = fe.current; if (ze === null) return; function Qn($t) { let Jr = vm($t.target, fe.current); if ($t.metaKey || !Pt || !Jr || Jr.getAttribute("target") === "_blank") return; MV(Pt, Jr, qn) && $t.preventDefault() } return ze.addEventListener("click", Qn), () => { ze.removeEventListener("click", Qn) } }, [Pt, qn]), Fk(c, U, fe), ct(() => { Pa() }, []), !y) return null; let P = T && I() === oe.canvas, _ = { outline: "none", display: "flex", flexDirection: "column", justifyContent: _k(w), opacity: P ? 0 : x, flexShrink: 0 }, M = oe.hasRestrictions(), N = ha(t, te || 0, !1), le = J && (u === "auto" || f === "auto"), et = !!t.transformTemplate || !N || !M || U || le ? t.transformTemplate ?? mu(S) : void 0; if (!F) { if (N && M && !le) { let ze = Ke.getNumber(k).toFixed(4); _.transform = `translate(${N.x}px, ${N.y}px) rotate(${ze}deg)`, _.width = N.width, _.minWidth = N.width, _.height = N.height } else _.left = d, _.right = p, _.top = g, _.bottom = v, _.width = u, _.height = f, _.rotate = k; B ? (!Kn || hn) && (_.position = "sticky", _.willChange = "transform", _.zIndex = 1, _.top = V, _.right = K, _.bottom = Z, _.left = j) : Kn && (t.positionFixed || t.positionAbsolute) && (_.position = "absolute") } return hm(t, _), Nw(t, _), E && um(_), Object.assign(_, t.style), C(Nt.div, { id: r, ref: fe, ...se, style: _, layoutId: re, "data-framer-name": i, "data-framer-component-type": "DeprecatedRichText", "data-center": S, className: pm(m, h, o4), transformTemplate: et, dangerouslySetInnerHTML: { __html: Eu } }) }); function _k(e) { switch (e) { case "top": return "flex-start"; case "center": return "center"; case "bottom": return "flex-end" } } function Fk(e, t, n) { let r = D([]); Z5(r.current, e) || (r.current = e, eu.loadFonts(e).then(({ newlyLoadedFontCount: i }) => { !t || !n.current || oe.current() !== oe.canvas || i > 0 && LO(n.current) })) } var zS = Ne(({ viewBoxScale: e, viewBox: t, children: n, ...r }, i) => C(Nt.svg, { ref: i, ...r, viewBox: t, children: C(Nt.foreignObject, { width: "100%", height: "100%", className: "framer-fit-text", transform: `scale(${e})`, style: { overflow: "visible", transformOrigin: "center center" }, children: n }) })), a4 = Ne((e, t) => { let { __fromCanvasComponent: n = !1, _forwardedOverrideId: r, _forwardedOverrides: i, _usesDOMRect: o, as: s, bottom: a, center: l, children: c, environment: u = oe.current, fonts: f = [], height: d, isEditable: p = !1, left: g, name: v, opacity: S, positionSticky: m, positionStickyBottom: h, positionStickyLeft: y, positionStickyRight: x, positionStickyTop: k, right: w, rotation: T = 0, style: E, _initialStyle: I, stylesPresetsClassNames: F, text: B, top: V, verticalAlignment: K = "top", visible: Z = !0, width: j, willChangeTransform: ne, withExternalLayout: U = !1, viewBox: X, viewBoxScale: z = 1, ...J } = e, ie = Ra(), se = Tu(), te = O(jo), re = _a(e), Qt = D(null), fe = t ?? Qt; if (gu(e, fe), Fk(f, n, fe), ct(() => { Pa() }, []), !Z) return null; let Pt = p && u() === oe.canvas, ee = { outline: "none", display: "flex", flexDirection: "column", justifyContent: _k(K), opacity: Pt ? 0 : S, flexShrink: 0 }, Zt = oe.hasRestrictions(), hn = ha(e, ie || 0, !1), Kn = o && (j === "auto" || d === "auto"), pn = !!e.transformTemplate || !hn || !Zt || n || Kn ? e.transformTemplate ?? mu(l) : void 0; U || (hn && Zt && !Kn ? (ee.x = hn.x, ee.y = hn.y, ee.rotate = Ke.getNumber(T), ee.width = hn.width, ee.minWidth = hn.width, ee.height = hn.height) : (ee.left = g, ee.right = w, ee.top = V, ee.bottom = a, ee.width = j, ee.height = d, ee.rotate = T), m ? (!se || te) && (ee.position = "sticky", ee.willChange = "transform", ee.zIndex = 1, ee.top = k, ee.right = x, ee.bottom = h, ee.left = y) : se && (e.positionFixed || e.positionAbsolute) && (ee.position = "absolute")), hm(e, ee), Nw(e, ee), ne && um(ee), Object.assign(ee, I, E), re && (J.layout = "preserve-aspect"); let Bt = pu(e.as); return Ce(e.viewBox) ? e.as !== void 0 ? C(Bt, { ...J, ref: fe, style: ee, layoutId: re, transformTemplate: pn, "data-framer-name": v, "data-framer-component-type": "RichTextContainer", children: C(zS, { viewBox: X, viewBoxScale: z, style: { width: "100%", height: "100%" }, children: c && tu(c, F, B) }) }) : C(zS, { ...J, ref: fe, style: ee, layoutId: re, viewBox: X, viewBoxScale: z, transformTemplate: pn, "data-framer-name": v, "data-framer-component-type": "RichTextContainer", children: c && tu(c, F, B) }) : C(Bt, { ...J, ref: fe, style: ee, layoutId: re, transformTemplate: pn, "data-framer-name": v, "data-framer-component-type": "RichTextContainer", children: c && tu(c, F, B) }) }); function tu(e, t, n) { let r = Rn.toArray(e.props.children); Ce(n) && (r = r.slice(0, 1)), r = r.map(s => en(s) ? tu(s, t, n) : Ce(n) ? n : s); let { ["data-preset-tag"]: i, ...o } = e.props; if (Ce(e.type) || ld(e.type)) { let s = i || n0(e.type) || e.type, a = Ce(s) ? t?.[s] : void 0; o.className = pm("framer-text", o.className, a) } return mn(e, o, ...r) } var J8 = Ne(({ children: e, html: t, htmlFromDesign: n, ...r }, i) => { let o = t || e || n; if (Ce(o)) { !r.stylesPresetsClassName && ke(r.stylesPresetsClassNames) && (r.stylesPresetsClassName = Object.values(r.stylesPresetsClassNames).join(" ")); let s = { [Ce(t) ? "html" : "htmlFromDesign"]: o }; return C(s4, { ...r, ...s, ref: i }) } if (!r.stylesPresetsClassNames && Ce(r.stylesPresetsClassName)) { let [s, a, l, c, u] = r.stylesPresetsClassName.split(" "); s === void 0 || a === void 0 || l === void 0 || c === void 0 || u === void 0 ? console.warn(`Encountered invalid stylesPresetsClassNames: ${r.stylesPresetsClassNames}`) : r.stylesPresetsClassNames = { h1: s, h2: a, h3: l, p: c, a: u } } return C(a4, { ...r, ref: i, children: en(o) ? o : void 0 }) }); function l4(e) { var t, n; let r = e * Math.PI / 180, i = { x: -Math.sin(r) * 100, y: Math.cos(r) * 100 }, o = yt(i.x, i.y), s = st(yt(.5, .5), o), a = $.points({ x: 0, y: 0, width: 1, height: 1 }), l = a.map(v => ({ point: v, distance: yt.distance(o, v) })).sort((v, S) => v.distance - S.distance), c = (t = l[0]) == null ? void 0 : t.point, u = (n = l[1]) == null ? void 0 : n.point; de(c && u, "linearGradientLine: Must have 2 closest points."); let [f, d] = a.filter(v => !yt.isEqual(v, c) && !yt.isEqual(v, u)); de(f && d, "linearGradientLine: Must have 2 opposing points."); let p = st.intersection(s, st(c, u)), g = st.intersection(s, st(f, d)); return de(p && g, "linearGradientLine: Must have a start and end point."), st(p, g) } function c4(e, t) { var n, r; let i = l4(e.angle), o = Fa(e), s = ((n = o[0]) == null ? void 0 : n.position) ?? 0, a = ((r = o[o.length - 1]) == null ? void 0 : r.position) ?? 1, l = st.pointAtPercentDistance(i, s), c = st.pointAtPercentDistance(i, a), u = Ki([s, a], [0, 1]); return { id: `id${t}g${ma.hash(e)}`, x1: l.x, y1: l.y, x2: c.x, y2: c.y, stops: o.map(f => ({ color: f.value, alpha: fm.getAlpha(f.value) * e.alpha, position: u(f.position) })) } } function u4(e, t) { return { id: `id${t}g${va.hash(e)}`, widthFactor: e.widthFactor, heightFactor: e.heightFactor, centerAnchorX: e.centerAnchorX, centerAnchorY: e.centerAnchorY, stops: Fa(e).map(n => ({ color: n.value, alpha: fm.getAlpha(n.value) * e.alpha, position: n.position })) } } function Ik(e) { if (!Ce(e) || e.charAt(e.length - 1) !== "%") return !1; let n = e.slice(0, -1), r = parseFloat(n); return En(r) } function Lk(e) { let t = e.slice(0, -1), n = parseFloat(t); return En(n) ? n : 50 } function NS(e) { return Ik(e) ? Lk(e) / 100 : e === "left" ? 0 : e === "right" ? 1 : .5 } function HS(e) { return Ik(e) ? Lk(e) / 100 : e === "top" ? 0 : e === "bottom" ? 1 : .5 } function f4(e, t, n, r) { if (e = Ke.get(e, "#09F"), !Ei.isImageObject(e) || !e.pixelWidth || !e.pixelHeight) return; let i = e.pixelWidth, o = e.pixelHeight, s, { fit: a } = e, l = 1, c = 1, u = 0, f = 0; if (a === "fill" || a === "fit" || a === "tile" || !a) { let p = 1, g = 1, v = i / o, S = t.height * v, m = t.width / v, h = S / t.width, y = m / t.height; if (a === "tile") { e.backgroundSize ?? (e.backgroundSize = 1), l = Math.round(e.backgroundSize * (i / 2)), c = Math.round(e.backgroundSize * (o / 2)); let x = t.x ?? 0, k = t.y ?? 0, w = 0, T = 0; r && (w = x, T = k), u = (t.width - l) * NS(e.positionX) + w, f = (t.height - c) * HS(e.positionY) + T, s = `translate(${u + x}, ${f + k})` } else (a === "fill" || !a ? y > h : y < h) ? (g = y, f = (1 - y) * HS(e.positionY)) : (p = h, u = (1 - h) * NS(e.positionX)), s = `translate(${u}, ${f}) scale(${p}, ${g})` } return { id: `id${n}g-fillImage`, path: e.src ?? "", transform: s, width: l, height: c, offsetX: u, offsetY: f } } var d4 = "framer/asset-reference,"; function h4(e) { return e.startsWith(`data:${d4}`) } function p4(e, t) { if (/^\w+:/.test(e) && !h4(e)) return e; typeof t != "number" ? t = void 0 : t <= 512 ? t = 512 : t <= 1024 ? t = 1024 : t <= 2048 ? t = 2048 : t = 4096; let n = oe.current() === oe.export; return Je.assetResolver(e, { pixelSize: t, isExport: n }) ?? "" } var m4 = ({ id: e, path: t, transform: n, repeat: r, width: i, height: o, offsetX: s, offsetY: a }) => { let l = p4(t); return C("pattern", { id: e, width: r ? i : "100%", height: r ? o : "100%", patternContentUnits: r ? void 0 : "objectBoundingBox", patternUnits: r ? "userSpaceOnUse" : void 0, x: r ? s : void 0, y: r ? a : void 0, children: C("image", { width: r ? i : 1, height: r ? o : 1, href: l, preserveAspectRatio: "none", transform: r ? void 0 : n, x: r ? 0 : void 0, y: r ? 0 : void 0 }, l) }) }, jS = mr(), v4 = class { constructor(e, t, n, r, i = 0) { this.id = e, this.svg = t, this.innerHTML = n, this.viewBox = r, this.count = i } }, g4 = class {
    constructor() { R(this, "entries", new Map) } debugGetEntries() { return this.entries } subscribe(e, t, n) { if (!e || e === "") return ""; let r = this.entries.get(e); if (!r) { n || (n = "svg" + String(Ow(e)) + "_" + String(e.length)); let i = e, o, s = y4(e); s && (t && b4(s, n), s.id = n, o = k4(s), i = s.outerHTML), r = this.createDOMElementFor(i, n, o), this.entries.set(e, r) } return r.count += 1, r.innerHTML } getViewBox(e) { if (!e || e === "") return; let t = this.entries.get(e); return t?.viewBox } unsubscribe(e) { if (!e || e === "") return; let t = this.entries.get(e); t && (t.count -= 1, !(t.count > 0) && setTimeout(() => this.maybeRemoveEntry(e), 5e3)) } maybeRemoveEntry(e) { let t = this.entries.get(e); t && (t.count > 0 || (this.entries.delete(e), this.removeDOMElement(t))) } removeDOMElement(e) { let t = "container_" + e.id; if (jS) { let n = document?.querySelector("#" + t); n?.remove() } } createDOMElementFor(e, t, n) { let r = "container_" + t; if (jS) { let a = document.querySelector("#svg-templates"); if (a || (a = document.createElement("div"), a.id = "svg-templates", a.style.position = "absolute", a.style.top = "0", a.style.left = "0", a.style.width = "0", a.style.height = "0", a.style.overflow = "hidden", document.body.appendChild(a)), !document.querySelector("#" + r)) { let l = document.createElement("div"); l.id = r, l.innerHTML = e, l.firstElementChild && (l.firstElementChild.id = t), a.appendChild(l) } } let i = n ? `0 0 ${n.width} ${n.height}` : void 0, s = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="width: 100%; height: 100%"${i ? ` viewBox="${i}"` : ""}><use href="#${t}"></use></svg>`; return new v4(t, e, s, i) } clear() { this.entries.clear() } generateTemplates() {
        let e = [], t = "position: absolute; overflow: hidden; top: 0; left: 0; width: 0; height: 0"; e.push(`<div id="svg-templates" style="${t}">`); for (let n of this.entries.values()) { let r = "container_" + n.id; e.push(`  <div id="${r}">`), e.push(`    ${n.svg}`), e.push("  </div>") } return e.push("</div>"), e.join(`
`)
    }
}, Lo = new g4; function y4(e) { if (typeof DOMParser > "u") { console.warn("unable to find DOMParser"); return } try { let r = new DOMParser().parseFromString(e, "text/html").getElementsByTagName("svg")[0]; if (!r) throw Error("no svg element found"); return r } catch { return } } function b4(e, t) { let n = x4(t); Mk(e, n) } function x4(e) { return e.replace(/[^\w\-:.]|^[^a-z]+/gi, "") } function Mk(e, t) { S4(e, t), Array.from(e.children).forEach(r => { Mk(r, t) }) } function S4(e, t) { e.getAttributeNames().forEach(r => { let i = e.getAttribute(r); if (!i) return; if (r === "id" && e.setAttribute(r, `${t}_${i}`), r === "href" || r === "xlink:href") { let [s, a] = i.split("#"); if (s) return; e.setAttribute(r, `#${t}_${a}`); return } let o = "url(#"; if (i.includes(o)) { let s = i.replace(o, `${o}${t}_`); e.setAttribute(r, s) } }) } var w4 = (() => ({ cm: 96 / 2.54, mm: 96 / 2.54 / 10, Q: 96 / 2.54 / 40, in: 96, pc: 96 / 6, pt: 96 / 72, px: 1, em: 16, ex: 8, ch: 8, rem: 16 }))(); function WS(e) { var t; if (!e) return; let n = /(-?[\d.]+)([a-z%]*)/u.exec(e); if (!(n?.[1] === void 0 || n?.[2] === void 0) && !((t = n[2]) != null && t.startsWith("%"))) return Math.round(parseFloat(n[1]) * (w4[n[2]] || 1)) } function k4(e) { let t = WS(e.getAttribute("width")), n = WS(e.getAttribute("height")); if (!(typeof t != "number" || typeof n != "number") && !(t <= 0 || n <= 0)) return { width: t, height: n } } function rH(e) { let t = Ra(), n = _a(e), r = b.useRef(null), i = _5(); return gu(e, r), C(_4, { ...e, innerRef: r, parentSize: t, layoutId: n, providedWindow: i }) } var C4 = 5e4; function T4(e) { return e.indexOf("image") >= 0 } function E4(e) { return e.indexOf("var(--") >= 0 } function R4(e) { return !!(e.borderRadius || e.borderBottomLeftRadius || e.borderBottomRightRadius || e.borderTopLeftRadius || e.borderTopRightRadius) } function US(e, t) { var n, r; let i = e.current; if (!i) return; let o = t.providedWindow ?? Ve, s = i.firstElementChild; if (!s || !(s instanceof o.SVGSVGElement)) return; if (!s.getAttribute("viewBox")) { let p = Lo.getViewBox(t.svg); p && s.setAttribute("viewBox", p) } let { withExternalLayout: a, parentSize: l } = t; if (!a && Ea(t) && l !== 1 && l !== 2) return; let { intrinsicWidth: u, intrinsicHeight: f, _constraints: d } = t; ((n = s.viewBox.baseVal) == null ? void 0 : n.width) === 0 && ((r = s.viewBox.baseVal) == null ? void 0 : r.height) === 0 && Q(u) && Q(f) && s.setAttribute("viewBox", `0 0 ${u} ${f}`), d && d.aspectRatio ? s.setAttribute("preserveAspectRatio", "") : s.setAttribute("preserveAspectRatio", "none"), s.setAttribute("width", "100%"), s.setAttribute("height", "100%") } function P4() { return b.useInsertionEffect(() => { Pa() }, []), null } var _4 = (() => { var e; return e = class extends qc { constructor() { super(...arguments), R(this, "container", b.createRef()), R(this, "svgElement", null), R(this, "setSVGElement", t => { this.svgElement = t, this.setLayerElement(t) }), R(this, "previouslyRenderedSVG", ""), R(this, "unmountedSVG", "") } static frame(t) { return ha(t, t.parentSize || 0) } get frame() { return ha(this.props, this.props.parentSize || 0) } componentDidMount() { if (this.unmountedSVG) { let { svgContentId: t } = this.props, n = t ? "svg" + t : null; Lo.subscribe(this.unmountedSVG, !t, n), this.previouslyRenderedSVG = this.unmountedSVG } this.props.svgContentId || US(this.container, this.props) } componentWillUnmount() { Lo.unsubscribe(this.previouslyRenderedSVG), this.unmountedSVG = this.previouslyRenderedSVG, this.previouslyRenderedSVG = "" } componentDidUpdate(t) { if (super.componentDidUpdate(t), this.props.svgContentId) return; let { fill: n } = this.props; Ei.isImageObject(n) && Ei.isImageObject(t.fill) && n.src !== t.fill.src && Mw(this.svgElement, "fill", null, !1), US(this.container, this.props) } collectLayout(t, n) { if (this.props.withExternalLayout) { n.width = "100%", n.height = "100%", n.aspectRatio = "inherit"; return } let r = this.frame, { rotation: i, intrinsicWidth: o, intrinsicHeight: s, width: a, height: l } = this.props, c = Ke.getNumber(i); if (t.opacity = Q(this.props.opacity) ? this.props.opacity : 1, oe.hasRestrictions() && r) { Object.assign(t, { transform: `translate(${r.x}px, ${r.y}px) rotate(${c.toFixed(4)}deg)`, width: `${r.width}px`, height: `${r.height}px` }), Ea(this.props) && (t.position = "absolute"); let u = r.width / (o || 1), f = r.height / (s || 1); n.transformOrigin = "top left"; let { zoom: d, target: p } = nu; if (p === oe.export) { let g = d > 1 ? d : 1; n.transform = `scale(${u * g}, ${f * g})`, n.zoom = 1 / g } else n.transform = `scale(${u}, ${f})`; o && s && (n.width = o, n.height = s) } else { let { left: u, right: f, top: d, bottom: p } = this.props; Object.assign(t, { left: u, right: f, top: d, bottom: p, width: a, height: l, rotate: c }), Object.assign(n, { left: 0, top: 0, bottom: 0, right: 0, position: "absolute" }) } } render() { let { id: t, visible: n, style: r, fill: i, svg: o, intrinsicHeight: s, intrinsicWidth: a, title: l, description: c, layoutId: u, className: f, variants: d, withExternalLayout: p, innerRef: g, svgContentId: v, height: S, opacity: m, width: h, ...y } = this.props; if (!p && (!n || !t)) return null; let x = t ?? u ?? "svg", k = this.frame, w = k || { width: a || 100, height: s || 100 }, T = { ...r, imageRendering: "pixelated", flexShrink: 0 }, E = {}; this.collectLayout(T, E), ED(this.props, T), hm(this.props, T), qc.applyWillChange(this.props, T, !1); let I = null; if (typeof i == "string" || W.isColorObject(i)) { let z = W.isColorObject(i) ? i.initialValue || W.toRgbString(i) : i; T.fill = z, T.color = z } else if (ma.isLinearGradient(i)) { let z = i, J = `${encodeURI(t || "")}g${ma.hash(z)}`; T.fill = `url(#${J})`; let { stops: ie, x1: se, x2: te, y1: re, y2: Qt } = c4(z, x); I = C("svg", { ref: this.setSVGElement, xmlns: "http://www.w3.org/2000/svg", width: "100%", height: "100%", style: { position: "absolute" }, children: C("linearGradient", { id: J, x1: se, x2: te, y1: re, y2: Qt, children: ie.map((fe, Pt) => C("stop", { offset: fe.position, stopColor: fe.color, stopOpacity: fe.alpha }, Pt)) }) }) } else if (va.isRadialGradient(i)) { let z = i, J = `${encodeURI(t || "")}g${va.hash(z)}`; T.fill = `url(#${J})`; let ie = u4(z, x); I = C("svg", { ref: this.setSVGElement, xmlns: "http://www.w3.org/2000/svg", width: "100%", height: "100%", style: { position: "absolute" }, children: C("radialGradient", { id: J, cy: z.centerAnchorY, cx: z.centerAnchorX, r: z.widthFactor, children: ie.stops.map((se, te) => C("stop", { offset: se.position, stopColor: se.color, stopOpacity: se.alpha }, te)) }) }) } else if (Ei.isImageObject(i)) { let z = f4(i, w, x); z && (T.fill = `url(#${z.id})`, I = C("svg", { ref: this.setSVGElement, xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", width: "100%", height: "100%", style: { position: "absolute" }, children: C("defs", { children: C(m4, { ...z }) }) })) } let F = { "data-framer-component-type": "SVG" }, B = !k; B && Object.assign(F, Rw(this.props.center)); let V = !I && !T.fill && !T.background && !T.backgroundImage && o.length < C4 && !T4(o) && !E4(o), K = null; if (V) T.backgroundSize = "100% 100%", T.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(o)}')`, Lo.unsubscribe(this.previouslyRenderedSVG), this.previouslyRenderedSVG = ""; else { let z = v ? "svg" + v : null, J = Lo.subscribe(o, !v, z); Lo.unsubscribe(this.previouslyRenderedSVG), this.previouslyRenderedSVG = o, R4(T) && (T.overflow = "hidden"), K = ae(Le, { children: [I, C("div", { className: "svgContainer", style: E, ref: this.container, dangerouslySetInnerHTML: { __html: J } }, Ei.isImageObject(i) ? i.src : "")] }) } let Z = pu(this.props.as), { href: j, target: ne, rel: U, onClick: X } = this.props; return ae(Z, { ...F, ...y, layoutId: u, transformTemplate: B ? mu(this.props.center) : void 0, id: t, ref: g, style: T, className: f, variants: d, tabIndex: this.props.tabIndex, role: l || c ? "img" : void 0, "aria-label": l, "aria-description": c, href: j, target: ne, rel: U, onClick: X, children: [K, C(P4, {})] }) } }, R(e, "supportsConstraints", !0), R(e, "defaultSVGProps", { left: void 0, right: void 0, top: void 0, bottom: void 0, style: void 0, _constraints: { enabled: !0, aspectRatio: null }, parentSize: 0, rotation: 0, visible: !0, svg: "", shadows: [] }), R(e, "defaultProps", { ...qc.defaultProps, ...e.defaultSVGProps }), e })(); function hH(e, t, n) { let r = Ok(t); !n?.supportsExplicitInterCodegen && !r.some(i => i.explicitInter === !1) && r.push({ explicitInter: !1, fonts: [] }), Object.assign(e, { fonts: r }) } function pH(e) { return e.fonts ?? [] } function mH(e) { return e.length === 0 ? [{ explicitInter: !1, fonts: [] }] : Ok(e) } function Ok(e) { let t = { explicitInter: !1, fonts: [] }, n = []; for (let r of e) I4(r) ? n.push(r) : t.fonts.push(L4(r)); return t.fonts.length > 0 && n.push(t), n } var F4 = "explicitInter"; function I4(e) { return F4 in e } function L4(e) { let t; return e.url.startsWith("https://fonts.gstatic.com/s/") ? t = "google" : e.url.startsWith("https://framerusercontent.com/third-party-assets/fontshare/") ? t = "fontshare" : t = "custom", { ...e, source: t } } dl.prototype.addChild = function ({ transformer: e = t => t }) { let t = Ee(e(this.get())); return this.onChange(n => t.set(e(n))), t };/**
 * @license Emotion v11.0.0
 * MIT License
 *
 * Copyright (c) Emotion team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *//*! Bundled license information:

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/export { b as a, Rn as b, Uo as c, mn as d, ge as e, Du as f, $m as g, Ne as h, Ai as i, pe as j, O as k, hC as l, H as m, ei as n, pC as o, ct as p, Pn as q, he as r, D as s, ut as t, _t as u, Le as v, C as w, ae as x, On as y, Jn as z, Y as A, Nt as B, od as C, Wy as D, An as E, St as F, YP as G, Ky as H, Qy as I, Qi as J, f_ as K, Jy as L, h_ as M, wp as N, $F as O, qF as P, iI as Q, Q$ as R, tz as S, Ta as T, du as U, dz as V, sw as W, gz as X, W as Y, oe as Z, Pz as _, ZL as $, Mz as aa, GM as ba, Oz as ca, ww as da, Nz as ea, pm as fa, QA as ga, yN as ha, SN as ia, TN as ja, EN as ka, LN as la, rk as ma, sV as na, BN as oa, HN as pa, _V as qa, jV as ra, UN as sa, XN as ta, YN as ua, ZN as va, n8 as wa, r8 as xa, t5 as ya, xk as za, i8 as Aa, l5 as Ba, o8 as Ca, s8 as Da, a8 as Ea, c8 as Fa, d8 as Ga, h8 as Ha, b8 as Ia, S8 as Ja, x5 as Ka, k8 as La, T8 as Ma, R8 as Na, _8 as Oa, eu as Pa, G8 as Qa, J8 as Ra, Lo as Sa, rH as Ta, hH as Ua, pH as Va, mH as Wa };
//# sourceMappingURL=chunk-VUOZ7AWS.mjs.map
